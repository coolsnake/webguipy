import base64
import pickle
import uuid
import json
import time
import hashlib
import traceback
import os
import sys
import glob
#import filestubs
import imp
import re
from bson.objectid import ObjectId
from datetime import timedelta, datetime
import urllib2
#import ziptestweb

"""
set platform seperator for library to use
"""
platform=sys.platform
if platform[0:3]=="win":
    sep="\\"
elif platform[0:3]=="lin":
    sep="/"
else:
    sep="/"


def formatExceptionInfo(cache=None,spoolid=""):
    """
    format traceback information to run after an exception and pass back to the user

    :param cache:  cache memory object to store error
    :param spoolid: spool id to identify user
    """
    maxTBlevel=5
    cla, exc, trbk = sys.exc_info()
    excName = cla.__name__
    try:
        excArgs = exc.__dict__["args"]
    except KeyError:
        excArgs = "<no args>"
    excTb = traceback.format_tb(trbk, maxTBlevel)
    if not cache is None:
        if spoolid!="":
            cache.append("TraceBack"+spoolid,[cla,exc,trbk,excName,excArgs,excTb])
    aTB=""
    for tb in excTb:
       aTB+="    "+tb.lstrip(" ")+"\n"
    return "ExecName: "+str(excName)+"\nArguments: "+str(excArgs)+"\nTraceBack:\n"+str(aTB)

class EmptyObj(object):
    """
    Empty Session Object Class
    """

    def __init__(self):
        """
        empty init of class
        """
        pass

    def append(self,key,item):
        """
        append call for class to add values to itself

        :param key:
        :param item:
        """
        self.__dict__[key]=item

class DictChanges(object):
    """
    This class is to get the changes and additions in a didctionary
    """
 
    def __init__(self, newdict, olddict):
        """
        Initilize the two dictionaries in order to calculate the difference in the two

        :param newdict: this is the new formulation of the dictionary
        :param olddict: this is the old dictionary for comparison
        """
        self.newdict = newdict
        self.olddict = olddict
        self.setnew = set(newdict.keys())
        self.setold = set(olddict.keys())
        self.theintersect = self.setnew.intersection(self.setold)

    def changed(self):
        """
        Return the changed items for the difference in the dictionaries
        """ 
        retDict = {}
        for o in self.theintersect:
            if str(self.olddict[o]) != str(self.newdict[o]):
                retDict[o]=self.newdict[o]
        return retDict

    def added(self):
        """
        Return the added items for the difference in the dictionaries
        """
        retDict = {}
        addset = self.setnew - self.theintersect
        for o in addset:
            retDict[o]=self.newdict[o]
        return retDict


class spool(object):
    """
    This class is the mainwindow class of the gui that gets generated by the javascript.  Functions in this class control the mainwindow and various core functions
    of the environment itself
    """

    def __init__(self,cache):
        """
        Initialize the spool class

        :param cache: the global memory cache for the current session
        """
        self.startAPICall()
        self.type               = "WINDOW"
        self.name               = "window"
        self.threadID           = ""
        self.sessionObj         = EmptyObj()
        self.connTable          = False
        self.cache              = cache
        self.clientBuffer       = []
        self.isValid            = 1
        self.addingClientSignal = False
        self.autoDone           = False
        self.uiRef              = ""
        self.acnt               = 20000
        self.globalDict         = {}

        self.IntOnly      = 101
        self.FloatOnly    = 102
        self.StrOnly      = 103
        self.EmailOnly    = 104
        self.PhoneOnly    = 105
        self.DateOnly     = 106
        self.StrNoSpaces  = 107
        self.ZipCode      = 108
        
        self.STATES = ['AK - Alaska','AL - Alabama','AR - Arkansas','AS - American Samoa','AZ - Arizona','CA - California','CO - Colorado','CT - Connecticut','DC - District of Columbia','DE - Delaware','FL - Florida','GA - Georgia','GU - Guam','HI - Hawaii','IA - Iowa','ID - Idaho','IL - Illinois','IN - Indiana','KS - Kansas','KY - Kentucky','LA - Louisiana','MA - Massachusetts','MD - Maryland','ME - Maine','MI - Michigan','MN - Minnesota','MO - Missouri','MP - Northern Mariana Islands','MS - Mississippi','MT - Montana','NA - National','NC - North Carolina','ND - North Dakota','NE - Nebraska','NH - New Hampshire','NJ - New Jersey','NM - New Mexico','NV - Nevada','NY - New York','OH - Ohio','OK - Oklahoma','OR - Oregon','PA - Pennsylvania','PR - Puerto Rico','RI - Rhode Island','SC - South Carolina','SD - South Dakota','TN - Tennessee','TX - Texas','UT - Utah','VA - Virginia','VI - Virgin Islands','VT - Vermont','WA - Washington','WI - Wisconsin','WV - West Virginia','WY - Wyoming']
        self.startAPICall()

    def spinSpool(self,parent,theid,tracelog,dbconn,cursor,modname):
        """
        This function is for spinning up the spool with the stored memory that it needs for the environment during each function call called during a signal

        :param parent:
        :param theid:
        :param tracelog:
        :param dbconn:
        :param cursor:
        :param modname:
        """
        self.startAPICall()
        self.currentModName = modname
        self.parent         = parent
        self.spoolID        = theid
        self.dbconn         = dbconn
        self.cursor         = cursor
        self.tracelog       = tracelog
        self.software       = parent.parent.software
        self.entrypoint     = parent.parent.entrypoint
        self.uiSpoolID      = parent.parent.uiSpoolID
        self.env            = parent.parent.theEnv
        self.valueBuffer    = []
        self.typeTransMat   = {"BUTTON"      : {"clicked"          : ["clicked()",            "    def %s_clicked(self)\n"],
                                                "pressed"          : ["pressed()",            "    def %s_pressed(self)\n"],
                                                "released"         : ["released()",           "    def %s_released(self)\n"]},
                               "LINEEDIT"    : {"returnPressed"    : ["returnPressed()",      "    def %s_returnPressed(self)\n"],
                                                "textChanged"      : ["textChanged(QString)", "    def %s_textChanged(self,theText)\n"],
                                                "editingFinished"  : ["editingFinished()",    "    def %s_editingFinished(self)\n"]}
                              }
        self.stopAPICall()
         
    
    def beforeCall(self,*args):
        """
        This function will run before the api function call and will be called with the same arguments as the function

        :param *args:
        """
        pass

    def afterCall(self,*args):
        """
        This function will run after the api function call and will be called with the same arguments as the function

        :param *args:
        """
        #subclass me
        pass

    def widgetSigTranslate(self,defstring):
        """
        Used from outside this module to translate functions that contain _signalname so that addsignal is not needed

        :param defstring:
        """
        #TODO CURRENTLY DOES NOT WORK DECIDE WEHTER TO KEEP THIS FEATURE
        wName   = defstring[:defstring.rfind("_")]
        sigtype = defstring[defstring.rfind("_"):].lstrip("_").split("(")[0]
        if wName in self.getWidgetDict():
            if self.__dict__.has_key(wName):
                if self.typeTransMat.has_key(self.__dict__[wName].type):
                    if self.typeTransMat[self.__dict__[wName].type].has_key(sigtype):
                        self.addSignal(self.__dict__[wName],self.typeTransMat[self.__dict__[wName].type][sigtype][0],wName+"_"+sigtype)

    def startAPICall(self):
        """
        Runs before an API call starts to disable any storage to cache that may occur automatically during a self.cacheSet call
        """
        self.__dict__['storeSet']=False

    def stopAPICall(self):
        """
        Runs after an API call ends to enable any storage to cache that is needed during running of non api functions in the module code
        """
        self.__dict__['storeSet']=True

    def passCall(self,directive,immediate=True,addon=""):
        """
        Passes a directive into the spool to be picked up by the browser and processed to control the gui

        :param directive:
        :param immediate:
        :param addon:
        """
        if self.addingClientSignal:
            self.clientBuffer.append(directive)
            self.stopAPICall()
            return
        elif immediate:
            self.clientBuffer=[directive]
        else:
            self.valueBuffer.append(directive)
            self.stopAPICall()
            return
        if addon!="":
            self.cache.append(self.spoolID+"send"+self.threadID,directive+["HINT:"+self.moduleUN]+[addon])
        else:
            try:
                self.cache.append(str(self.spoolID+"send"+self.threadID),directive+["HINT:"+self.moduleUN])
            except:
                self.cache.append(str(self.spoolID+"send"+self.threadID),directive)

    def tr(self, words):
        """
        Function for translating words and phrases in the system.
        This is meant to be used to wrap all words that the end user sees and translate on the fly

        :param words: string with word or phrase
        """
        #TODO build system of translating words and phrases
        #return words[::-1] # test to reverse all words
        return words

    def setUserPresence(self,userID,isPresent=True):
        """
        Set presence with a timestamp in global cache in the framework

        :param userID:
        :param isPresent:
        """
        self.startAPICall()
        presence = self.cache.get("userPresence"+self.software)
        if isPresent==True:
            if presence==[]:
                presence={userID:time.time()}
            else:
                presence[userID]=time.time()
        else:
            if presence==[]:
                pass
            else:
                try:
                    presence.pop(userID)
                except:
                    pass
        self.cache.set("userPresence"+self.software,presence)
        self.stopAPICall()

    def toJulian(self,theDate=None):
        """
        Convert a date to julian (defined as how many days since 1/1/1980) or pass the julian for today if no params
        
        :param theDate: date %m/%d/%y or GMT format %b %d %Y
        """
        foxStart= datetime.strptime("01/01/1980","%m/%d/%Y")
        if theDate==None:theday = datetime.now()
        else:
            if "GMT" in theDate:
                theDate = " ".join(theDate.split(" ")[1:4])
                theday = datetime.strptime(theDate,"%b %d %Y")
            else:
                theday = datetime.strptime(theDate,"%m/%d/%Y")
        if foxStart==theday:return 0
        julian = str(theday-foxStart).split(" ")[0]
        return int(julian)

    def fromJulian(self,theNumber=None):
        """
        Convert a julian (defined as how many days since 1/1/1980) to a legitamate date

        :param theNumber: numeric
        """
        try:
            foxStart= datetime.strptime("01/01/1980","%m/%d/%Y")
            if theNumber is None:
                theNumber = self.toJulian()
            dateString = foxStart + timedelta(days=int(theNumber))
            #TODO get locale to determine how to return the date
            dateString = dateString.strftime("%m/%d/%Y")[0:10]
            return dateString
        except:
            return ""

    def setDebugLines(self,modname,*debugLines):
        """
        set debug lines for debugging
        
        :param modulename:
        :param *debugLines:
        """
        self.startAPICall()
        self.cache.set("debugLines"+modname+self.uiSpoolID,[modname,debugLines])
        self.stopAPICall()

    def getDebugLines(self,modname,spoolID):
        """
        get a list of debug lines for debugging

        :param modname:
        :param spoolID:
        """
        self.startAPICall()
        self.cache.get("debugLines"+modname+spoolID)
        self.stopAPICall()

    def __setattr__(self, item, value):
        """
        subclass magic method that during a set it will store values for the class outside of an api call

        :param item:
        :param value:
        """
        if self.__dict__.has_key(item):
            if "Widget object" in repr(self.__dict__[item]):
                self.__dict__[item].setVal(value)
                ret=None
            else:
                ret=dict.__setattr__(self, item, value)
                self.cacheSet(item,value)
        else:
            ret=dict.__setattr__(self, item, value)
            self.cacheSet(item,value)
        return ret
            

    def set(self,item,value,protected=False):
        """
        set a global variable in the api to be retrieved by get
        """
        self.startAPICall()
        self.__dict__[item]=value
        if self.__dict__.has_key("cache"):
            self.cache.set("sessionObj"+self.uiSpoolID+self.currentModName+item,value)
            storedVals = self.cache.get("storedSets"+self.uiSpoolID+self.currentModName)
            if not [str(item),True] in storedVals and not [str(item),False] in storedVals:
                self.cache.append("storedSets"+self.uiSpoolID+self.currentModName,[str(item),protected])
        self.stopAPICall()

    def getMain(self,timeout=15):
        """
        get return data from the remote gui environment on a blocking function
        """
        acnt=0
        while True:
            currdata=self.cache.get(self.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==timeout*10:
                currdata=""
                break
            if currdata!=[]:
               self.cache.delete(self.spoolID+"receive"+self.threadID)
               break
        return currdata
    
    def cacheSet(self,item,value,protected=False,widgetname=""):
        """
        sets a class value in memory to be regenerated on other events
        """
        if self.__dict__.has_key("storeSet"):
            if self.storeSet:
                self.cache.set("sessionObj"+self.uiSpoolID+self.currentModName+widgetname+item,value)
                storedVals = self.cache.get("storedSets"+self.uiSpoolID+self.currentModName+widgetname)
                if not [str(item),True] in storedVals and not [str(item),False] in storedVals:
                    self.cache.append("storedSets"+self.uiSpoolID+self.currentModName+widgetname,[str(item),protected])
        else:
            print("not saving item")
    
    def cacheUnSet(self,key):
        """
        remove stored sets from the cache of a session
        """
        widgetList = self.cache.get("storedSets"+self.uiSpoolID+self.currentModName+key)
        for akey,avalue in widgetList:
            self.cache.remove("sessionObj"+self.uiSpoolID+self.currentModName+key+akey)
        self.cache.remove("storedSets"+self.uiSpoolID+self.currentModName+key)
    
    def get(self,item,widgetname=""):
        """
        get a global variable that was set with the "set" function
        """
        self.startAPICall()
        value=self.cache.get("sessionObj"+self.uiSpoolID+self.currentModName+item+widgetname)
        if widgetname=="":
            self.__dict__[item]=value
        else:
            self.__dict__[widgetname].__dict__[item]=value
        self.stopAPICall()
        return str(value)

    def delete(self,item):
        """
        delete a global variable that was set with the "set" function
        """
        self.startAPICall()
        self.cache.delete("sessionObj"+self.uiSpoolID+self.currentModName+item)
        self.stopAPICall()

    def updateWidgets(self,widget,wtype):
        """
        internally used to update widgets that get created by other functions
        """
        self.startAPICall()
        widgetDict=self.cache.get(self.software+"uiDict"+self.uiSpoolID+self.currentModName)
        if widgetDict==[]:widgetDict={}
        widgetDict[widget]=wtype
        self.cache.set(self.software+"uiDict"+self.uiSpoolID+self.currentModName,widgetDict)
        self.stopAPICall()
        
    def cleanupThreads(self):
        self.startAPICall()
        directive=['cleanupthreads','',self.currentModName]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()
        
    def getCOMGlobals(self):
        self.startAPICall()
        directive=['getcomglobals','',self.spoolID,'']+['blockingCall']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        currdata = self.getMain(999)
        self.stopAPICall()
        return currdata
        
    def getWidgetDict(self):
        self.startAPICall()
        widgetDict=self.cache.get(self.software+"uiDict"+self.uiSpoolID+self.currentModName)
        self.stopAPICall()
        return widgetDict

    def setBeforeCall(self,adef):
        self.startAPICall()
        self.cache.set("beforeCall"+self.uiSpoolID+self.currentModName,adef.__name__)
        self.stopAPICall()
        
    def setAfterCall(self,adef):
        self.startAPICall()
        self.cache.set("afterCall"+self.uiSpoolID+self.currentModName,adef.__name__)
        self.stopAPICall()

    #create a widget in the current scope
    def addressWidget(self,widget,atype,parentWidget=None,customlib="",addressClass=None):
        self.startAPICall()
        if addressClass is None:addressClass=Widget
        widget=str(widget)
        atype = atype.upper()
        if customlib!="":
            self.__dict__[widget] = self.getSoftwareModule(customlib).module
            self.__dict__[widget] = self.__dict__[widget](self,widget,atype,parentWidget)
            self.cache.set("storedSets"+self.uiSpoolID+self.currentModName+widget+"lib",customlib)
        else:
            self.__dict__[widget]=addressClass(self,widget,atype,parentWidget)
        self.updateWidgets(widget,atype)
        self.stopAPICall()
        
    #add a signal to a widget and set code server side that will run when that signal is triggered
    def addSignal(self,widget,signal,calldef,*returnargs,**kwargs):
        kwargList = ['returnvals','sigallow','calldefwidget','timeout','keytimeout']
        for argname in kwargs.keys():
            if not argname in kwargList:
                raise Exception("Invalid keywork argument " + argname + " in addSignal")
        self.startAPICall()
        threadtype="unthreaded"
        if not type(widget) is str:
            theType      = widget.type
            if widget.type=="TIMER":
                threadtype="unthreaded"
            widget=widget.name
        else:
            if "." in widget:
                theType = self.__dict__[widget.split(".")[-1]].type
            else:
                theType = self.__dict__[widget].type
        try:
            parentWidget = self.__dict__[widget].parentWidget
            if not parentWidget is None:
                parentWidgetType=parentWidget.type
                parentWidget=parentWidget.name
            else:
                parentWidget=""
                parentWidgetType=""
        except:
            parentWidget=""
            parentWidgetType=""
        if not type(calldef) is str:calldef=calldef.__name__
        if theType=="TABLE" and signal.lower()=="onsearchselect":
            self.__dict__[widget].addSearchCallback(calldef)
            return
        if theType=="TABLE" and signal.lower()=="onkbreturn":
            self.__dict__[widget].addKbCallback(calldef)
            return
        retargs = '|**|'.join(returnargs)
        if "sigallow" in kwargs:
            sigallow=kwargs['sigallow']
        else:
            sigallow=False
        if "timeout" in kwargs:
            timeout=kwargs['timeout']
            if int(timeout) <20:
                timeout = int(timeout)*100
        elif signal=="onChange":
            timeout = 0
        else:
            timeout=100
        if "keytimeout" in kwargs:
            keytimeout=kwargs['keytimeout']
            if int(timeout) <20:
                keytimeout = int(timeout)*100
        else:
            keytimeout=1200
        retvals = ""
        if "returnvals" in kwargs:
            for aretval in kwargs['returnvals']:
                try:
                    retvals+=aretval.name+"(*)"+aretval.type+"[&]"
                except:
                    retvals+=str(aretval)+"(*)GLOBAL[&]"
        cdefwidget = ""
        if "calldefwidget" in kwargs:
            if type(kwargs['calldefwidget']) is str:
                cdefwidget=kwargs['calldefwidget']
            else:
                cdefwidget=kwargs['calldefwidget'].name
        directive=['signal',widget,signal,calldef,self.currentModName,threadtype,theType,parentWidget,parentWidgetType,retargs,sigallow,retvals,cdefwidget,keytimeout,timeout]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    def addWebSocket(self,socketname,wsurl,wsprotocol):
        self.startAPICall()
        directive=['addwebsocket',"mainwindow",socketname,"WINDOW",wsurl,wsprotocol]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.addressWidget(socketname,"WEBSOCKET")
        self.updateWidgets(socketname,"WEBSOCKET")
        self.stopAPICall()
 
    def createMainWindow(self,pattern,skin):
        self.startAPICall()
        directive=['createmainwindow',"mainwindow",pattern,"WINDOW",skin]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.addressWidget("mainwindow","WINDOW")
        self.updateWidgets("mainwindow","WINDOW")
        self.stopAPICall()

    def addToolbar(self,toolBarWidget,iconsize=32,alignment="left"):
        self.startAPICall()
        if type(toolBarWidget) != str:toolBarWidget = toolBarWidget.name
        self.addressWidget(toolBarWidget,"TOOLBAR")
        directive=['addtoolbar',"mainwindow",toolBarWidget,"WINDOW",iconsize,alignment]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    def addMenu(self,menuWidget):
        self.startAPICall()
        if type(menuWidget) != str:menuWidget = menuWidget.name
        self.addressWidget(menuWidget,"MENU")
        directive=['addmenu',"mainwindow",menuWidget,"WINDOW"]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    def addLayout(self,layoutWidget,pattern,cell="a"):
        self.startAPICall()
        if type(layoutWidget) != str:layoutWidget = layoutWidget.name
        directive=['addlayout',"mainwindow",layoutWidget,self.type,cell,pattern]
        self.passCall(directive)
        self.addressWidget(layoutWidget,"LAYOUT")
        self.stopAPICall()
   
    def addForm(self,formWidget,formdata,cell="a"):
        self.startAPICall()
        if type(formWidget) != str:formWidget = formWidget.name
        directive=['addform',"mainwindow",formWidget,self.type,cell,formdata]
        self.passCall(directive)
        self.addressWidget(formWidget,"FORM")
        self.stopAPICall()
 
    def setStyle(self,skin):
        self.startAPICall()
        directive=['setstyle',"mainwindow",skin,"WINDOW"]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()
        
    def removeToolBar(self,toolBarWidget):
        self.startAPICall()
        if type(toolBarWidget) != str:toolBarWidget = toolBarWidget.name
        directive=['removetoolbar',"","",toolBarWidget]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()
        
    def addToolBarBreak(self,toolBarWidget):
        self.startAPICall()
        if type(toolBarWidget) != str:toolBarWidget = toolBarWidget.name
        directive=['addtoolbarbreak',"","",toolBarWidget]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    def setFutureCall(self,calldef,waittime=2.0):
        self.startAPICall()
        if not type(calldef) is str:calldef=calldef.__name__
        directive=['setfuturecall',calldef,self.currentModName,waittime]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    def makeTimer(self,widgetName,interval,calldef=""):
        self.startAPICall()
        if not type(calldef) is str:calldef=calldef.__name__
        self.addressWidget(widgetName,"TIMER")
        directive=['maketimer',widgetName,calldef,interval]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    def makeStopWatch(self,elementName):
        self.startAPICall()
        self.addressWidget(elementName,"STOPWATCH")
        directive=['makestopwatch',elementName]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    def setGlobalCaretInsert(self,keyCode,insertString):
        self.startAPICall()
        directive=['setglobalcaretinsert',keyCode,insertString]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()
        
    def storeSoftwareSetting(self,setting,value):
        self.startAPICall()
        directive=['storesoftwaresetting',setting,value]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    def getSoftwareSetting(self,setting,default=""):
        self.startAPICall()
        directive=['getsoftwaresetting',setting,self.spoolID,default]+['blockingCall']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.cache.get(self.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.cache.delete(self.spoolID+"receive"+self.threadID)
               break
        self.stopAPICall()
        return currdata

    def getRemoteWidgets(self,parent="mainwindow",parentWidget=None,internal=False):
        self.startAPICall()
        if internal:
            if not parentWidget is None:
                parentWidget.addressWidget("dhxWins","WINDOWMANAGER")
            else:
                self.addressWidget("dhxwins","WINDOWMANAGER")
        directive=['getwidgets',parent,self.spoolID]+['blockingCall']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.cache.get(self.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.cache.delete(self.spoolID+"receive"+self.threadID)
               break
        self.stopAPICall()
        if currdata!="":
            try:
                adict = json.loads(currdata)
            except:
                adict = {}
            for key,value in adict.items():
                if key!="widgettype":
                    if not parentWidget is None:
                        parentWidget.addressWidget(key,value)
                    else:
                        self.addressWidget(key,value)
        else:
            adict = {}
        return adict

    def setExitDef(self,calldef):
        self.startAPICall()
        if not type(calldef) is str:calldef=calldef.__name__
        directive=['setexitdef',"","",calldef,self.currentModName]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    def closeEventCallback(self,calldef):
        self.startAPICall()
        if not type(calldef) is str:calldef=calldef.__name__
        directive=['closeeventcallback',"","","","",self.currentModName,calldef]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()
        
    def cancelSignal(self):
        self.startAPICall()
        directive=['cancelsignal']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    #add a signal to a widget and send the directives to the client side to be executed
    #so that any simple thing that the client can do will be done there instead of talking
    #to the server to do simple tasks
    def addClientSignal(self,buttonWidget,signal,directive,threaded="threaded",actionDef="",*defArgs):
        self.startAPICall()
        self.addingClientSignal=True
        if type(buttonWidget) != str:buttonWidget = buttonWidget.name
        if type(actionDef)    != str:actionDef    = actionDef.__name__
        self.clientBuffer=[]
        try:
            if len(defArgs)>0:
                directive(*defArgs)
            else:
                directive()
        except:
            pass
        import copy
        dirList=copy.deepcopy(self.clientBuffer)
        self.clientBuffer=[]
        directive=['clientsignal',buttonWidget,[],[],dirList,signal,self.currentModName,actionDef,threaded]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.addingClientSignal=False
        self.stopAPICall()

    #add a process that will run a program on the client side
    def addProcess(self,processName,program, arguments=[], modal=False, asoftware="", actionDef="", stdOutDef=""):
        self.startAPICall()
        #sender = self.getSender()
        if type(processName) != str:processName=processName.__name__
        if type(actionDef)   != str:actionDef    = actionDef.__name__
        if type(stdOutDef)   != str:stdOutDef    = stdOutDef.__name__
        self.addressWidget(processName,"PROCESS")
        self.updateWidgets(processName,"PROCESS")
        directive=['addprocess',processName,program,arguments,modal,asoftware,actionDef,self.spoolID,self.currentModName,stdOutDef]
        if self.addingClientSignal:
            self.clientBuffer.append(directive)
            self.stopAPICall()
            return
        else:
            self.clientBuffer=[directive]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    def setTalkBox(self,talkboxWidget):
        self.startAPICall()
        #self.tracelog.subscribeWidget(talkboxWidget)
        if not type(talkboxWidget) is str:talkboxWidget=talkboxWidget.name
        directive=['talkbox',talkboxWidget]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()
        
    def setWindowFocusDef(self, actionDef):
        self.startAPICall()
        if type(actionDef) != str:actionDef=actionDef.__name__
        directive=['setwindowfocusdef',actionDef,self.currentModName]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    def hasClipboardText(self):
        self.startAPICall()
        directive=['hasclipboardtext',self.spoolID]+['blockingCall']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.cache.get(self.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.cache.delete(self.spoolID+"receive"+self.threadID)
               break
        self.stopAPICall()
        return currdata
        
    def enableRestore(self,abool):
        self.startAPICall()
        directive=['enablerestore',abool]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    #add a signal to a widget that will trigger a process that was created
    def addProcessSignal(self,widget,signal,calldef,threadtype="threaded"):
        self.startAPICall()
        if not type(widget) is str:widget=widget.name
        if not type(calldef) is str:calldef=calldef.name
        directive=['signal',widget,signal,calldef,self.currentModName,threadtype]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    #resize the currently active window
    def resizeWindow(self,width,height):
        self.startAPICall()
        directive=['mainresize',str(width),str(height)]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()
        
    #listen to all keystrokes typed into a specific widget also define the
    #key that will stop the listening and the function to run server side
    #when listening is done
    def keyListen(self,valueSet,listenWidgets,typeValueActions,actionDef):
        self.startAPICall()
        if type(valueSet)  != str:valueSet=valueSet.name
        if type(actionDef) != str:actionDef=actionDef.__name__
        directive=['keylisten',valueSet,self.currentModName,listenWidgets,typeValueActions,actionDef]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    #get a global that is stored on the client side
    def getGlobal(self,value):
        self.startAPICall()
        directive=['getglobal',value,self.spoolID,"VALUE"]+['blockingCall']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.cache.get(self.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.cache.delete(self.spoolID+"receive"+self.threadID)
               break
        self.stopAPICall()
        return currdata

    def getWindowTitle(self):
        self.startAPICall()
        directive=['getwindowtitle',self.spoolID]+['blockingCall']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.cache.get(self.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.cache.delete(self.spoolID+"receive"+self.threadID)
               break
        self.stopAPICall()
        return currdata

    def setWindowTitle(self,text):
        self.startAPICall()
        directive=['setwindowtitle',self.spoolID,text]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    def setWindowSize(self,width,height):
        self.startAPICall()
        directive=['setwindowsize',self.spoolID,str(width),"",str(height)]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    #return data from a dialog box
    def returnData(self,*args):
        self.startAPICall()
        directive=['returndata',self.uiSpoolID,args]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    #set a global that is stored on the client side
    def setGlobal(self,value,text):
        self.startAPICall()
        directive=['setglobal',value,self.spoolID,"VALUE",text]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()
        setattr(self,value,text)

    #fill up the client clipboard with some data
    def loadClipboard(self,text):
        self.startAPICall()
        directive=['loadclipboard',text,self.spoolID,"TEXT"]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    def storeState(self,widget,whattostore,default=""):
        self.startAPICall()
        if type(widget) != str:awidget=widget.name
        else:awidget="NONE"
        if type(widget) != str:atype=widget.type
        else:atype="NONE"
        directive=['storestate',awidget,self.spoolID,atype,whattostore.upper(),default]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    #show a message box on the client screen
    def messageBox(self,title,message="",blocking=True,name=""):
        self.startAPICall()
        if message=="":message=title;title="pop"
        self.cache.delete(self.spoolID+"receive"+self.threadID)
        if blocking:
            thedir="messagebox"
        #else:
        #    thedir="messageboxnr"
        #    self.addressWidget(name,"MESSAGEBOX")
        directive=[thedir,title,self.spoolID,message,name]+['blockingCall']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        acnt=0
        currdata=""
        while blocking:
            currdata=self.cache.get(self.spoolID+"receive"+self.threadID)
            time.sleep(0.05)
            if currdata!=[]:
               self.cache.delete(self.spoolID+"receive"+self.threadID)
               break
            if acnt==self.acnt:
                currdata=False
                break
            acnt+=1
        self.stopAPICall()
        return currdata

    #show a message box on the client screen
    def colorDialog(self,title):
        self.startAPICall()
        self.cache.delete(self.spoolID+"receive"+self.threadID)
        directive=["colordialog",title,self.spoolID]+['blockingCall']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        acnt=0
        currdata=""
        while True:
            currdata=self.cache.get(self.spoolID+"receive"+self.threadID)
            time.sleep(0.05)
            if currdata!=[]:
               self.cache.delete(self.spoolID+"receive"+self.threadID)
               break
            if acnt==self.acnt:
                currdata=False
                break
            acnt+=1
        self.stopAPICall()
        return currdata

    def getResolution(self):
        self.startAPICall()
        self.cache.delete(self.spoolID+"receive"+self.threadID)
        directive=["getresolution","",self.spoolID]+['blockingCall']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        acnt=0
        currdata=""
        while True:
            currdata=self.cache.get(self.spoolID+"receive"+self.threadID)
            time.sleep(0.05)
            if currdata!=[]:
               self.cache.delete(self.spoolID+"receive"+self.threadID)
               break
            if acnt==self.acnt:
                currdata=False
                break
            acnt+=1
        self.stopAPICall()
        return currdata
        
    def getPrinterList(self):
        self.startAPICall()
        self.cache.delete(self.spoolID+"receive"+self.threadID)
        directive=["getprinterlist","",self.spoolID]+['blockingCall']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        acnt=0
        currdata=""
        while True:
            currdata=self.cache.get(self.spoolID+"receive"+self.threadID)
            time.sleep(0.05)
            if currdata!=[]:
               self.cache.delete(self.spoolID+"receive"+self.threadID)
               break
            if acnt==self.acnt:
                currdata=False
                break
            acnt+=1
        self.stopAPICall()
        return currdata

    def storedata(self,key,value):
        self.startAPICall()
        if self.env == "webgui":
            self.parent.cache.set(key,value)
        else:
            pickled_value = pickle.dumps(value)
            self.cache.set(key,pickled_value)
        self.stopAPICall()

    def dataFill(self,lun,data,fields,procname):
        self.startAPICall()
        if not type(procname) is str:procname=procname.name
        dataid=str(uuid.uuid1()).lstrip("{").rstrip("}").replace("-","")
        directive=['datafill',str(lun),dataid,'',fields,procname]
        self.addressWidget("db"+str(lun),"DATABUCKET")
        self.storedata(dataid,data)
        if self.addingClientSignal:
            self.clientBuffer.append(directive)
            self.stopAPICall()
            return
        else:
            self.clientBuffer=[directive]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    def makeSocketObject(self,objectName,hostname="",port=0):
        self.startAPICall()
        directive=['makesocketobject',objectName,hostname,port]
        self.addressWidget(objectName,"TCPSOCKET")
        if self.addingClientSignal:
            self.clientBuffer.append(directive)
            self.stopAPICall()
            return
        else:
            self.clientBuffer=[directive]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    def http_request(self,hostname,request_data,urlAddon="",datatype="plain",ssl=False,username="",password=""):
        self.httpError = ""
        if ssl:url = "https://%s" % hostname
        else:url = "http://%s" % hostname
        
        if username!="":
            passManager = urllib2.HTTPPasswordMgrWithDefaultRealm()
            passManager.add_password(None,url,username,password)
            
            authHandler = urllib2.HTTPDigestAuthHandler(passManager)
            urlOpener = urllib2.build_opener(authHandler)
            
        else:
            urlOpener = urllib2.build_opener()
        
        if "/" in datatype:
            if request_data is None:
                pass
            elif len(request_data)==0:
                #urlOpener.add_headers={'Content-Type':datatype}
                pass
            else:
                urlOpener.add_headers={'Host':hostname, 'Content-Type':datatype, 'Content-Length':str(len(request_data))}
        else:
            urlOpener.add_headers={'Host':hostname, 'Content-Type':'text'+datatype, 'Content-Length':str(len(request_data))}
        
        try:
            if request_data=="":
                req = urlOpener.open(url+"/"+urlAddon)
            else:
                req = urlOpener.open(url+"/"+urlAddon,data=request_data)
        except urllib2.HTTPError as e:
            req = e
            self.httpError = str(e.code) + " " +  str(e)
        
        result=req.read()

        return result

    def http_requestA(self,hostname,request_data,urlAddon="",datatype="plain",ssl=False,username="",password="",method="POST"):
        self.httpError = ""
        if ssl:url = "https://%s" % hostname
        else:url = "http://%s" % hostname

        if username!="":
            passManager = urllib2.HTTPPasswordMgrWithDefaultRealm()
            passManager.add_password(None,url,username,password)

            authHandler = urllib2.HTTPDigestAuthHandler(passManager)
            urlOpener = urllib2.build_opener(authHandler)

        else:
            handler = urllib2.HTTPHandler()
            urlOpener = urllib2.build_opener(handler)

        if "/" in datatype:
            if request_data is None:
                pass
            elif len(request_data)==0:
                add_headers={'Content-Type':datatype}
            else:
                add_headers={'Host':hostname, 'Content-Type':datatype, 'Content-Length':str(len(request_data))}
        else:
            add_headers={'Host':hostname, 'Content-Type':'text'+datatype, 'Content-Length':str(len(request_data))}

        try:
            if request_data=="":
                req = urllib2.Request(url+"/"+urlAddon,data=None)
                for key,value in add_headers.items():
                    req.add_header(key,value)
                req.get_method = lambda: method
                res = urlOpener.open(req)
            else:
                if request_data==" ":request_data=""
                req = urllib2.Request(url+"/"+urlAddon,data=request_data)
                for key,value in add_headers.items():
                    req.add_header(key,value)
                req.get_method = lambda: method
                res = urlOpener.open(req)
        except urllib2.HTTPError as e:
            res = e
            self.httpError = str(e.code) + " "

        result=res.read()

        return result

    def sendHttpRequest(self,hostname,request_data="",urlAddon="",datatype="plain",ssl=False,username="",password=""):
        self.startAPICall()
        self.cache.delete(self.spoolID+"receive"+self.threadID)
        directive=["sendhttprequest",'',self.spoolID,hostname,request_data,urlAddon,datatype,ssl,username,password]+['blockingCall']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.cache.get(self.spoolID+"receive"+self.threadID)
            time.sleep(0.15)
            if currdata!=[]:
               self.cache.delete(self.spoolID+"receive"+self.threadID)
               break
            if acnt==self.acnt:
                currdata=False
                break
            acnt+=1
        self.stopAPICall()
        return currdata

    def sendHttpRequestSVR(self,hostname,request_data="",urlAddon="",datatype="plain",ssl=False,username="",password=""):
        self.startAPICall()
        currdata = self.http_request(hostname,request_data,urlAddon,datatype,ssl,username,password)
        self.stopAPICall()
        return currdata

    #show a boolean box (OK / Cancel) with a question and get True or False return
    def booleanBox(self,title,message,okButtonText="Ok",cancelButtonText="Cancel"):
        self.startAPICall()
        self.cache.delete(self.spoolID+"receive"+self.threadID)
        thedir="booleanbox"
        directive=[thedir,title,self.spoolID,message,okButtonText,cancelButtonText]+['blockingCall']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        acnt=0
        currdata=""
        while True:
            currdata=self.cache.get(self.spoolID+"receive"+self.threadID)
            time.sleep(0.05)
            if currdata!=[]:
               self.cache.delete(self.spoolID+"receive"+self.threadID)
               break
            if acnt==self.acnt:
                currdata=False
                break
            acnt+=1
        self.stopAPICall()
        return currdata

    def runStripe(self,publickey):
        self.startAPICall()
        self.cache.delete(self.spoolID+"receive"+self.threadID)
        directive=["runstripe",publickey,self.spoolID]+['blockingCall']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        acnt=0
        currdata=""
        while True:
            currdata=self.cache.get(self.spoolID+"receive"+self.threadID)
            time.sleep(0.05)
            if currdata!=[]:
               self.cache.delete(self.spoolID+"receive"+self.threadID)
               break
            if acnt==self.acnt:
                currdata=False
                break
            acnt+=1
        self.stopAPICall()
        return currdata

    #show an input box that expects entry on a line edit as a return value
    def inputBox(self,title,form):
        self.startAPICall()
        self.cache.delete(self.spoolID+"receive"+self.threadID)
        directive=["inputbox",title,self.spoolID,form]+['blockingCall']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.cache.get(self.spoolID+"receive"+self.threadID)
            time.sleep(0.15)
            if currdata!=[]:
               self.cache.delete(self.spoolID+"receive"+self.threadID)
               break
            if acnt==self.acnt:
                currdata=False
                break
            acnt+=1
        self.stopAPICall()
        return currdata


    #show a file search dialog box on the client side for the client to
    #choose a file and path to be sent back
    def fileDialog(self,title,startpath,lookForDir=False):
        self.startAPICall()
        self.cache.delete(self.spoolID+"receive"+self.threadID)
        directive=["filedialog",title,self.spoolID,startpath,lookForDir]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.cache.get(self.spoolID+"receive"+self.threadID)
            time.sleep(0.15)
            if currdata!=[]:
               self.cache.delete(self.spoolID+"receive"+self.threadID)
               break
            if acnt==self.acnt:
                currdata=False
                break
            acnt+=1
        self.stopAPICall()
        return currdata

    def clientFileExists(self,filename):
        self.startAPICall()
        self.cache.delete(self.spoolID+"receive"+self.threadID)
        directive=["clientfileexists",filename,self.spoolID]+['blockingCall']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.cache.get(self.spoolID+"receive"+self.threadID)
            time.sleep(0.15)
            if currdata!=[]:
               self.cache.delete(self.spoolID+"receive"+self.threadID)
               break
            if acnt==self.acnt:
                currdata=False
                break
            acnt+=1
        self.stopAPICall()
        return currdata
        
    def focusWidget(self):
        self.startAPICall()
        self.cache.delete(self.spoolID+"receive"+self.threadID)
        directive=["focuswidget",'',self.spoolID]+['blockingCall']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.cache.get(self.spoolID+"receive"+self.threadID)
            time.sleep(0.15)
            if currdata!=[]:
               self.cache.delete(self.spoolID+"receive"+self.threadID)
               break
            if acnt==self.acnt:
                currdata=False
                break
            acnt+=1
        self.stopAPICall()
        if self.__dict__.has_key(currdata):currdata=self.__dict__[currdata]
        return currdata
        
    def setFocusVal(self,value,thetype="FOCUS"):
        self.startAPICall()
        directive=['setvalue','',str(self.spoolID),thetype,value]
        if self.addingClientSignal:
            self.clientBuffer.append(directive)
            self.stopAPICall()
            return
        else:
            self.clientBuffer=[directive]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()
        
    def getFocusVal(self,value,thetype="FOCUS"):
        self.startAPICall()
        directive=['getfocusval',self.spoolID,thetype]+['blockingCall']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.cache.get(self.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.cache.delete(self.spoolID+"receive"+self.threadID)
               break
        self.stopAPICall()
        return currdata
        
    #create a UI file on the server side if one does not exists
    def createDialogUI(self,filename):
        self.startAPICall()
        dui = open(filename,"w")
        dui.write(filestubs.uiDialogStub)
        dui.close()
        self.stopAPICall()
    
    def createMainWindowUI(self,filename,altfilename=""):
        self.startAPICall()
        dui = open(filename,"w")
        dui.write(filestubs.uiMainWindowStub)
        dui.close()
        if altfilename!="":
            dui = open(altfilename,"w")
            dui.write(filestubs.uiMainWindowStub)
            dui.close()
        self.stopAPICall()
    
    #create a module file on the server is one does not exists
    def createModFile(self,filename,stubType="mod"):
        stubdat=filestubs.modStub
        if stubType.lower()=="grid":stubdat=filestubs.modGridStub
        if stubType.lower()=="conv":stubdat=filestubs.modConvStub
        self.startAPICall()
        mod = open(filename,"w")
        mod.write(stubdat)
        mod.close()
        self.stopAPICall()

    #android function
    def backHook(self,funcName):
        self.startAPICall()
        directive=['backhook',funcName,'',self.currentModName]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()
        
    #android function        
    def homeHook(self,funcName):
        self.startAPICall()
        directive=['homehook',funcName,'',self.currentModName]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()
        
    #android function        
    def menuHook(self,funcName):
        self.startAPICall()
        directive=['menuhook',funcName,'',self.currentModName]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()
        
    #android and possibly other mobile devices function
    def showKeyboard(self):
        self.startAPICall()
        directive=['showkeyboard']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()
        
    def askForClose(self):
        self.startAPICall()
        directive=['askforclose']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    #create a module file on the server is one does not exists
    def createWebModFile(self,filename):
        self.startAPICall()
        mod = open(filename,"w")
        mod.write(filestubs.modWebStub)
        mod.close()
        self.stopAPICall()

    #create quickbooks object
    def createQBObject(self,widgetName,filepath):
        self.startAPICall()
        self.addressWidget(widgetName,"QBOBJECT")
        directive=['createqbobject',widgetName,self.spoolID,filepath]+['blockingCall']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.cache.get(self.spoolID+"receive"+self.threadID)
            time.sleep(0.1)
            if currdata!=[]:
               self.cache.delete(self.spoolID+"receive"+self.threadID)
               break
            if acnt==self.acnt:
                currdata=False
                break
            acnt+=1
        self.stopAPICall()
        return

    #show a dialog box and if the dialog ui does not exist for this dialog create it
    #and if the mod does not exist for this dialog create it as well.
    #Then display the dialog client side and make it the main screen
    def dialogBox(self,dialog,title,width=0,height=0,actionDef="",widgetUI="",software=""):
        self.startAPICall()
        #self.flushBuffer()
        if software=="":software=self.software
        if type(actionDef) != str:actionDef=actionDef.__name__
        if type(widgetUI)  != str:widgetUI=widgetUI.name
        dialog=dialog.upper()
        try:
            uifile = glob.glob('obj' + software + sep + dialog.upper() + '.ui')
            if len(uifile)==0:
                self.createDialogUI('obj' + software + sep + dialog.upper() + '.ui')
            module = glob.glob('obj' + software + sep + "mod_" + dialog.upper() + '.p*')
            if len(module)==0:
                self.createModFile('obj' + software + sep + "mod_" + dialog.upper() + '.py',"mod")
        except:
            pass
        self.cache.delete(self.spoolID+"receive"+self.threadID)
        self.addressWidget(dialog.lower(),"DIALOGBOX")
        directive=["dialogbox",title,self.spoolID,dialog,width,height,self.currentModName,actionDef,widgetUI,software]
        if self.addingClientSignal:
            self.clientBuffer.append(directive)
            self.stopAPICall()
            return
        else:
            self.clientBuffer=[directive]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()
        
    def softwareDialog(self,software,title,actionDef="",width=0,height=0):
        self.assignWidgetUI(software+"module",software,software)
        self.dialogBox(software,title,width,height,actionDef,software+"module",software)

    def doImport(self, name, globals=None, locals=None, fromlist=None):
        self.startAPICall()
        try:
            self.stopAPICall()
            return sys.modules[name]
        except KeyError:
            pass
            
        fp, pathname, description = imp.find_module(name)
    
        try:
            self.stopAPICall()
            return imp.load_module(name, fp, pathname, description)
        finally:
            if fp:
                fp.close()
        self.stopAPICall()

    def getSoftwareModule(self,moduleName):
        self.startAPICall()
        plugin = ziptestweb.loadPaceModule(self.software,moduleName,"0123456789abcdef")
        self.stopAPICall()
        return plugin

    def assignWidgetUI(self,widgetName,uiClass,uiSoftware=""):
        self.startAPICall()
        self.addressWidget(widgetName,"CUSTOMWIDGET")
        directive=["assignwidgetui",self.spoolID,uiClass,self.currentModName,widgetName,uiSoftware]
        if self.addingClientSignal:
            self.clientBuffer.append(directive)
            self.stopAPICall()
            return
        else:
            self.clientBuffer=[directive]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    def assignWebWidget(self,widgetName):
        self.startAPICall()
        self.addressWidget(widgetName,"WEBVIEW")
        directive=["assignwebwidget",self.spoolID,'',self.currentModName,widgetName]
        if self.addingClientSignal:
            self.clientBuffer.append(directive)
            self.stopAPICall()
            return
        else:
            self.clientBuffer=[directive]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()
        
    def startCEF(self):
        self.startAPICall()
        directive=["initcef",self.spoolID,'',self.currentModName]
        if self.addingClientSignal:
            self.clientBuffer.append(directive)
            self.stopAPICall()
            return
        else:
            self.clientBuffer=[directive]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    def startCustomEventListener(self):
        self.startAPICall()
        directive=["startcustomeventlistener",self.spoolID,'',self.currentModName]
        if self.addingClientSignal:
            self.clientBuffer.append(directive)
            self.stopAPICall()
            return
        else:
            self.clientBuffer=[directive]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()
        
    def stopCEF(self):
        self.startAPICall()
        directive=["stopcef",self.spoolID,'',self.currentModName]
        if self.addingClientSignal:
            self.clientBuffer.append(directive)
            self.stopAPICall()
            return
        else:
            self.clientBuffer=[directive]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()
        
    def assignScribbleWidget(self,widgetName,addToWidget):
        self.startAPICall()
        self.addressWidget(widgetName,"SCRIBBLEWIDGET")
        directive=["assignscribblewidget",self.spoolID,'',self.currentModName,widgetName,addToWidget.name]
        if self.addingClientSignal:
            self.clientBuffer.append(directive)
            self.stopAPICall()
            return
        else:
            self.clientBuffer=[directive]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()
        
    def assignCameraWidget(self,widgetName,addToWidget):
        self.startAPICall()
        self.addressWidget(widgetName,"CAMERAWIDGET")
        directive=["assigncamerawidget",self.spoolID,'',self.currentModName,widgetName,addToWidget.name]
        if self.addingClientSignal:
            self.clientBuffer.append(directive)
            self.stopAPICall()
            return
        else:
            self.clientBuffer=[directive]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    def assignAxWidget(self,widgetName,controlID):
        self.startAPICall()
        self.addressWidget(widgetName,"AXWIDGET")
        directive=["assignaxwidget",self.spoolID,'',self.currentModName,widgetName,controlID]
        if self.addingClientSignal:
            self.clientBuffer.append(directive)
            self.stopAPICall()
            return
        else:
            self.clientBuffer=[directive]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    def loadModule(self,modulename,onFinishActionDef="",uiWidget="",exitImmediately=False,modFileType="mod"):
        #self.flushBuffer()
        self.startAPICall()
        if type(onFinishActionDef) != str:onFinishActionDef=onFinishActionDef.__name__
        moduleArgs=""
        if type(uiWidget) != str:
            if uiWidget.__dict__.has_key("moduleArgs"):
                moduleArgs = uiWidget.moduleArgs
            uiWidget=uiWidget.name
            
        directive=["loadmodule",modulename,onFinishActionDef,self.spoolID,self.currentModName,uiWidget,exitImmediately,moduleArgs]
        module = glob.glob('obj' + self.software + sep + "mod_" + modulename.upper() + '.p*')
        if len(module)==0:
            self.createModFile('obj' + self.software + sep + "mod_" + modulename.upper() + '.py',modFileType)
        if self.addingClientSignal:
            self.clientBuffer.append(directive)
            self.stopAPICall()
            return
        else:
            self.clientBuffer=[directive]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        if not exitImmediately:
            self.autoDone=True
        self.stopAPICall()
        
    #must have assigned a ui widget to use reload module
    def reLoadModule(self,modulename,uiWidget,modFileType="mod",onFinishActionDef=""):
        #self.flushBuffer()
        self.startAPICall()
        if type(onFinishActionDef) != str:onFinishActionDef=onFinishActionDef.__name__
        if type(uiWidget) != str:uiWidget=uiWidget.name
        directive=["reloadmodule",modulename,onFinishActionDef,self.spoolID,self.currentModName,uiWidget,False]
        module = glob.glob('obj' + self.software + sep + "mod_" + modulename.upper() + '.p*')
        if len(module)==0:
            self.createModFile('obj' + self.software + sep + "mod_" + modulename.upper() + '.py',modFileType)
        if self.addingClientSignal:
            self.clientBuffer.append(directive)
            self.stopAPICall()
            return
        else:
            self.clientBuffer=[directive]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.autoDone=True
        self.stopAPICall()
        
    def writeFile(self,afile,data):
        self.startAPICall()
        directive=['writefile','',data,afile]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()
        
    def exitModule(self,moduleToExit=""):
        #self.flushBuffer()
        self.startAPICall()
        directive=["exitmodule",moduleToExit]
        if self.addingClientSignal:
            self.clientBuffer.append(directive)
            self.stopAPICall()
            return
        else:
            self.clientBuffer=[directive]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        if moduleToExit=="":
            self.autoDone=True
        self.stopAPICall()
    
    def getTraceback(self):
        self.startAPICall()
        val=self.cache.get("TraceBack"+self.uiSpoolID)
        self.cache.delete("TraceBack"+self.uiSpoolID)
        self.stopAPICall()
        return val
                
    def createProject(self,software,web=False,modFileType="mod"):
        self.startAPICall()
        objFolder = glob.glob("obj" + software)
        if len(objFolder)==0:
            os.mkdir("obj" + software)
        uifile = glob.glob('obj' + software + sep + software + '.ui')
        if len(uifile)==0:
            self.createMainWindowUI('obj' + software + sep + software + '.ui',software + '.ui')
        module = glob.glob('obj' + software + sep + "mod_" + software + '.p*')
        if len(module)==0:
            self.createModFile('obj' + software + sep + "mod_" + software + '.py',modFileType)
            if web:self.createWebModFile('obj' + software + sep + "mod_web_" + software.lower() + '.py')
        self.stopAPICall()
        #self.cache.delete(self.spoolID+"receive"+self.threadID)
        #directive=["dialogbox",title,self.spoolID,dialog,width,height,self.currentModName,actionDef]
        #self.cache.append(self.spoolID+"send"+self.threadID,directive)

    def createModule(self,software,modulename,dialog=False,modFileType="mod"):
        self.startAPICall()
        objFolder = glob.glob("obj" + software)
        if len(objFolder)==0:
            self.messageBox("Error","Unable to find Project")
            self.stopAPICall()
            return
        if dialog==True:
            uifile = glob.glob('obj' + software + sep + modulename + '.ui')
            if len(uifile)==0:
                self.createDialogUI('obj' + software + sep + modulename + '.ui')
        module = glob.glob('obj' + software + sep + "mod_" + modulename + '.p*')
        if len(module)==0:
            self.createModFile('obj' + software + sep + "mod_" + modulename + '.py',modFileType)
        self.stopAPICall()

    def setWindowIconFromWidget(self,widget,window):
        self.startAPICall()
        if type(widget) != str:widget=widget.name
        directive=['setwindowiconfromwidget',widget,window]
        if self.addingClientSignal:
            self.clientBuffer.append(directive)
            self.stopAPICall()
            return
        else:
            self.clientBuffer=[directive]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()
    
    def setWindowIconFromResource(self,pngfile,window):
        self.startAPICall()
        directive=['setwindowiconfromresource',pngfile,window]
        if self.addingClientSignal:
            self.clientBuffer.append(directive)
            self.stopAPICall()
            return
        else:
            self.clientBuffer=[directive]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    def centerWindow(self):
        self.startAPICall()
        directive=['centerwindow']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    def raiseScreen(self):
        self.startAPICall()
        directive=['raisescreen',self.spoolID]
        if self.addingClientSignal:
            self.clientBuffer.append(directive)
            self.stopAPICall()
            return
        else:
            self.clientBuffer=[directive]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    #send an error to be displayed client side console (for dev)
    def error(self,errorTrace):
        self.tellcli(errorTrace)

    #send a message to be displayed client side console (for dev)
    def tellcli(self,*args):
        #if self.notalk!="True":
        datstr=""
        for arg in args:
            datstr+=str(arg)+"\t"
        self.startAPICall()
        directive=['error',str(datstr)]
        #if not self.software=="WEBIDE":
        try:
            self.tracelog.write(str(datstr),2,self.parent.parentmod,self.parent.parentspool)
        except:
            print(datstr)
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()
    
    def tellySavalas(self,data):
        self.tellcli(data)
        
    def baldy(self,data):
        self.tellcli(data)

    def createShortcut(self,objname,shortcut,widget=""):
        self.startAPICall()
        self.addressWidget(objname,"KEYACCEL")
        directive=["createshortcut",objname,shortcut,widget]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    #an internal function to be used to finish a list of directives to the client
    #so that the client knows to stop looking
    def done(self):
        self.startAPICall()
        directive=["done"]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()
    
    def flushBuffer(self):
        self.startAPICall()
        directive=['signalflush',self.valueBuffer]+['blockingCall']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.cache.get(self.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.cache.delete(self.spoolID+"receive"+self.threadID)
               break
        self.stopAPICall()

    def doEvents(self):
        self.startAPICall()
        directive=['signalflush',self.valueBuffer]+['blockingCall']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.cache.get(self.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.cache.delete(self.spoolID+"receive"+self.threadID)
               break
        self.stopAPICall()

    def inBuffer(self,name):
        self.startAPICall()
        for adir in self.valueBuffer:
            if adir[1]==name:
                self.stopAPICall()
                return True
        self.stopAPICall()
        return False

    def getValueList(self,*args,**kwargs):
        self.startAPICall()
        valList  = []
        typeList = []
        valTypeListFill=False
        valExtraListFill=False
        if kwargs.has_key("valType"):
            valTypeList=kwargs["valType"]
        else:
            valTypeList=[]
            valTypeListFill=True
        if kwargs.has_key("valExtra"):
            valExtraList=kwargs["valExtra"]
        else:
            valExtraList=[]
            valExtraListFill=True
        for arg in args:
            try:
                if not arg.parentWidget is None:addname = arg.getAddName()
                else:addname=""
                valList.append(addname+arg.name)
                #if self.inBuffer(arg.name):self.flushBuffer()
                typeList.append(arg.type)
                if valTypeListFill:valTypeList.append("")
                if valExtraListFill:valExtraList.append("")
            except:
                valList.append(None)
                typeList.append("")
                if valTypeListFill:valTypeList.append("")
                if valExtraListFill:valExtraList.append("")
        directive=["getvaluelist",valList,self.spoolID,typeList,valTypeList,valExtraList]+['blockingCall']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.cache.get(self.spoolID+"receive"+self.threadID)
            time.sleep(0.1)
            if currdata!=[]:
               self.cache.delete(self.spoolID+"receive"+self.threadID)
               break
            if acnt==self.acnt:
                currdata=False
                break
            acnt+=1
        currcnt=0
        if type(currdata) is str:currdata=currdata.split(",")
        if not type(currdata) is bool:
            for arg in args:
                if typeList[currcnt]=="TABLE":
                    currdata[currcnt]= self.decode_base64(currdata[currcnt]).split("\n")
                arg.value=currdata[currcnt]
                currcnt+=1
        else:
            for arg in args:
                arg.value=""
        self.stopAPICall()
        return currdata
    
    def decode_base64(self,data):
        missing_padding = 4 - len(data) % 4
        if missing_padding:
            data += b'='* missing_padding
        return base64.decodestring(data)

    def setValueList(self,*args):
        self.startAPICall()
        switch=0
        items=[]
        values=[]
        types=[]
        for arg in args:
            if switch==0:
                items.append(arg.name)
                types.append(arg.type)
                switch=1
            elif switch==1:
                values.append(arg)
                switch=0
        directive=["setvaluelist",items,self.spoolID,types,values]
        self.cache.append(self.spoolID+"send"+self.threadID,directive+["HINT:"+self.moduleUN])
        self.stopAPICall()
        
                    
    #tells the client to end itself (goodbye)
    def exitProgram(self):
        #self.flushBuffer()
        self.startAPICall()
        directive=['exitprogram']
        if self.addingClientSignal:
            self.clientBuffer.append(directive)
            self.stopAPICall()
            return
        else:
            self.clientBuffer=[directive]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()
        
    def startSpinner(self):
        self.startAPICall()
        directive=['startspinner',"mainwindow"]
        self.passCall(directive)
        self.stopAPICall()
        self.flushBuffer()

    def stopSpinner(self):
        self.startAPICall()
        directive=['stopspinner',"mainwindow"]
        self.passCall(directive)
        self.stopAPICall()

    def printStart(self,printerName,formData,invoiceXML,printFlags=""):
        self.startAPICall()
        directive=['printstart','mainwindow',self.spoolID,printerName,formData,invoiceXML,printFlags]+['blockingCall']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        currdata = self.getMain(999)
        self.stopAPICall()
        return currdata

    def printStartOLD(self,printerName,formData,invoiceXML):
        self.startAPICall()
        directive=['printstart',"mainwindow",printerName,formData,invoiceXML]+['blockingCall']
        self.passCall(directive)
        acnt=0
        while True:
            currdata=self.cache.get(self.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.cache.delete(self.spoolID+"receive"+self.threadID)
               break
        self.stopAPICall()
        return currdata

    def exitWindow(self):
        #self.flushBuffer()
        self.startAPICall()
        directive=['exitwindow']
        if self.addingClientSignal:
            self.clientBuffer.append(directive)
            self.stopAPICall()
            return
        else:
            self.clientBuffer=[directive]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()
        
    def closeHint(self):
        self.startAPICall()
        setList = self.cache.get("storedSets"+self.uiSpoolID+self.currentModName)
        for aset in setList:
            try:
                self.set(aset[0],self.__dict__[aset[0]])
            except:
                pass
        self.stopAPICall()
        #self.flushBuffer()

    def delAll(self,*args):
        self.startAPICall()
        try:
            self.dbconn.close()
        except:
            pass
        if self.__dict__.has_key("cbConn"):
            self.cbConn.closeAll()
            #self.cbConn.close()
        self.cache.clearUID(self.uiSpoolID)
        self.stopAPICall()
    

    def getFieldClassInfo(self,gridClass,fields,keys,sortinfo):
        self.startAPICall()
        try:
            #agridclass = self.dbObj.getTable("yesgridclass")
            agridclass = self.db.yesgridclass
            
            retSel      = ""
            allRetSel   = ""
            funcDict    = {}
            filterDict  = {}
            allFuncList = []
            allFilterList = []
            allColNames = ['theKey']
            keyFuncList = []

            agridclass.acur = agridclass.find({"$and":[{"classname":gridClass},{"colorder":{"$lte":0}}]})
            if agridclass.acur.count()>0:
                theDB=agridclass.acur[0]['griddb']
            else:
                theDB = ""
            
            cnt=0
            #self.tellcli(gridClass,theDB)
            for akey in keys:
                if akey=="Sort Order":
                    if type(sortinfo) is list and len(sortinfo)>0:
                        akey=sortinfo[0]
                    else:
                        akey='nosort|'#' +"
                        retSel+=akey
                        
                
                #gs=agridclass.getSelect("byOne",
                #                     "columntype,source",
                #                     "",
                #                     "classname="+agridclass.repstr +" and " + \
                #                     "columnname="+agridclass.repstr,
                #                     "",
                #                     (gridClass,akey))
                #self.tellcli("get select:",gs)
                agridclass.recDat=[]
                agridclass.acur = agridclass.find({"$and":[{"classname":gridClass},{"columnname":akey}]})
                if agridclass.acur.count()>0:agridclass.recDat=[agridclass.acur[0]['columntype'],agridclass.acur[0]['source']]
                
                if agridclass.recDat!=[] and agridclass.recDat!=None:
                    datline=agridclass.recDat
                    #self.tellcli("found key")
                    if datline[0]=="Field":
                        #retSel+="convert(varchar,"+datline[1]+")+ '|' +"
                        retSel+=str(datline[1])+"|"#+"+ '|' +"
                        #self.tellcli("added field")
                    else:
                        try:
                            funcField    = datline[1].split("(")[1].rstrip(" ").rstrip(")")
                            functionName = datline[1].split("(")[0]
                            retSel+=funcField+"|"#"+ '|' +"
                            keyFuncList.append([cnt,functionName])
                            #self.tellcli("added keyfunc")
                        except Exception, e:
                            retSel+=str(datline[1])+"|"#"+ '|' +"
                            #self.tellcli("error adding keyfunc",str(e))
                else:
                    pass
                    #self.tellcli(gridClass,akey,"not found")
                cnt+=1
                        
            sortKey=retSel
            #if retSel!="":
            #    retSel=retSel[:-1]+" as theKey"
            #elif type(sortinfo) is list and len(sortinfo)>0:
            retSel={0:retSel}
            retFld={}
            cnt=1
            allCnt=0

            agridclass.recDat = []
            agridclass.acur = agridclass.find({"$and":[{"classname":gridClass},{"colorder":{"$ne":-1}}]}).sort("colorder")
            for arec in agridclass.acur:agridclass.recDat.append([arec['columntype'],arec['source'],arec['columnname']])
                                 
            for fielddat in agridclass.recDat:
                afield=fielddat[2]
                datline=fielddat
                if datline[0]=="Field":
                    if afield in fields:
                        retSel[fields.index(afield)+1]=datline[1]
                        retFld[fields.index(afield)+1]=[fields.index(afield)+1,datline[1],afield]
                    allRetSel+=datline[1]+","
                elif datline[0]=="Function":
                    funcField = ""
                    try:
                        funcField    = datline[1].split("(")[1].rstrip(" ").rstrip(")")
                        functionName = datline[1].split("(")[0]
                        if afield in fields:
                            retSel[fields.index(afield)+1]=funcField
                            funcDict[fields.index(afield)+1]=[fields.index(afield)+1,functionName,afield]
                        allRetSel+=funcField+","
                        allFuncList.append([allCnt,functionName])
                    except Exception, e:
                        if afield in fields:
                            retSel[fields.index(afield)+1]=datline[1]
                        allRetSel+=funcField+","
                elif datline[0]=="Filter":
                    try:
                        funcField    = datline[1].split("(")[1].rstrip(" ").rstrip(")")
                        functionName = datline[1].split("(")[0]
                        if afield in fields:
                            retSel[fields.index(afield)+1]=funcField
                            filterDict[fields.index(afield)+1]=[fields.index(afield)+1,functionName,afield]
                        allRetSel+=funcField+","
                        allFilterList.append([allCnt,functionName])
                    except:
                        if afield in fields:
                            retSel[fields.index(afield)+1]=datline[1]
                        allRetSel+=funcField+","
                    
                allCnt+=1
                allColNames.append(afield)
            
            retVal=[]
            for d in sorted(retSel.keys()):retVal.append(retSel[d])
            retSel=','.join(retVal)
            
            usedfldList=[]
            for d in sorted(retFld.keys()):usedfldList.append(retFld[d])
            
            funcList=[]
            for d in sorted(funcDict.keys()):funcList.append(funcDict[d])
            
            filterList=[]
            for d in sorted(filterDict.keys()):filterList.append(filterDict[d])
            
            allRetSel=allRetSel[:-1]
        except Exception, e:
            self.tellcli(str(e))
            self.tellcli(str(formatExceptionInfo()))
        self.stopAPICall()
        return retSel,sortKey,theDB,funcList,filterList,keyFuncList,allRetSel,allFuncList,allColNames,allFilterList,usedfldList

    def getKeyClassInfo(self,gridClass):
        self.startAPICall()
        agridkey = self.db.yesgridkeys

        agridkey.recDat=[]
        agridkey.acur = agridkey.find({"classname":gridClass}).sort("keyorder")
        for arec in agridkey.acur:agridkey.recDat.append([arec['classkey']])
                           
        retDat=[]
        for adat in agridkey.recDat:
            retDat.append(adat[0])
                            
        self.stopAPICall()
        return retDat
            

    def getFieldClassList(self,gridClass):
        self.startAPICall()
        agridclass = self.parent.parent.mongoClient.pacemain.yesgridclass
        
        recDat = []
        acur = agridclass.find({"$and":[{"classname":str(gridClass)},{"colorder":{"$gte":0}}]}).sort("colorder")
        self.tellcli({"$and":[{"classname":str(gridClass)},{"colorder":{"$gte":0}}]}) 
        for arec in acur:
            #self.tellcli("REC",arec)
            recDat.append([arec['colorder'],'0',arec['columnname']])
        
        if recDat!=[] and recDat!=None:
            self.stopAPICall()
            return recDat
        else:
            self.stopAPICall()
            return []
            
            
    def cacheTable(self,tableName,tableKey=""):
        if self.cache.gpdbconn.root.has_key(tableName):
            retTable=self.cache.gpdbconn.root[tableName]
        else:
            self.cache.gpdbconn.root[tableName]=self.cache.gpdb.table(tableName,tableKey)
            retTable = self.cache.gpdbconn.root[tableName]
        return retTable

                
class Widget(object):
    def __init__(self,parent,name,type,parentWidget=None):
        if not parentWidget is None:
            self.parentWidget = parentWidget
        else:
            self.parentWidget = None
        self.widgetLib = ""
        self.parent = parent
        self.threadID = self.parent.threadID
        self.name = name
        self.type = str(type)
        self.value = None
        self.binding = {}
        self.isValid = 1


    def tr(self,words):
        #return words[::-1]
        return words

    def __str__(self):
        return str(self.value)

    def tellcli(self,*args):
        self.parent.tellcli(*args)

    def messageBox(self,*args):
        self.parent.messageBox(*args)

    def __setattr__(self, item, value):
        if "parent" in self.__dict__ and "name" in self.__dict__: 
            try:
                self.parent.__dict__[self.name].__dict__[item]=value
                self.parent.cacheSet(item,self.__dict__[item],False,self.name)
            except:
                pass
        ret=dict.__setattr__(self, item, value)
        return ret
 
    def addressWidget(self,widget,atype,extraParent=False,addressClass=None):
        self.parent.stopAPICall()
        if addressClass is None:addressClass=Widget
        widget=str(widget)
        atype = atype.upper()
        setattr(getattr(self.parent,self.name),widget,addressClass(self.parent,widget,atype,self))
        self.parent.cacheSet(widget,self.__dict__[widget],False,self.name)

    #add a signal to a widget and set code server side that will run when that signal is triggered
    def addSignal(self,widget,signal,calldef,*args,**kwargs):
        kwargList = ['returnvals','sigallow','calldefwidget','timeout','keytimeout']
        for argname in kwargs.keys():
            if not argname in kwargList:
                raise Exception("Invalid keywork argument " + argname + " in addSignal")
        self.parent.startAPICall()
        if not type(widget) is str:
            theType = widget.type
            widget  = widget.name
        else:
            theType = self.__dict__[widget].type
        if not type(calldef) is str:
            calldef=calldef.__name__
        theLib = self.widgetLib
        if "sigallow" in kwargs:
            sigallow=kwargs['sigallow']
        else:
            sigallow=False
        retargs = '|**|'.join(args)
        retvals = ""
        if theType=="TABLE" and signal.lower()=="onsearchselect":
            self.__dict__[widget].addSearchCallback(calldef)
            return
        if theType=="TABLE" and signal.lower()=="onkbreturn":
            self.__dict__[widget].addKbCallback(calldef)
            return
        if theType=="TABLE" and signal.lower()=="ontotalcheck":
            self.__dict__[widget].addTotalCheckCallback(calldef)
            return
        if "returnvals" in kwargs:
            for aretval in kwargs['returnvals']:
                try:
                    if not aretval.parentWidget is None:addname = aretval.getAddName()
                    else:addname=""
                    retvals+=addname+aretval.name+"(*)"+aretval.type+"[&]"
                except Exception as e:
                    print(e)
                    retvals+=str(aretval)+"(*)GLOBAL[&]"
        cdefwidget = ""
        if "calldefwidget" in kwargs:
            if type(kwargs['calldefwidget']) is str:
                cdefwidget=kwargs['calldefwidget']
            else:
                cdefwidget=kwargs['calldefwidget'].name
        if "timeout" in kwargs:
            timeout=kwargs['timeout']
            if int(timeout) <20:
                timeout = float(timeout)*100
        elif signal=="onChange":
            timeout = 0
        #elif signal=="onRowSelect":
        #    timeout = 270
        else:
            timeout=100
        if "keytimeout" in kwargs:
            keytimeout=kwargs['keytimeout']
            if int(timeout) <20:
                keytimeout = float(timeout)*100
        else:
            keytimeout=1200
        directive=['widgetsignal',widget,signal,calldef,self.parent.currentModName,"",theType,self.name,theLib,sigallow,retargs,retvals,cdefwidget,keytimeout,timeout]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def getAddName(self):
        retname = ""
        onObj = self.parentWidget
        if not onObj is None:
            while True:
                if not onObj is None:
                    retname=onObj.name+"."+retname
                else:
                    break
                try:
                    onObj = onObj.parentWidget
                except:
                    break
        
        return retname

    def getAddType(self):
        rettype = ""
        onObj = self.parentWidget
        if not onObj is None:
            while True:
                if not onObj is None:
                    rettype=onObj.type+"."+rettype
                else:
                    break
                try:
                    onObj = onObj.parentWidget
                except:
                    break
        return rettype

    def close(self,*args):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['close',addname+self.name,str(self.parent.spoolID),self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        if self.type=="DIALOG":
            self.parent.cacheUnSet(self.name)
        self.parent.stopAPICall()

    def toJulian(self,theDate=None):
        foxStart= datetime.strptime("01/01/1980","%m/%d/%Y")
        if theDate==None:theday = datetime.now()
        else:
            if "GMT" in theDate:
                theDate = " ".join(theDate.split(" ")[1:4])
                theday = datetime.strptime(theDate,"%b %d %Y")
            else:
                theday = datetime.strptime(theDate,"%m/%d/%Y")
        if foxStart==theday:return 0
        julian = str(theday-foxStart).split(" ")[0]
        return int(julian)

    def fromJulian(self,theNumber=None):
        try:
            foxStart= datetime.strptime("01/01/1980","%m/%d/%Y")
            if theNumber is None:
                theNumber = self.toJulian()
            dateString = foxStart + timedelta(days=int(theNumber))
            #TODO add locale to determine how to return the date
            dateString = dateString.strftime("%m/%d/%Y")[0:10]
            return dateString
        except:
            return ""

    def show(self,widgetname=""):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        if not self.name+"hse" in self.parent.__dict__:
            directive=['show',addname+self.name,self.parent.spoolID,self.type,widgetname]
        else:
            directive=['show',addname+self.parent.__dict__[self.name+'hse'],self.parent.spoolID,"HTMLELEMENT",widgetname]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
    
    def showKeyboard(self,keyflag=""):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['showkeyboardwidget',addname+self.name,self.parent.spoolID,self.type,keyflag]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def expandAll(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['expandall',addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def collapseAll(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['collapseall',addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def stopTimer(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['stoptimer',addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
    
    def setSpacing(self,spacing):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setspacing',addname+self.name,self.parent.spoolID,self.type,spacing]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setMargin(self,margin):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setmargin',addname+self.name,self.parent.spoolID,self.type,margin]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def startTimer(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['starttimer',addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def startStopWatch(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['startstopwatch',addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def stopStopWatch(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['stopstopwatch',addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def getStopWatchSeconds(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['getstopwatchseconds',addname+self.name,self.parent.spoolID]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.parent.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
               break
        self.value=currdata
        self.parent.stopAPICall()
        return currdata

    def setInterval(self,interval=10):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setinterval',addname+self.name,self.parent.spoolID,self.type,interval]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def assignLayout(self,widgetAssign):
        self.parent.startAPICall()
        if type(widgetAssign) != str:widgetAssign=widgetAssign.name
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=["assignlayout",self.parent.spoolID,widgetAssign,self.parent.currentModName,addname+self.name]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    def setWebLayout(self,widgetAssign,startURL="www.google.com"):
        self.parent.startAPICall()
        if type(widgetAssign) != str:widgetAssign=widgetAssign.name
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=["setweblayout",self.parent.spoolID,widgetAssign,self.parent.currentModName,addname+self.name,startURL]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def addDesigner(self,aname,changeCallDef=""):
        self.parent.startAPICall()
        if not type(changeCallDef) is str:changeCallDef=changeCallDef.__name__
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=["adddesigner",self.parent.spoolID,addname+self.name,self.parent.currentModName,aname,changeCallDef]
        self.parent.addressWidget(aname,"DESIGNER")
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    def addTableView(self,aname):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=["addtableview",self.parent.spoolID,addname+self.name,self.parent.currentModName,aname]
        self.parent.addressWidget(aname,"TABLE")
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def loadFile(self,filename,desWidgetName,software):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=["loadfile",self.parent.spoolID,addname+self.name,self.parent.currentModName,filename,desWidgetName,software]
        self.parent.addressWidget(desWidgetName,"SUBWINDOW")
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def saveFile(self,filename):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=["savefile",self.parent.spoolID,addname+self.name,self.parent.currentModName,filename,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def saveImage(self,filename,filetype):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=["saveimage",self.parent.spoolID,addname+self.name,self.parent.currentModName,filename,self.type,filetype]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def clearImage(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=["clearimage",self.parent.spoolID,addname+self.name,self.parent.currentModName,"",self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def hideTitleBar(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['hidetitlebar',addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setFloating(self,abool):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setfloating',addname+self.name,self.parent.spoolID,self.type,abool]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    #set the top headers for a table
    def setTableHeaders(self,headers,headerFilters=[],secondaryHeader=[],footer=[]):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['tableheaders',addname+self.name,headers,self.type,headerFilters,secondaryHeader,footer]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def updateFooter(self,footer):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['updatefooter',addname+self.name,footer,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setFilterValue(self,column,value):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setfiltervalue',addname+self.name,"",self.type,column,value]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
    
    #set the top headers for a table
    def setSelectMode(self,selmode):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setselectmode',addname+self.name,selmode,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
    
    def setTableAlignments(self,alignments):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['settablealignments',addname+self.name,alignments,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setTableRowNoSelect(self,row):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['settablerownoselect',addname+self.name,self.type,row]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setTableRowStyles(self,rowid,bgcolor,rowstyle="",celloptions=[]):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['settablerowstyles',addname+self.name,self.type,rowid,bgcolor,rowstyle,celloptions]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    def keySort(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['keysort',addname+self.name,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
    
    def setDragDropEnabled(self,abool=True):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        enabled="true"
        if not abool:enabled="false"
        directive=['setdragdropenabled',addname+self.name,self.type,enabled]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setMultilineEnabled(self,abool=True):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        enabled="true"
        if not abool:enabled="false"
        directive=['setmultilineenabled',addname+self.name,self.type,enabled]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setColumnMoveEnabled(self,abool=True):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        enabled="true"
        if not abool:enabled="false"
        directive=['setcolumnmoveenabled',addname+self.name,self.type,enabled]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
    
    def assignModelWidget(self,actionWidget,selectionModel=False):
        self.parent.startAPICall()
        self.parent.addressWidget(actionWidget,"TABLEMODEL")
        self.parent.updateWidgets(actionWidget,"TABLEMODEL")
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['assignmodelwidget',actionWidget,"",addname+self.name,self.parent.spoolID,self.type,selectionModel]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setToolTip(self,tipinfo):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['settooltip',addname+self.name,tipinfo,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setTableWidths(self,widths):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['settablewidths',addname+self.name,widths,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setTableFontStyle(self,fontstyle):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['settablefontstyle',addname+self.name,fontstyle,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setFontSize(self,fontsize="12px"):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        if type(fontsize) is int or type(fontsize) is float:fontsize=str(fontsize)+"px"
        directive=['setfontsize',addname+self.name,fontsize,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setTableColTypes(self,types):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['settablecoltypes',addname+self.name,types,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    def setTableResizes(self,resizes):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['settableresizes',addname+self.name,resizes,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    #fill a table one by one
    def fillTableOne(self,rowkey,data,position=0):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['tableaddone',addname+self.name,data,position,self.type,rowkey]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    def addRow(self,data,position=0):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['tableaddone',addname+self.name,data,position,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    def tableSortColumn(self,columnnum,AscOrDesc="asc"):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['tablesortcolumn',addname+self.name,columnnum,0,AscOrDesc]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    def setColorStart(self,keyColStart,dataColStart):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setcolorstart',addname+self.name,keyColStart,0,dataColStart]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    def acceptDrop(self,acceptBool):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['acceptdrop',addname+self.name,acceptBool]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    def setDefaultBackgroundColor(self,color):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setdefaultbackgroundcolor',addname+self.name,color]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
    
    #add a row to a table using the key to replace a key that may already be there
    def addKey(self,data,keypos=None):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['tableaddkey',addname+self.name,data,self.type,keypos]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def deleteRow(self,row):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['deleterow',addname+self.name,row,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def deleteRowKey(self,rowKey,keypos=None):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['deleterowkey',addname+self.name,rowKey,self.type,keypos]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    def selectRow(self,rowindex):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['selectrows',addname+self.name,rowindex,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
   
    def setCheckedColumn(self,colIndex,value=1):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setcheckedcolumn',addname+self.name,colIndex,self.type,value]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()


    def selectRowKey(self,rowindex):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['selectrowkeys',addname+self.name,rowindex,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def getWord(self):
        self.parent.startAPICall()
        self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=["getword",addname+self.name,self.parent.spoolID,self.type]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
            time.sleep(0.15)
            if currdata!=[]:
               self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
               break
            if acnt==self.parent.acnt:
                currdata=False
                break
            acnt+=1
        self.parent.stopAPICall()
        return currdata
    
    def signalFlush(self):
        self.parent.startAPICall()
        self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=["signalflush",addname+self.name,self.parent.spoolID,self.type]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
            time.sleep(0.15)
            if currdata!=[]:
               self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
               break
            if acnt==self.parent.acnt:
                currdata=False
                break
            acnt+=1
        self.parent.stopAPICall()
        return currdata

    def buildTableData(self,data,headers,widths=[],types=[],alignments=[],sorttypes=[]):
        self.parent.startAPICall()
        rtdat = {"head":[],"rows":[]}
        cnt = 0
        for nhead in headers:
            if len(widths)==len(headers):headwidth = widths[cnt]
            else: headwidth = 100
            if len(types)==len(headers):headtype = types[cnt]
            else: headtype = "ro"
            if len(alignments)==len(headers):headalign = alignments[cnt]
            else: headalign = "left"
            if len(sorttypes)==len(headers):headsort = sorttypes[cnt]
            else: headsort = "str"
            rtdat["head"].append({"width":headwidth,"type":headtype,"align":headalign,"sort":headsort,"value":headers[cnt]})
            cnt+=1
        for ndat in data:
            rtdat["rows"].append({"id":ndat[0],"data":ndat[1:]})
        self.parent.stopAPICall()
        return rtdat

    #fill the table with all the data to be displayed
    def fillTableMany(self,data,rowtoselect=-1):
        self.parent.startAPICall()
        dataid=str(uuid.uuid1()).lstrip("{").rstrip("}").replace("-","")
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['tablefill',addname+self.name,dataid,self.type,rowtoselect]
        self.storedata(dataid,data)
        self.parent.passCall(directive)
        #if self.parent.addingClientSignal:
        #    self.parent.clientBuffer.append(directive)
        #    self.parent.stopAPICall()
        #    return
        #else:
        #    self.parent.clientBuffer=[directive]
        #self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def schedulerFill(self,scheddata):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['schedulerfill',addname+self.name,scheddata,self.type]
        self.parent.passCall(directive)
        self.parent.stopAPICall()

    def fillTableMany2(self,data):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        dataid=str(uuid.uuid1()).lstrip("{").rstrip("}").replace("-","")
        directive=['tablefill2',addname+self.name,dataid,self.type]
        self.storedata(dataid,data)
        self.parent.passCall(directive)
        self.parent.stopAPICall()

    def clearTable(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['tableclear',addname+self.name,'',self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    def initTable(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['tableinit',addname+self.name,'',self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setTableDelegate(self,column,atype,colData=[],callDef="",params=[]):
        self.parent.startAPICall()
        if not type(callDef) is str:callDef=callDef.__name__
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['settabledelegate',addname+self.name,self.type,column,atype,colData,self.parent.currentModName,callDef,params]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    def resetTableDelegates(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['resettabledelegates',addname+self.name,self.type,self.parent.currentModName]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setTableColumnIcon(self,column,resource,iconfile):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['settablecolumnicon',addname+self.name,self.type,column,resource,iconfile]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def addGridButtons(self,buttonList,actionDef):
        for button in buttonList:  #[0]=Name [1]=Text [2]=IconResource [3]=IconSize [4]=Row [5]=Column
            self.parent.addressWidget(button[0],"BUTTON")
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['addgridbuttons',addname+self.name,self.type,"",buttonList]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        for button in buttonList:
            self.parent.addSignal(self.parent.__dict__[button[0]],  "clicked(sendername)",  actionDef)

    def setHideIcon(self,row,column,abool=True):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['sethideicon',addname+self.name,self.type,row,column,abool]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setSortingEnabled(self,abool):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setsortingenabled',addname+self.name,self.type,abool]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setTableColumnEditable(self,column):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['settablecolumneditable',addname+self.name,self.type,column]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    def setTableCellDisabled(self,row,column):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['settablecelldisabled',addname+self.name,self.type,row,column]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    def setWordWrap(self,abool):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setwordwrap',addname+self.name,self.type,abool]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setTableCellValue(self,rowKey,column,value):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        if type(value) is str:
            pass
        elif type(value) is int or type(value) is float:
            pass
        else:
            value = json.dumps(value)
        directive=['settablecellvalue',addname+self.name,self.type,rowKey,column,value]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]

        self.parent.cache.append(self.parent.spoolID+"send"+self.parent.threadID,directive)
        self.parent.stopAPICall()

    def setTableRowKey(self,rowKey,newKey):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['settablerowkey',addname+self.name,self.type,rowKey,newKey]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.parent.threadID,directive)
        self.parent.stopAPICall()

    def setTableCellType(self,rowKey,column,atype,startval=""):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['settablecelltype',addname+self.name,self.type,rowKey,column,atype,startval]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]

        self.parent.cache.append(self.parent.spoolID+"send"+self.parent.threadID,directive)
        self.parent.stopAPICall()

    def setTableCellEnabled(self,row,column):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['settablecellenabled',addname+self.name,self.type,row,column]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setCellContents(self,row,column,data):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setcellcontents',addname+self.name,self.type,row,column,data]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setSelectRows(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setselectrows',addname+self.name,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setSelectCells(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setselectcells',addname+self.name,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setTableBGColorRule(self,keyItem,equalTo,color,columns,priority=0):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['settablebgcolorrule',addname+self.name,keyItem,equalTo,color,columns,priority]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setTableNSRule(self,keyItem,equalTo,exceptionList=[]):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['settablensrule',addname+self.name,keyItem,equalTo,exceptionList]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setTableFGColorRule(self,keyItem,equalTo,color,columns,priority=0):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['settablefgcolorrule',addname+self.name,keyItem,equalTo,color,columns,priority]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    #hide a column in a table
    def hideColumns(self,colList):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['hidecolumns',addname+self.name,colList]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def hide(self,widgetname=""):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        if not self.name+"hse" in self.parent.__dict__:
            directive=['hide',addname+self.name,"",self.type,widgetname]
        else:
            directive=['hide',addname+self.parent.__dict__[self.name+'hse'],"","HTMLELEMENT",widgetname]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive+["HINT:"+self.parent.moduleUN])
        self.parent.stopAPICall()

    #hide a grid header
    def hideHeader(self):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['hideheader',addname+self.name]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def hideAll(self):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['hideall',addname+self.name,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def write(self,data):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['write',addname+self.name,self.type,data]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def writeToSocket(self,data):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['writetosocket',addname+self.name,self.type,data]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def readFromSocket(self):
        self.parent.startAPICall()
        #if self.parent.inBuffer(self.name):self.flushBuffer()
        self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['readfromsocket',addname+self.name,self.parent.spoolID,self.type]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.parent.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
               break
        self.value=currdata
        self.parent.stopAPICall()
        return currdata

    #add a python code editor screen to the current widget
    def addFormattedEdit(self,filename,onChangeActionDef="",onSelectChangeActionDef="",onMarginClickActionDef="",codeType="PYTHON"):
        self.parent.startAPICall()
        if type(onChangeActionDef) != str:onChangeActionDef=onChangeActionDef.__name__
        if type(onSelectChangeActionDef) != str:onSelectChangeActionDef=onSelectChangeActionDef.__name__
        if type(onMarginClickActionDef) != str:onMarginClickActionDef=onMarginClickActionDef.__name__
        #sender = self.getSender()
        data=open(self.parent.cache.realpath+filename,"r").read()
        import base64
        data = base64.b64encode(data)
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['addpythoncodeedit',addname+self.name,self.parent.spoolID,self.type,filename,data,onChangeActionDef,self.parent.currentModName,onSelectChangeActionDef,codeType,onMarginClickActionDef]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def addFormattedWebEdit(self,widgetname,filename,onChangeActionDef="",onSelectChangeActionDef="",onMarginClickActionDef="",codeType="PYTHON",filedata=""):
        self.parent.startAPICall()
        self.parent.addressWidget(widgetname,"CODEEDIT")
        if type(onChangeActionDef) != str:onChangeActionDef=onChangeActionDef.__name__
        if type(onSelectChangeActionDef) != str:onSelectChangeActionDef=onSelectChangeActionDef.__name__
        if type(onMarginClickActionDef) != str:onMarginClickActionDef=onMarginClickActionDef.__name__
        #sender = self.getSender()
        if filedata=="":
            data=open(self.parent.cache.realpath+filename,"r").read()
        else:
            data=filedata
        import base64
        data = base64.b64encode(data)
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['addpythoncodeedit',addname+self.name,self.parent.spoolID,self.type,filename,data,onChangeActionDef,self.parent.currentModName,onSelectChangeActionDef,codeType,onMarginClickActionDef,widgetname]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def disconnectListener(self):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['disconnectlistener',addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def reconnectListener(self,index=-1):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['reconnectlistener',addname+self.name,self.parent.spoolID,self.type,index]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    #add a program to a widget
    def addProgram(self,filename,windowname,createname,somename="mprog"):
        self.parent.startAPICall()
        #sender = self.getSender()
        self.parent.addressWidget(somename,"PROGRAM")
        self.parent.updateWidgets(somename,"PROGRAM")
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['addprogram',addname+self.name,self.parent.spoolID,self.type,filename,windowname,createname,somename]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    #add a program to a widget
    def showBalloon(self,text):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['showballoon',addname+self.name,self.parent.spoolID,self.type,text]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    #raise widget
    def raiseWidget(self):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['raise',addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def exportXLS(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['exportxls',addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def exportPDF(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['exportpdf',addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
    

    #get a value from the current widget
    def getVal(self,valtype="",extra="",wait=10000):
        self.parent.startAPICall()
        #if self.parent.inBuffer(self.name):self.parent.flushBuffer()
        self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
        self.parent.cache.set(self.parent.spoolID+"receiveloading",None)
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['getvalue',addname+self.name,self.parent.spoolID,self.type,valtype,extra]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            if self.parent.cache.get(self.parent.spoolID+"receiveloading")==False:
                currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
                acnt+=1
                time.sleep(.01)
                if acnt==self.parent.acnt:
                    currdata=""
                    break
                if currdata!=[]:
                   self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
                   break
            elif self.parent.cache.get(self.parent.spoolID+"receiveloading")==True:
                time.sleep(0.1)
            else:
                time.sleep(0.1)
        self.value=currdata
        self.parent.stopAPICall()
        return currdata

    def setAsTime(self,timeFormat="%H:%i"):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setastime',addname+self.name,self.parent.spoolID,self.type,timeFormat]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    def openQBConnection(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['openqbconnection',addname+self.name,self.parent.spoolID]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.parent.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
               break
        self.value=currdata
        self.parent.stopAPICall()
        return currdata
        
    def closeQBConnection(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['closeqbconnection',addname+self.name,self.parent.spoolID]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    def setQBVariable(self,varname,varvalue):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setqbvariable',addname+self.name,self.parent.spoolID,varname,varvalue]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    def qbQueryItem(self,thetype,thexml):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['qbqueryitem',addname+self.name,self.parent.spoolID,thetype,thexml]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.parent.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
               break
        self.value=currdata
        self.parent.stopAPICall()
        return currdata
        
    def qbAddItem(self,thetype,thexml):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['qbadditem',addname+self.name,self.parent.spoolID,thetype,thexml]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.parent.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
               break
        self.value=currdata
        self.parent.stopAPICall()
        return currdata
        
    def qbModItem(self,thetype,thexml):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['qbmoditem',addname+self.name,self.parent.spoolID,thetype,thexml]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.parent.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
               break
        self.value=currdata
        self.parent.stopAPICall()
        return currdata
        
    def qbDelListItem(self,thetype,theid):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['qbdellistitem',addname+self.name,self.parent.spoolID,thetype,theid]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.parent.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
               break
        self.value=currdata
        self.parent.stopAPICall()
        return currdata
        
    def qbDelTxn(self,thetype,theid):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['qbdeltxn',addname+self.name,self.parent.spoolID,thetype,theid]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.parent.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
               break
        self.value=currdata
        self.parent.stopAPICall()
        return currdata

    def getTableData(self):
        self.parent.startAPICall()
        #if self.parent.inBuffer(self.name):self.flushBuffer()
        self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['gettabledata',addname+self.name,self.parent.spoolID,self.type]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.parent.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
               break
        self.value=currdata
        self.parent.stopAPICall()
        return currdata

    def getSelectedKey(self):
        self.parent.startAPICall()
        #if self.parent.inBuffer(self.name):self.flushBuffer()
        self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['getselectedkey',addname+self.name,self.parent.spoolID,self.type]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.parent.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
               break
        self.value=currdata
        self.parent.stopAPICall()
        return currdata
        
    def getTableHeaderInfo(self):
        self.parent.startAPICall()
        #if self.parent.inBuffer(self.name):self.flushBuffer()
        self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['gettableheaderinfo',addname+self.name,self.parent.spoolID,self.type]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.parent.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
               break
        self.value=currdata
        self.parent.stopAPICall()
        return currdata

    def setRowHeight(self,theheight):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setrowheight',addname+self.name,self.type,theheight]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    def setRowHeightToContents(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setrowheighttocontents',addname+self.name,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setColumnWidgetRules(self,tableColumn,*args):
        self.parent.startAPICall()
        sendList=[]
        for data in args:
            sendList.append(data.getRuleData())
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setcolumnwidgetrules',addname+self.name,self.type,tableColumn, sendList]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setColumnWidth(self,thecolumn,thewidth):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setcolumnwidth',addname+self.name,self.type,thecolumn,thewidth]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setColumnsResizeable(self,thecolumn):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setcolumnsresizeable',addname+self.name,self.type,thecolumn]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def getCodeFileLock(self):
        self.parent.startAPICall()
        #if self.parent.inBuffer(self.name):self.flushBuffer()
        self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['getcodefilelock',addname+self.name,self.parent.spoolID,self.type]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.parent.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
               break
        self.value=currdata
        self.parent.stopAPICall()
        return currdata

    def setMask(self,mask):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
        directive=['setmask',addname+self.name,self.parent.spoolID,self.type,mask]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    #get a value from a widget after validating its contents to match what you want
    #the content type to be
    def getValidate(self,TypeConst,Required=False,valtype=""):
        self.parent.startAPICall()
        self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['getvalue',addname+self.name,self.parent.spoolID,self.type,valtype,TypeConst,Required]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.parent.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
               break
        if currdata=="VALIDATION ERROR":
            currdata=None
            self.isValid=False
        self.value = currdata
        self.parent.stopAPICall()
        return currdata

    #get the index from the current widget
    def getIndex(self):
        self.parent.startAPICall()
        self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['getindex',addname+self.name,self.parent.spoolID,self.type]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.parent.acnt:break
            if currdata!=[]:
               self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
               break
        self.parent.stopAPICall()
        return currdata
        
    def getIndexCount(self):
        self.parent.startAPICall()
        self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['getindexcount',addname+self.name,self.parent.spoolID,self.type]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.parent.acnt:break
            if currdata!=[]:
               self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
               break
        self.parent.stopAPICall()
        return currdata
        
    #set the value of the current widget
    def setVal(self,text,immediate=True,valType=""):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        if self.type=="CODEEDIT":
            import base64
            text = base64.b64encode(text)
        else:
            text = str(text)
        self.value = text
        directive=['setvalue',addname+self.name,str(self.parent.spoolID),self.type,text,valType]
        self.parent.passCall(directive,immediate)
        self.parent.stopAPICall()

    def initWidget(self):
        #subclass me
        pass

    def initParams(self,keyargs):
        for akey,avalue in keyargs.items():
            setattr(self,akey,avalue)

    def dialogBox(self, windowname, title, widgetLib, width, height, maximize=False, returnCallback=None, *args,**kwargs):
        if not returnCallback is None and not type(returnCallback) is str:
            returnCallback = returnCallback.__name__ 
        self.parent.globalDict[windowname] = {"caller":self.name,"returnCallback":returnCallback}
        self.parent.dhxWins.createWindow(windowname,width,height,"ajax","doDialogScreen",title,True,maximize,None,widgetLib,*args,**kwargs)
        
   
    def createWindow(self,windowname,width,height,datatype,data,title,modal,maximize=False,windowParent=None,widgetLib="",*args,**kwargs):
        self.parent.startAPICall()
        self.parent.tracelog.write("CREATING WINDOW for lib "+widgetLib)
        if windowParent==None:
            self.parent.addressWidget(windowname,"DIALOG",None,widgetLib)
            awidget = self.parent.__dict__[windowname]
            wpaddname = ""
        else:
            #this only runs if i'm creating a dialog inside a dialog by giving a windowParent
            if self.parent.name==windowParent.name:
                self.parent.addressWidget(windowname,"DIALOG")
                awidget = self.parent.__dict__[windowname]
                wpaddname = self.getAddName() + windowParent.name
            else:
                self.parent.__dict__[windowParent.name].addressWidget(windowname,"DIALOG")
                awidget = self.parent.__dict__[windowParent.name].__dict__[windowname]
                wpaddname = windowParent.getAddName() +  windowParent.name
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['createwindow',addname+self.name,self.parent.spoolID,self.type,windowname,width,height,datatype,data,modal,title,maximize,wpaddname]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.parent.acnt:break
            if currdata!=[]:
               self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
               break
        self.parent.stopAPICall()
        if widgetLib!="":
            awidget.widgetLib = widgetLib
            awidget.initParams(kwargs) 
            awidget.initWidget()
            awidget.addSignal(awidget,      "onClose",       awidget.close)
        else:
            awidget.parent.addClientSignal(awidget,      "onClose",       awidget.close)
        if currdata!="":
            try:
                adict = json.loads(currdata)
            except Exception as e:
                self.parent.tracelog.write(str(e)+str(currdata))
                adict = {}
            for key,value in adict.items():
                if key!="widgettype":
                    if not awidget is None:
                        awidget.addressWidget(key,value)
                    else:
                        self.addressWidget(key,value)
        else:
            adict = {}
        return adict
        #self.parent.getRemoteWidgets(windowname,awidget)

 
    def setActionGlobal(self,text,immediate=False):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setactionglobal',addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            return
        elif not immediate:
            self.parent.valueBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
    
    #set the value of the current widget
    def setURL(self,text,calldef=""):
        self.parent.startAPICall()
        if not type(calldef) is str:calldef=calldef.__name__
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['seturl',addname+self.name,self.parent.spoolID,self.type,text,calldef]
        self.parent.passCall(directive,True,"blockingCall")
        currdata = self.parent.getMain(15)
        self.parent.stopAPICall()
        return currdata

    #set the value of the current widget
    def setAJAX(self,function):
        self.parent.startAPICall()
        #sender = self.getSender()
        awidget = self.parent.__dict__[self.name]
        wpaddname=""
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setajax',addname+self.name,self.parent.spoolID,self.type,function,wpaddname]+['blockingCall']
        self.value=function
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.parent.acnt:break
            if currdata!=[]:
               self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
               break
        self.parent.stopAPICall()
        if currdata!="":
            try:
                adict = json.loads(currdata)
            except:
                adict = {}
            for key,value in adict.items():
                if key!="widgettype":
                    if not awidget is None:
                        awidget.addressWidget(key,value)
                    else:
                        self.addressWidget(key,value)
        else:
            adict = {}

        return adict

    #set the value of the current widget
    def addAlliance(self,sellerid,buyerid,partnerid,vinnumber,catalogid,indexid,indexcount):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['addalliance',addname+self.name,self.parent.spoolID,self.type,sellerid,buyerid,partnerid,vinnumber,catalogid,indexid,str(indexcount)]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.parent.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
               break
        self.parent.stopAPICall()
        return currdata

    def addStackedWidget(self,widgetName,indexQty,activeIndex=0,cell=""):
        immediate=True
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        for d in range(0,indexQty):
            self.doAddAddress(widgetName+str(d),"LAYOUT")
            self.doAddAddress(widgetName+"Div"+str(d),"HTMLELEMENT")
            #self.parent.addressWidget(widgetName+str(d),"LAYOUT")
            #self.parent.addressWidget(widgetName+"Div"+str(d),"HTMLELEMENT")
            self.parent.__dict__[widgetName+str(d)+"hse"] = widgetName+"Div"+str(d)  #internally used only during hide / show
        #self.parent.addressWidget(widgetName,"STACKEDWIDGET")
        self.doAddAddress(widgetName,"STACKEDWIDGET")
        directive=['addstackedwidget',addname+self.name,self.parent.spoolID,self.type,indexQty,activeIndex,widgetName,cell]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            return
        elif not immediate:
            self.parent.valueBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
             
    def checkAvailabilityAlliance(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['checkavailabilityalliance',addname+self.name,"",self.parent.spoolID]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.parent.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
               break
        self.parent.stopAPICall()
        return currdata

    def placeOrderAlliance(self,deliveryMethod,orderMessage,purchaseOrderNumber):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['placeorderalliance',addname+self.name,"",self.parent.spoolID,deliveryMethod,orderMessage,purchaseOrderNumber]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.parent.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
               break
        self.parent.stopAPICall()
        return currdata
 
    #set the value of the current widget
    def setCursorPosition(self,line,index,immediate=False):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setcursorposition',addname+self.name,self.parent.spoolID,self.type,line,index]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            return
        elif not immediate:
            self.parent.valueBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setFocusCallback(self,InOrOut,theDef):
        self.parent.startAPICall()
        if not type(theDef) is str:theDef=theDef.__name__
        InOrOut=InOrOut.upper()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['focuseventcall',addname+self.name,self.parent.spoolID,self.type,InOrOut,self.parent.currentModName,theDef]
        self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        
    def delegateFocusEventCallback(self,InOrOut,theDef):
        self.parent.startAPICall()
        if not type(theDef) is str:theDef=theDef.__name__
        InOrOut=InOrOut.upper()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['delegatefocuseventcall',addname+self.name,self.parent.spoolID,self.type,InOrOut,self.parent.currentModName,theDef]
        self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)

    def annotateLine(self):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['annotateline',addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def append(self,text,immediate=True):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['append',addname+self.name,self.parent.spoolID,self.type,text]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            return
        elif not immediate:
            self.parent.valueBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setLength(self,text):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setlength',addname+self.name,self.parent.spoolID,self.type,text]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
    
    #set the current widget to a client side global
    def setToGlobal(self,text):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['settoglobal',addname+self.name,self.parent.spoolID,self.type,text]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def putToGlobal(self,text):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['puttoglobal',addname+self.name,self.parent.spoolID,self.type,text]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    #set the current widget to a specific index
    def setIndex(self,index,widgetname=""):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setindex',addname+self.name,self.parent.spoolID,self.type,index,widgetname]
        self.parent.passCall(directive)
        self.parent.stopAPICall()

    def closeCurrentEdit(self):
        self.parent.startAPICall()
        #sender = self.getSender(5)
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['closeedit',addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def removeTab(self,whichtab):
        self.parent.startAPICall()
        #sender = self.getSender(5)
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['removetab',addname+self.name,self.parent.spoolID,self.type,whichtab]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def cut(self):
        self.parent.startAPICall()
        #sender = self.getSender(5)
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['cut',addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def showFind(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['showfind',addname+self.name,self.parent.spoolID,self.type]
        self.parent.passCall(directive)
        self.parent.stopAPICall()
        
    def copy(self):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['copy',addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    def paste(self):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['paste',addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def undo(self,keyOnText=""):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['undo',addname+self.name,self.parent.spoolID,self.type,keyOnText]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def redo(self,keyOnText=""):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['redo',addname+self.name,self.parent.spoolID,self.type,keyOnText]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
  
    def insert(self,thetext):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['insert',addname+self.name,self.parent.spoolID,self.type,thetext]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setTabChanged(self,index):
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['settabchanged',addname+self.name,index]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    def setTabText(self,thetext):
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['settabtext',addname+self.name,'',self.type,thetext]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def tabCloseHook(self,calldef,retGlobal):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['tabclosehook',addname+self.name,"",calldef.__name__,retGlobal]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def replace(self,text,findLineEdit):
        self.parent.startAPICall()
        if type(findLineEdit) != str:findLineEdit=findLineEdit.name
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['replace',addname+self.name,self.parent.spoolID,self.type,text,findLineEdit]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
    
    def setCompleterData(self,dataList):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setcompleterdata',addname+self.name,self.parent.spoolID,self.type,dataList]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
    
    def findFirst(self,text):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['findfirst',addname+self.name,self.parent.spoolID,self.type,text]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    def updateText(self,text):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['updatetext',addname+self.name,self.parent.spoolID,self.type,text]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
    
    def findNext(self):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['findnext',addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
    
    def setTabSaved(self,index):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['settabsaved',addname+self.name,index]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setTabUnlocked(self,index,switch=True):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['settabunlocked',addname+self.name,index,switch]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setAllSaved(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['setallsaved',addname+self.name]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
    
    def getTabChanged(self,index):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['gettabchanged',addname+self.name,index,self.parent.spoolID]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.parent.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
               break
        self.parent.stopAPICall()
        return currdata

    def getAllUnsaved(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['getallunsaved',addname+self.name,self.parent.spoolID]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.parent.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
               break
        self.parent.stopAPICall()
        return currdata

    #bump the index of the current widget by X amount
    def moveIndex(self,index):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['moveindex',addname+self.name,self.parent.spoolID,self.type,index]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    #clear the focus from the current widget to the main widget
    def clearFocus(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['clearfocus',addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    #set the focus to the current widget
    def setFocus(self,widget=""):
        self.parent.startAPICall()
        if type(widget) != str:widget=widget.name
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setfocus',addname+self.name,self.parent.spoolID,self.type,widget]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.stopAPICall()
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)

    #internal function used to get the md5 hash value of a local file
    def md5_for_local_file(self,afile):
        self.parent.startAPICall()
        afile=open(afile,"r")
        block_size=2**20
        md5 = hashlib.md5()
        while True:
            data = afile.read(block_size)
            if not data:
                break
            md5.update(data)
        self.parent.stopAPICall()
        return md5.digest()

    def runCallback(self,*args):
        callingWidgetName = self.parent.globalDict[self.name]["caller"]
        returnCallback    = self.parent.globalDict[self.name]["returnCallback"]
        returnFunc = getattr(self.parent.__dict__[callingWidgetName],returnCallback)
        returnFunc(*args)
        self.close()

    #internal function used to get the md5 hash value of a remote file
    def md5_for_remote_file(self,afile):
        self.parent.startAPICall()
        self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['getmd5',addname+self.name,self.parent.spoolID,self.type,afile]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.parent.acnt:break
            if currdata!=[]:
               self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
               break
        self.parent.stopAPICall()
        return currdata
        
    
    def base64_for_remote_file(self,afile):
        self.parent.startAPICall()
        self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['getbase64',addname+self.name,self.parent.spoolID,self.type,afile]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.parent.acnt:break
            if currdata!=[]:
               self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
               break
        self.parent.stopAPICall()
        return currdata

    #send a file from the server to the client 
    def sendFile(self,afile):
        self.parent.startAPICall()
        dataid=str(uuid.uuid1()).lstrip("{").rstrip("}").replace("-","")
        totalBytes = os.path.getsize(afile)
        data = open(afile,'rb').read(totalBytes)
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['sendfile',addname+self.name,dataid,afile]
        self.storedata(dataid,data)
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    #set the image pixmap of the current widget
    def setPixMap(self,imageFile,stretch=True):
        self.parent.startAPICall()
        localMD5  = self.md5_for_local_file("images"+sep+imageFile)
        remoteMD5 = self.md5_for_remote_file("images"+sep+imageFile)
        if localMD5!=remoteMD5:
            self.sendFile("images"+sep+imageFile)
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setpixmap',addname+self.name,self.parent.spoolID,self.type,"images"+sep+imageFile]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    #set the image icon of the current widget
    def setIcon(self,resource,iconfile):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['seticon',addname+self.name,self.parent.spoolID,self.type,resource,iconfile]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    #add a menu action to the current widget
    def addAction(self,actionWidget,actionText,pngName=""):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not type(actionText) is list:actionText=[actionText]
        if type(actionWidget) != list and type(actionWidget)!=str:actionWidget=[actionWidget.__name__]
        elif type(actionWidget) != list:actionWidget=[actionWidget]
        if type(pngName) != list:pngName=[pngName]
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        nwlist = []
        for anaction in actionWidget:
            if type(anaction) != str:anaction=anaction.__name__
            nwlist.append(anaction)
            self.parent.addressWidget(anaction,"ACTION")
            self.parent.updateWidgets(anaction,"ACTION")
        actionWidget = nwlist
            
        directive=['addaction',actionWidget,actionText,addname+self.name,self.parent.spoolID,self.type,pngName]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    #add a menu action to the current widget
    def addEmptyCellAction(self,actionWidget,actionText):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not type(actionText) is list:actionText=[actionText]
        if type(actionWidget) != list and type(actionWidget)!=str:actionWidget=[actionWidget.__name__]
        elif type(actionWidget) != list:actionWidget=[actionWidget]
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        nwlist = []
        for anaction in actionWidget:
            if type(anaction) != str:anaction=anaction.__name__
            nwlist.append(anaction)
            self.parent.addressWidget(anaction,"ACTION")
            self.parent.updateWidgets(anaction,"ACTION")
        actionWidget = nwlist
            
        directive=['addemptycellaction',actionWidget,actionText,addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    #add a menu action to the current widget
    def addFilledCellAction(self,actionWidget,actionText):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not type(actionText) is list:actionText=[actionText]
        if type(actionWidget) != list and type(actionWidget)!=str:actionWidget=[actionWidget.__name__]
        elif type(actionWidget) != list:actionWidget=[actionWidget]
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        nwlist = []
        for anaction in actionWidget:
            if type(anaction) != str:anaction=anaction.__name__
            nwlist.append(anaction)
            self.parent.addressWidget(anaction,"ACTION")
            self.parent.updateWidgets(anaction,"ACTION")
        actionWidget = nwlist
        
        directive=['addfilledcellaction',actionWidget,actionText,addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    #set the context menu allowed columns
    def setContextMenuColumns(self,columnList):
        self.parent.startAPICall()
        if not type(columnList) is list:columnList=[columnList]
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setcontextmenucolumns',addname+self.name,columnList,"",self.parent.spoolID,self.type]
        self.parent.passCall(directive)
        self.parent.stopAPICall()
        
    def disableDragDropColumns(self,columnList):
        self.parent.startAPICall()
        if not type(columnList) is list:columnList=[columnList]
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['disabledragdropcolumns',addname+self.name,columnList,"",self.parent.spoolID,self.type]
        self.parent.passCall(directive)
        self.parent.stopAPICall()

    def addHideRowRange(self,rangeStart,rangeEnd):
        self.parent.startAPICall()
        rowRange = range(rangeStart,rangeEnd)
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['addhiderowrange',addname+self.name,rowRange,"",self.parent.spoolID,self.type]
        self.parent.passCall(directive)
        self.parent.stopAPICall()
        
    #add a menu stretch to the current toolbar
    def addStretch(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['addstretch',addname+self.name,"",self.parent.spoolID,self.type]
        self.parent.passCall(directive)
        self.parent.stopAPICall()

    def doAddAddress(self,widget,widgetType):
        if self.type=="DIALOG":
            self.addressWidget(widget,widgetType)
        elif self.getAddType()=="DIALOG.":
            self.parentWidget.addressWidget(widget,widgetType,True)
        else:
            self.parent.addressWidget(widget,widgetType)

    #add a menu stretch to the current toolbar
    def addLayout(self,layoutWidget,pattern,cell="a"):
        self.parent.startAPICall()
        if type(layoutWidget) != str:layoutWidget = layoutWidget.name
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['addlayout',addname+self.name,layoutWidget,self.type,cell,pattern]
        self.parent.passCall(directive)
        self.doAddAddress(layoutWidget,"LAYOUT")
        self.parent.stopAPICall()

    def getItemNames(self,item):
        retItems = []
        try:
            pmod = self.parent.parent.parent.__dict__[self.parent.spoolID+"sessinfo"]["parentmod"]
        except:
            pmod = ""
        if not type(item) is list:item=[item]
        for anitem in item:
            if "value" in anitem:
                anitem['value'] = anitem['value'].replace("'","q|q")
            if "bindname" in anitem:
                try:
                    self.binding[anitem["bindname"][0]]=[anitem["name"],anitem["type"],anitem["bindname"]]
                except Exception as e:
                    print("could not bind",anitem,e)
            if anitem["type"]=="combo":
                self.doAddAddress(anitem["name"],"COMBOBOX")
            elif anitem["type"]=="input":
                self.doAddAddress(anitem["name"],"TEXTBOX") 
            elif anitem["type"]=="radio":
                self.doAddAddress(anitem["name"],"RADIOBUTTON")
            elif anitem["type"]=="password":
                self.doAddAddress(anitem["name"],"TEXTBOX")
            elif anitem["type"]=="calendar":
                self.doAddAddress(anitem["name"],"CALENDAR")
            elif anitem["type"]=="button":
                if "image" in anitem:
                    anitem["value"]="<img style=display:inline-block;vertical-align:bottom;margin-right:3px;margin-bottom:2px src=paceicon/blue/"+anitem["image"]+" height=18 width=18>"+anitem["value"]
                self.doAddAddress(anitem["name"],"HTMLELEMENT")
            elif anitem["type"]=="container":
                self.doAddAddress(anitem["name"],"CONTAINER")
            elif anitem["type"]=="checkbox":
                self.doAddAddress(anitem["name"],"CHECKBOX")
            if pmod!="" and "name" in anitem:
                anitem['tooltip']=anitem['name']
            retItems.append(anitem)
        if len(retItems)==1:retItems=retItems[0]
        return retItems

    def addForm(self,formWidget,formdata,cell="a"):
        self.parent.startAPICall()
        if type(formWidget) != str:formWidget = formWidget.name
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        retformdata = []
        for item in formdata:
            if "type" in item:
                #if item["type"]=="block" or item["type"]=="radio":
                if "list" in item:
                    item['list']=self.getItemNames(item['list'])
                item=self.getItemNames(item)
            retformdata.append(item)
        directive=['addform',addname+self.name,formWidget,self.type,cell,retformdata]
        self.parent.passCall(directive)
        self.doAddAddress(formWidget,"FORM")
        self.parent.stopAPICall()
        try:
            self.parentWidget.__dict__[formWidget].binding = self.binding
        except:
            pass

    def bind(self,data):
        self.clearItems()
        for abind,widgetinfo in self.binding.items():
            if abind in data:
                convtype=str
                if len(widgetinfo[2])>1:
                    if widgetinfo[2][1]=="julian":convtype=self.fromJulian
                self.parentWidget.__dict__[widgetinfo[0]].setVal(convtype(data[abind]))

    def bindGet(self):
        retdict = {}
        for abind,widgetinfo in self.binding.items():
            if abind!="" and widgetinfo[0] in self.parentWidget.__dict__:
                convtype=str
                if len(widgetinfo[2])>1:
                    if widgetinfo[2][1]=="int":convtype=int
                    elif widgetinfo[2][1]=="float":convtype=float
                    elif widgetinfo[2][1]=="julian":convtype=self.toJulian
                try:
                    self.parentWidget.__dict__[widgetinfo[0]].value = convtype(self.parentWidget.__dict__[widgetinfo[0]].value)
                    retdict[abind]= convtype(self.parentWidget.__dict__[widgetinfo[0]].value)
                except:
                    retdict[abind]= self.parentWidget.__dict__[widgetinfo[0]].value
        return retdict

    def hasWidget(self,widgetname):
        for abind,widgetinfo in self.binding.items():
            if widgetname==widgetinfo[0]:
                return True
        return False

    def wrapSave(self,dataValues,gridWidget,dbTableName,recordID,saveCallbackFunction):
        changeDict = DictChanges(dataValues,gridWidget.lastdata[str(recordID)]).changed()
        dat =self.parent.db[dbTableName].find_one({"_id":ObjectId(recordID)})
        globalChanges = DictChanges(dat,gridWidget.lastdata[str(recordID)]).changed()
        if globalChanges!={}:
            oChanges = DictChanges(globalChanges,changeDict).changed()
            if oChanges!={}:
                scb = saveCallbackFunction.__name__
                self.parent.changeWindowData=[oChanges,changeDict,self.name,scb]
                self.parent.dhxWins.createWindow("changesWindow",500,400,"ajax","doDialogScreen","Database Updates",True,False,None,"CHANGES")
                return
        saveCallbackFunction("save",changeDict)

    def startSpinner(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['startspinner',addname+self.name]
        self.parent.passCall(directive)
        self.parent.stopAPICall()

    def stopSpinner(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['stopspinner',addname+self.name]
        self.parent.passCall(directive)
        self.parent.stopAPICall()

    def addCalendar(self,calWidget,cell="a"):
        self.parent.startAPICall()
        if type(calWidget) != str:calWidget = calWidget.name
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['addcalendar',addname+self.name,calWidget,self.type,cell]
        self.parent.passCall(directive)
        self.doAddAddress(calWidget,"CALENDAR")
        self.parent.stopAPICall()

    def addScheduler(self,calWidget,sections,units,datestart,cell="a"):
        self.parent.startAPICall()
        if type(calWidget) != str:calWidget = calWidget.name
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        addhtml = ""
        px = 10
        for item in units:
            addhtml+='<div class="dhx_cal_tab" name="'+item["name"]+'_tab" style="right:'+str(px)+'px"></div>\n'
            px+=70
        schedHTML = """<div id="scheduler_here" class="dhx_cal_container" style="width:100pct; height:100pct;">
            <div class="dhx_cal_navline">
                <div class="dhx_cal_prev_button">&nbsp;</div>
                <div class="dhx_cal_next_button">&nbsp;</div>
                <div class="dhx_cal_today_button"></div>
                <div class="dhx_cal_date" style="align:right" ></div>
                %(addhtml)s             
            </div>
            <div class="dhx_cal_header"></div>
            <div class="dhx_cal_data"></div>
        </div>
        """ % {"addhtml":addhtml}
        schedHTML = schedHTML.replace("pct","%")
        directive=['addscheduler',addname+self.name,calWidget,self.type,cell,sections,units,datestart,schedHTML]
        self.parent.passCall(directive)
        self.doAddAddress(calWidget,"SCHEDULER")
        self.parent.stopAPICall()

    def highlightHour(self,hrtext,uid):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['highlighthour',addname+self.name,hrtext,uid]
        self.parent.passCall(directive)
        self.parent.stopAPICall()

    def addTabBar(self,tabWidget,cell="a"):
        self.parent.startAPICall()
        if type(tabWidget) != str:tabWidget = tabWidget.name
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['addtabbar',addname+self.name,tabWidget,self.type,cell]
        self.parent.passCall(directive)
        self.doAddAddress(tabWidget,"TABSHEET")
        self.parent.stopAPICall()

    def addTimeBox(self,htmlWidgetName,cell="a"):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['addtimebox',addname+self.name,htmlWidgetName,self.type,cell]
        self.parent.passCall(directive)
        self.parent.stopAPICall()

    def addHTML(self,htmlString,cell="a"):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['addhtml',addname+self.name,htmlString,self.type,cell]
        self.parent.passCall(directive)
        self.parent.stopAPICall()

    def addGridLayout(self,layoutWidget,rows,columns,cell="a"):
        self.parent.startAPICall()
        if type(layoutWidget) != str:layoutWidget = layoutWidget.name
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['addgridlayout',addname+self.name,layoutWidget,self.type,cell,rows,columns]
        self.parent.passCall(directive)
        self.doAddAddress(layoutWidget,"GRIDLAYOUT")
        self.parent.stopAPICall()

    def addToolbar(self,toolBarWidget,iconsize=32,alignment="left",layoutcell="a"):
        self.parent.startAPICall()
        if type(toolBarWidget) != str:toolBarWidget = toolBarWidget.name
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #self.parent.addressWidget(toolBarWidget,"TOOLBAR")
        self.doAddAddress(toolBarWidget,"TOOLBAR")
        directive=['addtoolbar',addname+self.name,toolBarWidget,self.type,iconsize,alignment,layoutcell]
        self.parent.passCall(directive)
        self.parent.stopAPICall()

    def addUploader(self,uploaderWidget,layoutcell="a"):
        self.parent.startAPICall()
        if type(uploaderWidget) != str:uploaderWidget = uploaderWidget.name
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #self.parent.addressWidget(toolBarWidget,"TOOLBAR")
        self.doAddAddress(uploaderWidget,"TOOLBAR")
        directive=['adduploader',addname+self.name,uploaderWidget,self.type,layoutcell]
        self.parent.passCall(directive)
        self.parent.stopAPICall()

    def click(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['click',addname+self.name,"",self.type]
        self.parent.passCall(directive)
        self.parent.stopAPICall()

    def addMenu(self,menuWidget,layoutcell="a"):
        self.parent.startAPICall()
        if type(menuWidget) != str:menuWidget = menuWidget.name
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #self.parent.addressWidget(menuWidget,"MENU")
        self.doAddAddress(menuWidget,"MENU")
        directive=['addmenu',addname+self.name,menuWidget,self.type,layoutcell]
        self.parent.passCall(directive)
        self.parent.stopAPICall()

    def addButton(self,buttonName,buttonText,icon,isDropdown=False,buttonParent=""):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['addbutton',addname+self.name,buttonName,self.type,buttonText,icon,isDropdown,buttonParent]
        self.parent.passCall(directive)
        self.parent.stopAPICall()

    def addInput(self,inputName,inputValue,inputWidth,readOnly=False,style=""):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['addinput',addname+self.name,inputName,self.type,inputValue,inputWidth,readOnly,style]
        self.doAddAddress(inputName,"TEXTBOX")
        self.parent.passCall(directive)
        self.parent.stopAPICall()
   
    def addText(self,text,fontsize=""):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['addtext',addname+self.name,"",self.type,text,fontsize]
        self.parent.passCall(directive)
        self.parent.stopAPICall()

    def addMenuItem(self,itemParent,itemName,itemText,icon,isDropdown=False):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['addmenuitem',addname+self.name,itemParent,self.type,itemName,itemText,icon]
        self.parent.passCall(directive)
        self.parent.stopAPICall()
        
    #add a menu seperator to the current toolbar
    def addSeperator(self,sepID):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['addseperator',addname+self.name,self.parent.spoolID,self.type,sepID]
        self.parent.passCall(directive)
        self.parent.stopAPICall()

    #set the subframe to use in a web widget
    def setSubFrameTitle(self,theTitle):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setsubframetitle',addname+self.name,theTitle,"",self.parent.spoolID,self.type]
        self.parent.passCall(directive)
        self.parent.stopAPICall()
        
    #set the subframe to use in a web widget
    def subFrameExec(self,thescript):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['subframeexec',addname+self.name,thescript,"",self.parent.spoolID,self.type]+['blockingCall']
        #self.parent.passCall(directive)
        self.parent.passCall(directive,True,"blockingCall")
        currdata = self.parent.getMain(15)
        self.parent.stopAPICall()
        return currdata
        
    #add a handled web widget
    def addHandledWidget(self,widgetName,findString,widgetType):
        self.parent.startAPICall()
        self.parent.addressWidget(widgetName,"WEBELEMENT",self)
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #self.parent.updateWidgets(widgetName,"WEBELEMENT")
        directive=['addhandledwidget',addname+self.name,widgetName,findString,self.parent.spoolID,self.type,widgetType.lower()]
        self.parent.passCall(directive)
        self.parent.stopAPICall()


    def addTrayMenu(self,actionWidget,icon):
        self.parent.startAPICall()
        #sender = self.getSender()
        if type(actionWidget) != str:actionWidget=actionWidget.__name__
        self.parent.addressWidget(actionWidget,"ACTION")
        self.parent.updateWidgets(actionWidget,"ACTION")
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['addtraymenu',actionWidget,icon,self.parent.spoolID,addname]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    #add a menu action to the table header of the current widget
    def addHeaderAction(self,actionWidget,actionText):
        self.parent.startAPICall()
        #sender = self.getSender()
        if type(actionWidget) != str:actionWidget=actionWidget.__name__
        self.parent.addressWidget(actionWidget,"ACTION")
        self.parent.updateWidgets(actionWidget,"ACTION")
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['addheaderaction',actionWidget,actionText,addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
    
    def addVHeaderAction(self,actionWidget,actionText):
        self.parent.startAPICall()
        #sender = self.getSender()
        if type(actionWidget) != str:actionWidget=actionWidget.__name__
        self.parent.addressWidget(actionWidget,"ACTION")
        self.parent.updateWidgets(actionWidget,"ACTION")
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['addvheaderaction',actionWidget,actionText,addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
    
    def assignHeaderWidget(self,actionWidget):
        self.parent.startAPICall()
        self.parent.addressWidget(actionWidget,"HEADERVIEW")
        self.parent.updateWidgets(actionWidget,"HEADERVIEW")
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['assignheaderwidget',actionWidget,"",addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive+["HINT:"+self.parent.moduleUN])
        self.parent.stopAPICall()
    
    def assignVHeaderWidget(self,actionWidget):
        self.parent.startAPICall()
        self.parent.addressWidget(actionWidget,"HEADERVIEW")
        self.parent.updateWidgets(actionWidget,"HEADERVIEW")
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['assignvheaderwidget',actionWidget,"",addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
    
    def setActionMenu(self,actionMenu):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        self.parent.addressWidget(actionMenu,"MENU")
        self.parent.updateWidgets(actionMenu,"MENU")
        directive=['setactionmenu',actionMenu,"",addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
    
    def addGridTab(self,tabText,gridWidgetName,tabWidgetName,makeActive=False):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['addgridtab',addname+self.name,tabText,gridWidgetName,tabWidgetName,makeActive,self.type,False]
        #self.parent.addressWidget(gridWidgetName,"TABLE")
        self.doAddAddress(gridWidgetName,"TABLE")
        #self.parent.addressWidget(tabWidgetName,"TAB")
        self.doAddAddress(tabWidgetName,"TAB")
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def addEditor(self,editorWidgetName):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['addeditor',addname+self.name,editorWidgetName,'','','',self.type]
        self.doAddAddress(editorWidgetName,"EDITOR")
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def addGrid(self,gridWidgetName,layoutCell="a"):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['addgridtab',addname+self.name,"",gridWidgetName,layoutCell,False,self.type,False]
        #self.parent.addressWidget(gridWidgetName,"TABLE")
        self.doAddAddress(gridWidgetName,"TABLE")
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def addTree(self,gridWidgetName,layoutCell="a"):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['addgridtab',addname+self.name,"",gridWidgetName,layoutCell,False,self.type,True]
        #self.parent.addressWidget(gridWidgetName,"TABLE")
        self.doAddAddress(gridWidgetName,"TREE")
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
    
    def startRecord(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['startrecord',addname+self.name]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
    
    #add a tab to the current widget
    def addTab(self,tabText,widgetName=""):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['addtab',addname+self.name,tabText,widgetName]
        #if widgetName!="":self.parent.__dict__[widgetName]=Widget(self.parent,widgetName,"WIDGET")
        if widgetName!="":self.doAddAddress(widgetName,"WIDGET")
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
    
    #add an item to the current widget (ex: combobox)
    def addItem(self,itemText):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['additem',addname+self.name,self.parent.spoolID,self.type,itemText]
        self.parent.passCall(directive,True)
        self.parent.stopAPICall()
        #if self.parent.addingClientSignal:
        #    self.parent.clientBuffer.append(directive)
        #    self.parent.stopAPICall()
        #    return
        #else:
        #    self.parent.clientBuffer=[directive]
        #self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        #self.parent.stopAPICall()
    
    #add multiple items to the current widget
    def addItems(self,itemList):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['additems',addname+self.name,self.parent.spoolID,self.type,json.dumps(itemList)]
        self.parent.passCall(directive,True)
        self.parent.stopAPICall()
        #if self.parent.addingClientSignal:
        #    self.parent.clientBuffer.append(directive)
        #    self.parent.stopAPICall()
        #    return
        #else:
        #    self.parent.clientBuffer=[directive]
        #self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        #self.parent.stopAPICall()

    def openSelect(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['openselect',addname+self.name,self.parent.spoolID,self.type]
        self.parent.passCall(directive,True)
        self.parent.stopAPICall()

    def addGridComboItems(self,itemList,key,index):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['addgridcomboitems',addname+self.name,self.parent.spoolID,self.type,itemList,key,index]
        self.parent.passCall(directive,True)
        self.parent.stopAPICall()

    def setColumnComboItems(self,itemList,index):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setcolumncomboitems',addname+self.name,self.parent.spoolID,self.type,itemList,index]
        self.parent.passCall(directive,True)
        self.parent.stopAPICall()
        
    def clearItems(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['clearitems',addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def progressOn(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['progresson',addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        self.parent.flushBuffer()

    def progressOff(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['progressoff',addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    def clearDelegates(self):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['cleardelegates',addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    #set the background color of the current widget
    def setBackColor(self,color):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['setbackcolor',addname+self.name,color]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
    
    def setStyleSheet(self,styleString):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['setstylesheet',addname+self.name,styleString]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
    
    def setSpan(self,startRow,startColumn,endRow,endColumn):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['setspan',addname+self.name,startRow,startColumn,endRow,endColumn]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    def scrollToRow(self,tableRow,tableColumn=1):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['scrolltorow',addname+self.name,tableRow,tableColumn]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
    
    #set the foreground color of the current widget
    def setForeColor(self,color):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['setforecolor',addname+self.name,color]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
            
    #set the enabled status of the current widget
    def setEnabled(self,enableSetting,immediate=True,subWidgetDat=""):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['setenabled',addname+self.name,self.parent.spoolID,self.type,enableSetting,subWidgetDat]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        elif not True:
            self.parent.valueBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setFormat(self,subWidgetDat,sformat):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['setformat',addname+self.name,self.parent.spoolID,self.type,subWidgetDat,sformat]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    #set the enabled status of the current widget
    def setReadOnly(self,enableSetting,immediate=True):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['setreadonly',addname+self.name,self.parent.spoolID,self.type,enableSetting]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        elif not immediate:
            self.parent.valueBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setTitleText(self,theText,immediate=True):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['settitletext',addname+self.name,self.parent.spoolID,self.type,theText]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        elif not immediate:
            self.parent.valueBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def addButtonListOptions(self,optionList):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['addbuttonlistoptions',addname+self.name,self.parent.spoolID,self.type,optionList]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    #set the width of the current widget
    def setWidth(self,width,layoutPosition="a"):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['setwidth',addname+self.name,self.parent.spoolID,self.type,width,layoutPosition]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    #set the widget of the current widget
    def setWidget(self,widget):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        if type(widget) != str:awidget=widget.name
        else:awidget=widget
        #sender = self.getSender()
        directive=['setwidget',addname+self.name,self.parent.spoolID,awidget]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    #set the widget of the current widget
    def addWidget(self,widget):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        if type(widget) != str:awidget=widget.name
        else:awidget=widget
        #sender = self.getSender()
        directive=['addwidget',addname+self.name,self.parent.spoolID,awidget]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    #set the layout of the current widget
    def setLayout(self,widget):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        if type(widget) != str:awidget=widget.name
        else:awidget=widget
        #sender = self.getSender()
        directive=['setlayout',addname+self.name,self.parent.spoolID,awidget]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()
        
    def addWidgetRow(self,widget):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        if type(widget) != str:awidget=widget.name
        else:awidget=widget
        #sender = self.getSender()
        directive=['addwidgetrow',addname+self.name,self.parent.spoolID,awidget]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setMinimumWidth(self,width):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['setminimumwidth',addname+self.name,self.parent.spoolID,self.type,width]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setWidgetResizeable(self,abool):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['setwidgetresizeable',addname+self.name,self.parent.spoolID,self.type,abool]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setFixedHeight(self,height):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['setfixedheight',addname+self.name,self.parent.spoolID,self.type,height]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    #set the height of the current widget
    def setHeight(self,height,layoutPosition="a"):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['setheight',addname+self.name,self.parent.spoolID,str(self.type),height,layoutPosition]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def resize(self):
        self.parent.startAPICall()
        #sender = self.getSender()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['resize',addname+self.name,self.parent.spoolID,self.type]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def setGeometry(self,geometry):
        self.parent.startAPICall()
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['setgeometry',addname+self.name,self.parent.spoolID,self.type,geometry]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    #internal function used to delete something from the memory cache
    def delete(self,key):
        self.parent.startAPICall()
        self.parent.cache.delete(key)
        self.parent.stopAPICall()

    #internal function used to store something that the client can retrieve directly
    #such as data etc..
    def storedata(self,key,value):
        self.parent.startAPICall()
        if self.parent.env == "webgui":
            self.parent.cache.set(key,value)
        else:
            pickled_value = pickle.dumps(value)
            self.parent.cache.set(key,pickled_value)
        self.parent.stopAPICall()


    ##### functions for grid binding added

    def initGrid(self,gridClass,gridFilter,screenName,changeModClass="",searchLimit=500):
        self.gridClass          = gridClass
        self.gridFilter         = gridFilter
        self.filterName         = gridFilter
        self.screenName         = screenName
        self.changeModClass     = changeModClass
        self.currentColumnNames = []
        self.currentColumnTotals= []
        self.searchWidget       = None
        self.searchWidgetFields = []
        self.firstRunBind       = False
        self.searchLimit        = searchLimit
        self.gridKey            = []
        self.lastFocus          = ""
        self.lastdata           = {}
        self.lastdataKeys       = []
        self.columnDict         = {}
        self.hasSearchText      = False
        self.searchCallback     = ""
        self.kbCallback         = ""
        self.totCheckCallback   = ""
        self.filterDB           = ""
        self.secondaryLookup    = {}
        self.pageType           = ""
        self.searchSpec         = {}
        self.forceSortField     = ""
        self.groupByField       = []
        self.groupByRowData     = {}
        self.tosDict            = {}
        self.totalFields        = []
        self.colorRows          = []
        self.lockRows           = []
        self.fieldPosStore      = {}
        self.fieldSourceStore   = {}
        self.dataKeys           = []
        self.groupKeys          = []
        self.allKeys            = []
        self.ignoreMaster       = False

    def addSearchWidget(self,searchForm,searchWidget,searchButton,pageType="multi",*args):
        self.pageType           = pageType
        self.searchForm         = searchForm.name
        self.searchName         = searchWidget.name
        self.searchButton       = searchButton.name
        self.parentWidget.addSignal(searchForm,   "onButtonClick",   self.doSearchButton,returnvals=[searchWidget],calldefwidget=self)
        self.parentWidget.addSignal(searchForm,   "onKeyTimeout",    self.kbControls,keytimeout=700,sigallow=True,calldefwidget=self)
        
        self._initBind(self.gridFilter,pageType)
        self.searchWidgetFields = args
        self.gridKey = ["_id"]

    def addGroupBy(self,fieldName,ttlonSelect=[],*args):
        self.groupByField.append(fieldName)
        self.tosDict[fieldName] = ttlonSelect
        self.groupByRowData[fieldName] = args

    def initFilterMode(self,dbname,forceSortField="",secondaryLookup={}):
        import pymongo
        self.gridKey = ["_id"]
        self.filterDB = dbname
        self.secondaryLookup = secondaryLookup
        if forceSortField=="" and len(self.groupByField)>0:
            if len(self.groupByField)>1:
                sortlist = []
                for afield in self.groupByField[::-1]:
                    sortlist.append([afield,pymongo.ASCENDING])
                self.forceSortField=tuple(sortlist)
            else:
                self.forceSortField=self.groupByField[0]
        else:
            self.forceSortField = forceSortField
        self.addMenu(self.name+"headmenu","header")
        parentWidget = self.parentWidget
        if parentWidget is None:parentWidget = self.parent
        parentWidget.__dict__[self.name+"headmenu"].addMenuItem("MAIN","showmenu","Show Menu","SHOWFIELD.png")
        parentWidget.__dict__[self.name+"headmenu"].addMenuItem("MAIN","hidefield","Hide Field","HIDEFIELD.png") 
        parentWidget.__dict__[self.name+"headmenu"].addMenuItem("MAIN","refresh","Refresh","REFRESH.png")

        parentWidget.addSignal(self,  "onAfterCMove",      self.columnMove,calldefwidget=self,timeout=0)
        parentWidget.addSignal(self,  "onResizeEnd",       self.columnResize,calldefwidget=self,timeout=0)
        parentWidget.addSignal(self,  "onAfterSorting",    self.columnSort,calldefwidget=self,timeout=0)
        if self.forceSortField!="":
            parentWidget.addSignal(self,  "onBeforeSorting",    self.dumpSort,calldefwidget=self,sigallow=False)
        parentWidget.addSignal(parentWidget.__dict__[self.name+"headmenu"],  "onClick",   self.doHeaderMenu,calldefwidget=self)
        parentWidget.addSignal(self,  "onCheck",           self.gridCheck,calldefwidget=self,timeout=0)

    def dumpSort(self,*args):
        pass

    def doHeaderMenu(self,moduleName,*args):
        if moduleName=="showmenu":
            self.parent.currentShowMenuGridClass = self.gridClass
            self.parent.currentShowMenuGridFilter = self.gridFilter
            self.parent.currentGridWidgetName = self.name
            if self.parentWidget is None:
                self.parent.currentGridParentName = self.parent.name
            else:
                self.parent.currentGridParentName = self.parentWidget.name
            self.parent.dhxWins.createWindow("showMenu",400,350, "ajax","doDialogScreen","Show/Hide Menu",True,False,None,"SHOWMENU")
        elif moduleName=="refresh":
            self.runFilter()
        elif moduleName=="hidefield":
            print(moduleName,args)

    def setSearchSpec(self,key,value,aggregate=False):
        self.searchSpec[key]=value

    def addTotalField(self,totalField):
        self.totalFields.append(totalField)

    def addVarTotalField(self,selectField,totalField):
        self.totalFields.append([selectField,totalField])

    def getTotal(self,totalName):
        try:
            return float(self.currentColumnTotals[self.getFieldPosition(totalName)])
        except:
            return 0.00

    def runFilter(self,colorRows=[],lockRows=[]):
        if not colorRows==[]:self.colorRows = colorRows
        if not lockRows==[]:self.lockRows = lockRows
        self.fieldPosStore      = {}
        self.fieldSourceStore   = {}
        self.clearItems()
        adata,colnames,colwidths,colTotals,colTypes = self.getSearchDat(None,self.searchLimit)
        self.currentColumnNames = colnames
        self.currentColumnTotals = colTotals
        if colnames!=[]:
            for alock in self.lockRows:
                self.setTableRowNoSelect(alock)
            for acolor in self.colorRows:
                self.setTableRowStyles(*acolor)
            self.setTableColTypes(colTypes)
            self.setTableHeaders(colnames,[],[],colTotals)
            self.setTableWidths(colwidths)
            self.setColumnMoveEnabled()
            if "selectedRowKey" in self.__dict__ and type(self.selectedRowKey) is str:
                self.selectRowKey(self.selectedRowKey+"|")
                self.fillTableMany(adata,self.selectedRowKey+"|")
            else:
                self.fillTableMany(adata)
            self.setColumnMoveEnabled()
        else:
            self.fillTableMany([])
        if len(adata)>0:
            if "selectedRowKey" in self.__dict__:
                return self.selectedRowKey
            else:
                return adata[0][0].rstrip("|")
        return [""]

    def addSearchCallback(self,searchCallback):
        if not type(searchCallback) is str:self.searchCallback=searchCallback.__name__
        else:self.searchCallback = searchCallback

    def addKbCallback(self,kbCallback):
        if not type(kbCallback) is str:self.kbCallback=kbCallback.__name__
        else:self.kbCallback = kbCallback

    def addTotalCheckCallback(self,totCheckCallback):
        if not type(totCheckCallback) is str:self.totCheckCallback=totCheckCallback.__name__
        else:self.totCheckCallback = totCheckCallback

    def kbControls(self,arg1="",arg2="",arg3="",arg4=""):
        if self.kbCallback=="" or self.kbCallback=="None":kbCallbackFunction = None
        else:kbCallbackFunction = getattr(self.parentWidget, self.kbCallback)
        formWidget = self.parentWidget.__dict__[self.searchForm]

        #if arg3==self.searchButton:
        #    formWidget.setFocus("null");self.lastFocus="grid"
  
        if arg3==self.searchName:
            if arg1=="" and self.hasSearchText == True:
                self.hasSearchText = False
                if not kbCallbackFunction is None:kbCallbackFunction("searchform",arg1,arg2,arg3,arg4)
            elif arg1!="" and self.hasSearchText==False:
                self.hasSearchText = True
                if not kbCallbackFunction is None:kbCallbackFunction("searchform",arg1,arg2,arg3,arg4)
            if len(arg1)>2:
                self.doSearchButton("",arg1,arg2,arg3,arg4)
            elif arg2=="13":
                self.doSearchButton("",arg1,arg2,arg3,arg4)
        
        elif not kbCallbackFunction is None and arg3==self.name:
            kbCallbackFunction("grid",arg1,arg2,arg3,arg4)
            
        elif not kbCallbackFunction is None and (formWidget.hasWidget(arg1) or formWidget.hasWidget(arg3)):  # arg3 widgetname exists in the form
            kbCallbackFunction("searchform",arg1,arg2,arg3,arg4)
        elif not kbCallbackFunction is None and arg1==self.searchName:
            kbCallbackFunction("searchtext",arg1,arg2,arg3,arg4)

    def getFieldPosition(self,fieldName):
        if fieldName in self.fieldPosStore:return self.fieldPosStore[fieldName]
        usr4grids    = self.parent.db.usr4grids
        fdat =usr4grids.find_one({"gridclass":self.gridClass,
                                  "filtername":self.gridFilter,
                                  "fieldname":fieldName,
                                  "screenname":self.screenName.lower()})
        if fdat is None:
            return -1
        else:
            self.fieldPosStore[fieldName] = fdat["colorder"]
            return fdat["colorder"]

    def getFieldSource(self,position,returnIsFunc=False):
        isFunc = False
        if returnIsFunc:
            pass
        elif position in self.fieldSourceStore:
            return self.fieldSourceStore[position]
        usr4grids    = self.parent.db.usr4grids
        fdat =usr4grids.find_one({"gridclass":self.gridClass,
                                  "fieldname":{"$ne":'[NULL]'},
                                  "filtername":self.gridFilter,
                                  "colorder":int(position),
                                  "screenname":self.screenName.lower()})
        if fdat is None:
            if returnIsFunc:
                return "",isFunc
            else:
                return ""
        else:
            agridclass       = self.parent.maindb.yesgridclass
            gcdict = agridclass.find_one({"_id":ObjectId(fdat['fldclass_id'])})
            src = gcdict["source"]
            if "(" in src:
                if not "Julian" in src:isFunc=True
                src = src.split("(")[1].split(")")[0]
            if "," in src:
                if not "Julian" in src:isFunc = True
                src = src.split(",")[0]
            self.fieldSourceStore[position] = src
            if returnIsFunc:
                return src,isFunc
            else:
                return src

    def hideRows(self,keysOrKeyType="data"):
        self.parent.startAPICall()
        if type(keysOrKeyType) is list:
            keys = json.dumps(keysOrKeyType)
        elif keysOrKeyType=="group":
            keys = json.dumps(self.groupKeys)
        elif keysOrKeyType=="all":
            keys = json.dumps(self.dataKeys+self.groupKeys)
        elif keysOrKeyType=="data":
            keys = json.dumps(self.dataKeys)
        else:
            self.parent.stopAPICall()
            return
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['hiderows',addname+self.name,self.parent.spoolID,str(self.type),keys]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def showRows(self,keysOrKeyType="data"):
        self.parent.startAPICall()
        if type(keysOrKeyType) is list:
            keys = json.dumps(keysOrKeyType)
        elif keysOrKeyType=="group":
            keys = json.dumps(self.groupKeys)
        elif keysOrKeyType=="all":
            keys = json.dumps(self.dataKeys+self.groupKeys)
        elif keysOrKeyType=="data":
            keys = json.dumps(self.dataKeys)
        else:
            self.parent.stopAPICall()
            return
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['showrows',addname+self.name,self.parent.spoolID,str(self.type),keys]
        if self.parent.addingClientSignal:
            self.parent.clientBuffer.append(directive)
            self.parent.stopAPICall()
            return
        else:
            self.parent.clientBuffer=[directive]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall() 

    def getSearchDat(self,searchText,limitOfSearch,keyOnly=""):

        useFilter = False
        if searchText is None or keyOnly!="":
            useFilter = True
        returnData = []
        agridclass       = self.parent.maindb.yesgridclass
        usr4grids        = self.parent.db.usr4grids
        gridcur          = self._getGrid(agridclass,usr4grids)
        if not useFilter:
            if len(self.searchWidgetFields)>2:
                firstSearchInfo = []
                for afld in self.searchWidgetFields[1]:
                    firstSearchInfo.append({afld.rstrip():{'$regex':".*"+re.escape(searchText)+".*","$options":"i"}})
                secSearchInfo = []
                for afld in self.searchWidgetFields[4]:
                    secSearchInfo.append({afld.rstrip():{'$regex':".*"+re.escape(searchText)+".*","$options":"i"}})
                vcursor = self.parent.db[self.searchWidgetFields[0]].find({"$or":firstSearchInfo}).limit(limitOfSearch)
                for vdata in vcursor:
                    secSearchInfo.append({self.searchWidgetFields[2]:vdata[self.searchWidgetFields[2]]})
                    if len(self.searchSpec.keys())>0:
                        secSearchInfo = [secSearchInfo]
                        hasSpecs = False
                        for key,value in self.searchSpec.items():
                            if not value is None:
                                hasSpecs = True
                                secSearchInfo.append({key:value})
                        if hasSpecs:secSearchInfo = {"$and":secSearchInfo}
                        else:secSearchInfo = secSearchInfo[0]
                                                  
                cursor = self.parent.db[self.searchWidgetFields[3]].find({"$or":secSearchInfo}).limit(limitOfSearch)
            else:
                firstSearchInfo = []
                for afld in self.searchWidgetFields[1]:
                    searchList = {afld.rstrip():{'$regex':".*"+re.escape(searchText)+".*","$options":"i"}}
                    if len(self.searchSpec.keys())>0:
                        searchList = [searchList]
                        hasSpecs = False
                        for key,value in self.searchSpec.items():
                            if not value is None:
                                hasSpecs = True
                                searchList.append({key:value})
                        if hasSpecs:searchList = {"$and":searchList}
                        else:searchList = searchList[0]
                    
                    firstSearchInfo.append(searchList)
                      
                    
                cursor = self.parent.db[self.searchWidgetFields[0]].find({"$or":firstSearchInfo}).limit(limitOfSearch)
        elif keyOnly!="":
            if self.filterDB!="":usedb = self.filterDB
            else:usedb = self.searchWidgetFields[0]
            cursor = self.parent.db[usedb].find({"_id":ObjectId(keyOnly)})
            if cursor.count()==0 and len(self.searchWidgetFields)>3:
                cursor = self.parent.db[self.searchWidgetFields[3]].find({"_id":ObjectId(keyOnly)})
        elif type(self.filterDB) is list:
            cursor = self.filterDB
        else:
            #build the cursor for the filter
            if self.ignoreMaster:
                rcursor = self.parent.db['usr4filterrules'].find({"screenname":self.screenName.lower(),"filtername":self.gridFilter})
            else:
                tcursor = self.parent.db['usr4filterrules'].find_one({"screenname":self.screenName.lower(),"filtername":self.gridFilter})
                if not tcursor is None:
                    rcursor = self.parent.db['usr4filterrules'].find({"$or":[{"screenname":"master","filtername":"MASTER"},{"screenname":self.screenName.lower(),"filtername":self.gridFilter}]})
                else:
                    rcursor = self.parent.db['usr4filterrules'].find({"screenname":self.screenName.lower(),"filtername":self.gridFilter})
            oplookup = {"EqualTo":"$eq","LessThan":"$lt","LessThan/EqualTo":"$lte","GreaterThan":"$gt","GreaterThan/EqualTo":"$gte","Not EqualTo":"$ne","Contains":"$regex"}
            searchDict = {}
            for rule in rcursor:
                usrfield = usr4grids.find_one({"fieldname":rule["rulefield"],"screenname":self.screenName.lower(),"filtername":self.gridFilter})
                if not usrfield is None: 
                    gcdict = agridclass.find_one({"_id":ObjectId(usrfield['fldclass_id'])})
                    if gcdict is None:
                        usr4grids.remove({"_id":usrfield["_id"]})
                        continue
                    actualField = gcdict['source']
                    convFunc = None
                    if "(" in actualField and ")" in actualField:
                        actualField = actualField.split("(")[1].split(")")[0].split(",")[0]
                        if "convertJulian" in gcdict['source']:convFunc = self.parent.toJulian
                
                    operation = oplookup[rule['rulesign']]
                    if gcdict['columntype']=="3" or gcdict['columntype']=="4" or gcdict['columntype']=="5" or gcdict['columntype']=="6" or gcdict['columntype']=="7" or gcdict['columntype']=="9":
                        try:
                            thevalue = int(rule["equalvalue"])
                        except:
                            thevalue = rule["equalvalue"] 
                    else:
                        thevalue = rule["equalvalue"]
                          
                    if not convFunc is None:
                        try:
                            thevalue=convFunc(thevalue)
                        except:
                            pass

                    if type(thevalue) is str:
                        if thevalue.upper()=="TODAY":thevalue=self.parent.toJulian()
                        elif thevalue.upper()=="TOMORROW":thevalue=self.parent.toJulian()+1
                        elif thevalue.upper()=="YESTERDAY":thevalue=self.parent.toJulian()-1

                    if searchDict == {}:
                        searchDict["$and"] = [{actualField:{operation:thevalue}}]
                    elif "$and" in searchDict:
                        searchDict["$and"].append({actualField:{operation:thevalue}})

                else:
                    print("rulefield " + rule["rulefield"] + " is missing from the grid")
            for key,value in self.searchSpec.items():
                if key=="$and" and "$and" in searchDict:
                    if type(value) is list:
                        for aitem in value:
                            searchDict[key].append(aitem)
                    else:
                        searchDict[key].append(value)
                else:
                    searchDict[key]=value
            if self.forceSortField != "":
                cursor = self.parent.db[self.filterDB].find(searchDict).sort(self.forceSortField).limit(limitOfSearch)
            else:
                sortcolumn,sortdir,isfunc = self.getSortInfo()
                if sortcolumn!="" and not isfunc:
                    direction = 1
                    if sortdir=="des":direction = -1
                    if self.secondaryLookup != {}:
                        cursor = self.parent.db[self.filterDB].aggregate([{"$match"  : searchDict},
                                                                          {"$lookup" : self.secondaryLookup},
                                                                          {"$sort"   : {sortcolumn:direction}}]).limit(limitOfSearch)
                    else:
                        cursor = self.parent.db[self.filterDB].find(searchDict).sort(sortcolumn,direction).limit(limitOfSearch)
                else:
                    if self.secondaryLookup != {}:
                        cursor = self.parent.db[self.filterDB].aggregate([{"$match"  : searchDict},
                                                                          {"$lookup" : self.secondaryLookup}]).limit(limitOfSearch)
                    else:
                        cursor = self.parent.db[self.filterDB].find(searchDict).limit(limitOfSearch)


        columnNames      = []
        columnWidths     = []
        columnTypes      = []
        columnDataFields = []
        self.columnDict  = {}
        for fielddict in gridcur:
            gcdict = agridclass.find_one({"_id":ObjectId(fielddict['fldclass_id'])})
            if gcdict is None:
                usr4grids.remove({"_id":fielddict["_id"]})
                continue
            columnWidths.append(fielddict['colwidth'])
            #columnNames.append(str(fielddict['fieldname']))
            columnNames.append(str(gcdict['columnname']))
            if int(fielddict['colorder']) in self.columnDict:
                self.columnDict[int(fielddict['colorder'])+.01]=str(fielddict['fieldname'])
            else:
                self.columnDict[int(fielddict['colorder'])]=str(fielddict['fieldname'])
            if gcdict['columntype']=="0":
                columnTypes.append("ro|str|left")
            elif gcdict['columntype']=="1":
                columnTypes.append("ro|str|center")
            elif gcdict['columntype']=="2":
                columnTypes.append("ro|str|right")
            elif gcdict['columntype']=="3":
                columnTypes.append("ron|price|right")
            elif gcdict['columntype']=="4":
                columnTypes.append("ron|int|right")
            elif gcdict['columntype']=="5":
                columnTypes.append("ron|int1|right")
            elif gcdict['columntype']=="6":
                columnTypes.append("ron|int2|right")
            elif gcdict['columntype']=="7":
                columnTypes.append("ron|int4|right")
            elif gcdict['columntype']=="8":
                acolType = "ch|str|left"
                for k,v in self.tosDict.items():
                    if len(v)>0:
                        if self.getFieldPosition(v[0])==int(fielddict['colorder']):
                            acolType = "oldch|str|left"
                columnTypes.append(acolType)
            elif gcdict['columntype']=="9":
                columnTypes.append("ro|date|left")
            elif gcdict['columntype']=="10":
                columnTypes.append("combo|str|left")
            elif gcdict['columntype']=="11":
                columnTypes.append("ed|str|left")
            else:
                columnTypes.append("ro")
            gsrc=gcdict['source']
            if "(" in gsrc:
                inparen = str(gsrc).split("(")[1].split(")")[0]
                columnDataFields.append([inparen.rstrip(),gsrc])
            else:
                columnDataFields.append([str(gsrc).rstrip(),str(gsrc).rstrip()])

        if keyOnly=="":
            self.lastdata = {}
            self.lastdataKeys = []
        try:
            gridDataMod = self.parent.getSoftwareModule(self.changeModClass.upper()).griddatamodule(self)
        except Exception as e:
            if not "mod_.pyc" in str(e):
                print("ERROR LOADING gridDataMod",str(e),formatExceptionInfo())
            gridDataMod = "empty"
        if len(self.totalFields)>0:
            columnTotals = [0] * len(columnNames)
        else:
            columnTotals = []
        if len(self.tosDict.keys())>0:
            columnTOSTotals = [0] * len(columnNames)
        else:
            columnTOSTotals = [] 
        if len(self.groupByField)>0:
            thisGroup = [""] * len(self.groupByField)
            lastLoopGroup = [None] * len(self.groupByField)
            lastLoopData = [None] * len(self.groupByField)
            thisGroupKey = ["ZZZ"] * len(self.groupByField)
            for d in range(0,len(thisGroupKey)):thisGroupKey[d]+=str(d)
            thisGroupSel = [""] * len(self.groupByField)
            groupTotals = [0.00] * len(self.groupByField)
        else:
            thisGroup = []
            lastLoopGroup = []
            lastLoopData = []
            thisGroupKey = []
            thisGroupSel = []
            groupTotals = []
        colorlist = ["#D2D2D2","#A2A2A2","#908100","#A3616C"]
        self.dataKeys = []
        self.groupKeys = []
        self.allKeys  = []
        for data in cursor:
            keydat      = ""
            firstKeyDat = ""
            for akey in self.gridKey:
                keydat+=str(data[akey])
                if not "|" in keydat:firstKeyDat=keydat
                keydat+="|"
            self.dataKeys.append(keydat)
            self.allKeys.append(keydat)
            rowData = [keydat]
            if len(self.totalFields)>0:
                columnTempTotals = [0] * len(columnNames)
            else:
                columnTempTotals = []

            showrow = True
            rowcolor = ""
            colCount = 0
            if len(self.groupByField)>0:
                cntgrp = 0
                for agroup in self.groupByField:
                    if agroup in data:
                        thisGroup[cntgrp] = str(data[agroup])
                        for grpadd in self.groupByField[cntgrp+1:]:
                            if grpadd in data:
                                thisGroup[cntgrp] += str(data[grpadd])
                    else:
                        thisGroup[cntgrp] = ""
                    if not lastLoopGroup[cntgrp] is None:
                        if thisGroup[cntgrp]!=lastLoopGroup[cntgrp]:
                            grpRowData = [thisGroupKey[cntgrp]]
                            for column,gsrc in columnDataFields:
                                if gsrc==agroup or gsrc in self.groupByField[cntgrp+1:]:
                                    if gsrc in lastLoopData[cntgrp]:
                                        grpRowData.append(lastLoopData[cntgrp][gsrc])
                                    else:
                                        grpRowData.append("")
                                else:
                                    grpRowData.append("")
                            ttlCol = self.getFieldPosition(self.tosDict[agroup][1])
                            self.setTableRowStyles(thisGroupKey[cntgrp],colorlist[cntgrp],"",[[ttlCol,"color:#FF002B;"]])
                            if agroup in self.tosDict:
                                if len(self.tosDict[agroup])>0:
                                    colNum = self.getFieldPosition(self.tosDict[agroup][0])
                                    ttlColNum = self.getFieldPosition(self.tosDict[agroup][1])
                                    selectOnValue = self.tosDict[agroup][2]
                                    if "false" in thisGroupSel[cntgrp]:
                                        if selectOnValue!="allhide":
                                            grpRowData[colNum+1]="false"
                                            self.setTableCellType(thisGroupKey[cntgrp],colNum,"ch","false")
                                    else:
                                        if selectOnValue!="allhide":
                                            grpRowData[colNum+1]="true"
                                            self.setTableCellType(thisGroupKey[cntgrp],colNum,"ch","true")
                                    for rcWrite in self.groupByRowData[agroup]:
                                        rcCol = self.getFieldPosition(rcWrite[0])
                                        rcColName = self.getFieldSource(rcCol)
                                        #convert lastLoopData field into a string to be piped into the string for the grid
                                        if rcColName in lastLoopData[cntgrp]:
                                            lastLoopData[cntgrp][rcColName] =  str(lastLoopData[cntgrp][rcColName])
                                            grpRowData[rcCol+1]=str(rcWrite[1] % lastLoopData[cntgrp])
                                            if len(rcWrite)>2:
                                                self.setTableRowStyles(thisGroupKey[cntgrp],colorlist[cntgrp],"",[[rcCol,rcWrite[2]]])


                                    grpRowData[ttlColNum+1] = "%.2f" % float(groupTotals[cntgrp])
                            self.lastdata[thisGroupKey[cntgrp]]=grpRowData
                            self.lastdataKeys.append(thisGroupKey[cntgrp])
                            self.groupKeys.append(thisGroupKey[cntgrp])
                            self.allKeys.append(thisGroupKey[cntgrp])
                            returnData.append(grpRowData)
                            #clear group key after row from prev loop was added
                            thisGroupKey[cntgrp] = "ZZZ"+str(cntgrp)
                            thisGroupSel[cntgrp] = ""
                            groupTotals[cntgrp] = 0.00
                            #if len(self.tosDict.keys())>0:
                            #    columnTOSTotals = [0] * len(columnNames)
                            #else:
                            #    columnTOSTotals = []

                    #build the group key for the group row
                    thisGroupKey[cntgrp]+="|"+str(data["_id"])
                    #build the group sel so that I can tell if the group should be checked or not
                    if len(self.tosDict[agroup])>0:
                        asrc = self.getFieldSource(self.getFieldPosition(self.tosDict[agroup][0]))
                        if asrc in data:
                            thisGroupSel[cntgrp]+="|"+str(data[asrc])
                        else:
                            thisGroupSel[cntgrp]+="|false"
                    else:
                        thisGroupSel[cntgrp]+="|false"
                    cntgrp+=1

            for column,gsrc in columnDataFields:
                newdat = self.getDataModInfo(column,gsrc,gridDataMod,data)
                if type(newdat) is list and len(newdat)==2:
                    newdat, showrow = newdat
                elif type(newdat) is list and len(newdat)==3:
                    newdat, showrow, rowcolor = newdat
                rowData.append(newdat)
                if not showrow:break
                if len(self.tosDict.keys())>0:
                    for atoskey,atos in self.tosDict.items():
                        if len(atos)>0:
                            if atos[1] == columnNames[colCount]:
                                try:
                                    columnTOSTotals[colCount]+=float(data[column.rstrip()])
                                except Exception as e:
                                    pass

                colCount+=1

            # add the totals buckets up (this is based on sort order for groupings and each bucket gets cleared when its dropped into a grouping
            for atotalField in self.totalFields:
                if type(atotalField) is list:
                    selColNum = self.getFieldPosition(atotalField[0])
                    selColSrc = self.getFieldSource(selColNum)
                    colNum = self.getFieldPosition(atotalField[1])
                    colSrc = self.getFieldSource(colNum)
                    if selColSrc in data and data[selColSrc] == "true":
                        try:
                            columnTempTotals[colNum]+=float(data[colSrc])
                        except:
                            pass
                else:
                    colNum = self.getFieldPosition(atotalField)
                    colSrc = self.getFieldSource(colNum)
                    try:
                        columnTempTotals[colNum]+=float(data[colSrc])
                    except Exception as e:
                        print("adding totals error ",e,"colSrc",colSrc,"TotalField",atotalField,"colNum",colNum,"colTempTotals",columnTempTotals)
            gcnt = 0
            for agrp in self.groupByField:
                colNum = self.getFieldPosition(self.tosDict[agrp][1])
                ckColNum = self.getFieldPosition(self.tosDict[agrp][0])
                totalKey = self.tosDict[agrp][2]
                if totalKey != "all" and totalKey != "allhide":
                    if rowData[ckColNum+1]==totalKey:
                        try:
                            groupTotals[gcnt]+=float(rowData[colNum+1])
                        except:
                             pass
                else:
                    try:
                        groupTotals[gcnt]+=float(rowData[colNum+1])
                    except:
                        pass
                gcnt+=1
            if self.groupByField!=[]:
                cntgrp=0
                for agroup in self.groupByField:
                    if agroup in data:
                        lastLoopGroup[cntgrp] = str(data[agroup])
                        for grpadd in self.groupByField[cntgrp+1:]:
                            if grpadd in data:
                                lastLoopGroup[cntgrp] += str(data[grpadd])
                        lastLoopData[cntgrp] = data
                    else:
                        lastLoopGroup[cntgrp] = ""
                        lastLoopData[cntgrp] = {}
                    cntgrp+=1
            if showrow:
                if len(self.totalFields)>0:
                    cnt=0
                    for colTot in columnTempTotals:
                        columnTotals[cnt]+=colTot
                        cnt+=1
                returnData.append(rowData)
                if rowcolor!="":
                    self.setTableRowStyles(rowData[0],rowcolor)
            if len(self.tosDict.keys())>0:
                cnt=0
                for colTot in columnTOSTotals:
                    columnTOSTotals[cnt]+=colTot
                    cnt+=1
            if keyOnly=="" and showrow:
                self.lastdata[firstKeyDat]=data
                self.lastdataKeys.append(firstKeyDat)
        if self.groupByField!=[]:
            cntgrp = 0
            for agroup in self.groupByField:
                if not lastLoopGroup[cntgrp] is None:
                    grpRowData = [thisGroupKey[cntgrp]]
                    for column,gsrc in columnDataFields:
                        if gsrc==agroup or gsrc in self.groupByField[cntgrp+1:]:
                            grpRowData.append(lastLoopData[cntgrp][gsrc])
                        else:
                            grpRowData.append("")
                    returnData.append(grpRowData)
                    self.lastdata[thisGroupKey[cntgrp]]=grpRowData
                    self.lastdataKeys.append(thisGroupKey[cntgrp])
                    self.groupKeys.append(thisGroupKey[cntgrp])
                    ttlCol = self.getFieldPosition(self.tosDict[agroup][1])
                    self.setTableRowStyles(thisGroupKey[cntgrp],colorlist[cntgrp],"",[[ttlCol,"color:#FF002B;"]])
                    if agroup in self.tosDict:
                        if len(self.tosDict[agroup])>0:
                            colNum = self.getFieldPosition(self.tosDict[agroup][0])
                            selectOnValue = self.tosDict[agroup][2]
                            if "false" in thisGroupSel[cntgrp]:
                                if selectOnValue!="allhide":
                                    grpRowData[colNum+1]="false"
                                    self.setTableCellType(thisGroupKey[cntgrp],colNum,"ch","false")
                            else:
                                if selectOnValue!="allhide":
                                    grpRowData[colNum+1]="true"
                                    self.setTableCellType(thisGroupKey[cntgrp],colNum,"ch","true")
                            grpRowData[ttlCol+1] = "%.2f" % float(groupTotals[cntgrp])
                            for rcWrite in self.groupByRowData[agroup]:
                                rcCol = self.getFieldPosition(rcWrite[0])
                                rcColName = self.getFieldSource(rcCol)
                                #convert lastLoopData field into a string to be piped into the string for the grid
                                lastLoopData[cntgrp][rcColName] =  str(lastLoopData[cntgrp][rcColName])
                                grpRowData[rcCol+1]=str(rcWrite[1] % lastLoopData[cntgrp])
                                if len(rcWrite)>2:
                                    self.setTableRowStyles(thisGroupKey[cntgrp],colorlist[cntgrp],"",[[rcCol,rcWrite[2]]])
                cntgrp+=1
        columnTotalFinal = []
        for ctotal in columnTotals:
            if float(ctotal)!=0.00:
                columnTotalFinal.append("%.2f" % float(ctotal))
            else:
                columnTotalFinal.append("")
        self.currentGroupTotals = groupTotals
        if self.forceSortField == "":
            sortcolumn,sortdir,isfunc = self.getSortInfo(True)
            if isfunc:
                returnData.sort(key= lambda row: row[sortcolumn+1],reverse=sortdir)

        return returnData,columnNames,columnWidths,columnTotalFinal,columnTypes

    def getDataModInfo(self,column,gsrc,gridDataMod,data):
        if str(gsrc)!=str(column) and "(" in str(gsrc) and gridDataMod!="empty":
            srcfield = gsrc.split("(",1)
            fields = srcfield[1].rstrip().rstrip(")").split(",")
            fieldargs = []
            for afield in fields:
                if afield=="self":
                    continue
                elif afield.rstrip() in data:
                    fieldargs.append(data[afield.rstrip()])
                elif '"' in afield or "'" in afield:
                    fieldargs.append(str(afield).lstrip("'").lstrip('"').rstrip("'").rstrip('"'))
                else:
                    fieldargs.append(str(afield))
            try:
                newdat = getattr(gridDataMod, srcfield[0])(*fieldargs)
            except Exception as e:
                print("Function Error ",str(e), gridDataMod, srcfield[0])
                newdat = fieldargs[0]
            retdat = newdat
        elif not column.rstrip() in data:
            retdat = ""
        else:
            retdat = str(data[column.rstrip()])
        return retdat

    def doSearchButton(self,moduleName,arg1="",arg2="",arg3="",arg4=""):
        searchBox = self.parentWidget.__dict__[self.searchName]
        theGrid = self
        colnames = []
        #try:
        if 1==1:
            if arg3==self.searchName:
                inText=arg1.lower()
            else:
                inText = searchBox.value
            adata = []
            if inText!="":
                adata,colnames,colwidths,colTotals,colTypes = theGrid.getSearchDat(inText,self.searchLimit)
                self.currentColumnNames = colnames
                self.currentColumnTotals = colTotals
        
            if colnames!=[]:
                theGrid.clearItems()
                theGrid.setTableHeaders(colnames,[],[],colTotals)
                theGrid.setTableColTypes(colTypes)
                theGrid.setTableWidths(colwidths)
                theGrid.fillTableMany(adata)
                theGrid.setColumnMoveEnabled()
                if len(adata)>0 and self.pageType=="single":
                    theGrid.doSearchCallback(adata[0][0],"","") 
            else:
                theGrid.clearItems()
                theGrid.fillTableMany([])
                theGrid.setColumnMoveEnabled()

    def _getGrid(self,agridclass,griddb):
        #this function returns the grid cursor (creates if does not exists for user and adds fields that may not exists yet)
        gridcur = griddb.find({"gridclass":self.gridClass,
                               "fieldname":{"$ne":'[NULL]'},
                               "filtername":self.gridFilter,
                               "screenname":self.screenName.lower()}).sort("colorder")
        fieldItems = agridclass.find({"$and":[{"classname":str(self.gridClass)},{"colorder":{"$gte":0}}]},{"_id":1,"columnname":1}).sort("colorder")
        try:
            import pymongo
            lastDat=agridclass.find({"$and":[{"classname":str(self.gridClass)},{"colorder":{"$gte":0}}]},{"_id":1,"colorder":1}).sort([("colorder",pymongo.DESCENDING)])[0]
            lastCol = lastDat["colorder"]
        except:
            lastCol = 99
        #found data so go see if there are some new fields to add
        if gridcur.count()>0:
            for fieldItem in fieldItems:
                acur = griddb.find_one({"fldclass_id":str(fieldItem['_id']),"filtername":self.gridFilter})
                if not acur:
                    lastCol+=1
                    recdict = {}
                    recdict['screenname']    = self.screenName.lower()
                    recdict['gridclass']     = self.gridClass
                    recdict['filtername']    = self.gridFilter
                    recdict['fieldname']     = fieldItem['columnname']
                    recdict['colorder']      = lastCol
                    recdict['colwidth']      = 0
                    recdict['sortflag']      = 0
                    recdict['sortdirection'] = ''
                    recdict['fldclass_id']   = str(fieldItem['_id'])
                    griddb.save(recdict,w=0)
            
        #no data found so go create the whole grid locally
        else:
            cnt=0
            for fieldItem in fieldItems:
                if cnt==0:
                     #create the header if any fields exists
                     recdict = {}
                     recdict['screenname']  =  self.screenName.lower()
                     recdict['gridclass']   =  self.gridClass
                     recdict['filtername']  =  self.gridFilter
                     recdict['fieldname']   =  "[NULL]"
                     recdict['colorder']    =  -1
                     recdict['colwidth']    =  0
                     recdict['sortflag']    =  ''
                     recdict['sortdirection'] =  "asc"
                     recdict['screenname']  =  self.screenName.lower()
                     recdict['fldclass_id'] =  ""
                     griddb.save(recdict,w=0)
                recdict = {}
                # create each field
                recdict['screenname']    = self.screenName.lower()
                recdict['gridclass']     = self.gridClass
                recdict['filtername']    = self.gridFilter
                recdict['fieldname']     = fieldItem['columnname']
                recdict['colorder']      = cnt
                recdict['colwidth']      = 100
                recdict['sortflag']      = 0
                recdict['sortdirection'] = ''
                recdict['fldclass_id']   = str(fieldItem['_id'])
                griddb.save(recdict,w=0)
                cnt+=1
            gridcur = griddb.find({"fieldname":{"$ne":'[NULL]'},
                                   "filtername":self.gridFilter,
                                   "screenname":self.screenName.lower()}).sort("colorder")
        return gridcur

    def columnMove(self,startPosition,newPosition):
        colList = sorted(self.columnDict.keys())
        if int(startPosition)<int(newPosition):adj=.5
        else:adj=-.5
        aval = self.columnDict[int(colList[int(startPosition)])]
        del self.columnDict[int(colList[int(startPosition)])]
        self.columnDict[int(colList[int(newPosition)])+adj] = aval
        cnt=0
        usr4grids        = self.parent.db.usr4grids
        newDict = {}
        for a in sorted(self.columnDict.keys()):
            usr4grids.update_one({"gridclass":self.gridClass,"fieldname":self.columnDict[a],"filtername":self.filterName,"screenname":self.screenName.lower()},{"$set":{"colorder":cnt}})
            newDict[cnt] = self.columnDict[a]
            cnt+=1
        self.columnDict = newDict
        self.fieldSourceStore = {}
        if len(self.groupByField)<=0:
            adata,colnames,colwidths,colTotals,colTypes = self.getSearchDat(None,self.searchLimit)
            self.currentColumnNames = colnames
            self.currentColumnTotals = colTotals
        else:
            self.runFilter()

    def columnResize(self,columnNum,columnWidth,widgetName):
        colList = sorted(self.columnDict.keys())
        usr4grids        = self.parent.db.usr4grids
        usr4grids.update_one({"gridclass":self.gridClass,"fieldname":self.columnDict[colList[int(columnNum)]],"filtername":self.filterName,"screenname":self.screenName.lower()},{"$set":{"colwidth":int(columnWidth)}})

    def columnSort(self,columnNum,columnType,direction):
        colList = sorted(self.columnDict.keys())
        usr4grids        = self.parent.db.usr4grids
        usr4grids.update_one({"gridclass":self.gridClass,"filtername":self.filterName,"screenname":self.screenName.lower(),"colorder":-1},{"$set":{"sortflag":self.columnDict[colList[int(columnNum)]],"sortdirection":direction}})

    def getSortInfo(self,listSort=False):
        if listSort:
            sortcolumn = 0
            sortdir    = False
            isFunc     = False
        else:
            sortcolumn = ""
            sortdir    = "asc"
            isFunc     = False
        usr4grids  = self.parent.db.usr4grids
        gridInfo   = usr4grids.find_one({"gridclass":self.gridClass,"filtername":self.filterName,"screenname":self.screenName.lower(),"colorder":-1})
        if not gridInfo is None:
            if "sortdirection" in gridInfo:
                if "asc" in gridInfo["sortdirection"] or "des" in gridInfo["sortdirection"]:
                    sortdir = gridInfo["sortdirection"]
                    if listSort:
                        if sortdir=="asc":sortdir=False
                        elif sortdir=="des":sortdir=True
            if "sortflag" in gridInfo:
                if str(gridInfo["sortflag"])!="0":
                    sortcolumn = self.getFieldPosition(gridInfo["sortflag"])
                    if not listSort:
                        sortcolumn,isFunc = self.getFieldSource(int(sortcolumn),True)
                    else:
                        nocol,isFunc = self.getFieldSource(int(sortcolumn),True)
        if sortcolumn=="":sortcolumn="_id"
        return sortcolumn,sortdir,isFunc

    def doSearchCallback(self,*args):
        if self.searchCallback=="" or self.searchCallback=="None":searchCallbackFunction = None
        else:searchCallbackFunction = getattr(self.parentWidget, self.searchCallback)
        if not searchCallbackFunction is None:
            searchCallbackFunction(*args)

    def gridCheck(self,rowId,columnId,checkState):
        if "ZZZ" in rowId:
            rowIdList = rowId.split("|")[1:]
        else:
            rowIdList = [rowId.split("|")[0]]

        srcfield = self.getFieldSource(int(columnId))
        for aRowId in rowIdList:
            self.parent.db[self.filterDB].update_one({"_id":ObjectId(aRowId)},{"$set":{srcfield:checkState}})
            self.lastdata[aRowId][srcfield]=checkState

        if "ZZZ" in rowId:
            rowIdList = rowId.split("|")[1:]
            columnTotals = [0.00] * len(self.currentColumnTotals)
            groupTotals = [0.00] * len(self.groupByField)
            for aRowId in self.lastdataKeys:
                #if it is a group by row and its not the current row then handle it
                if "ZZZ" in aRowId and aRowId!=rowId:
                    aRowIdList = aRowId.split("|")[1:]
                    if set(aRowIdList).issubset(set(rowIdList)):
                        self.setTableCellValue(aRowId,columnId,checkState)
                        self.lastdata[aRowId][int(columnId)+1]=checkState
                #if it is not a group by row
                elif not "ZZZ" in aRowId:
                    for atotalField in self.totalFields:
                        if type(atotalField) is list:
                            selColNum = self.getFieldPosition(atotalField[0])
                            selColSrc = self.getFieldSource(selColNum)
                            colNum = self.getFieldPosition(atotalField[1])
                            colSrc = self.getFieldSource(colNum)
                            if selColSrc in self.lastdata[aRowId] and self.lastdata[aRowId][selColSrc] == "true":
                                try:
                                    columnTotals[colNum]+=float(self.lastdata[aRowId][colSrc])
                                except:
                                    pass
                        else:
                            colNum = self.getFieldPosition(atotalField)
                            colSrc = self.getFieldSource(colNum)
                            try:
                                columnTotals[colNum]+=float(self.lastdata[aRowId][colSrc])
                            except:
                                pass
                    cnt = 0
                    for agrp in self.groupByField:
                        colNum = self.getFieldPosition(self.tosDict[agrp][1])
                        colName = self.getFieldSource(colNum)
                        ckColNum = self.getFieldPosition(self.tosDict[agrp][0])
                        ckColName = self.getFieldSource(ckColNum)
                        totalKey = self.tosDict[agrp][2]
                        if totalKey !="all" and totalKey!="allhide":
                            if ckColName in self.lastdata[aRowId] and  self.lastdata[aRowId][ckColName]==totalKey:
                                try:
                                    groupTotals[cnt]+=float(self.lastdata[aRowId][colName])
                                except:
                                    pass
                        else:
                             if ckColName in self.lastdata[aRowId]:
                                 try:
                                     groupTotals[cnt]+=float(self.lastdata[aRowId][colName])
                                 except:
                                     pass
                        cnt+=1
                    continue
               
                #if "ZZZ" in aRowId and aRowId!=rowId:
                #if checkState=="false" and  set(rowIdList).issubset(set(aRowId.split("|")[1:])):
                #    self.setTableCellValue(aRowId,columnId,checkState)
                #    self.lastdata[aRowId][int(columnId)+1]=checkState
                #elif checkState=="true":
                #    pass

                grpLevel = int(aRowId.split("|")[0].replace("ZZZ",""))
                grpName = self.groupByField[grpLevel]
                if self.tosDict[grpName][2]!="all" and self.tosDict[grpName][2]!="allhide":
                    colNum = self.getFieldPosition(self.tosDict[grpName][1])
                    self.setTableCellValue(aRowId,colNum,groupTotals[grpLevel])
                groupTotals[grpLevel]=0.00
        else:
            #rowIdList = rowId.split("|")[1:]
            columnTotals = [0.00] * len(self.currentColumnTotals)
            for aRowId in self.lastdataKeys:
                for atotalField in self.totalFields:
                    if type(atotalField) is list:
                        selColNum = self.getFieldPosition(atotalField[0])
                        selColSrc = self.getFieldSource(selColNum)
                        colNum = self.getFieldPosition(atotalField[1])
                        colSrc = self.getFieldSource(colNum)
                        if selColSrc in  self.lastdata[aRowId] and self.lastdata[aRowId][selColSrc] == "true":
                            try:
                                columnTotals[colNum]+=float(self.lastdata[aRowId][colSrc])
                            except:
                                pass
                    else:
                        colNum = self.getFieldPosition(atotalField)
                        colSrc = self.getFieldSource(colNum)
                        try:
                            columnTotals[colNum]+=float(self.lastdata[aRowId][colSrc])
                        except:
                            pass

        colTotals = []
        for acolTotal in columnTotals:
            if acolTotal==0.00:
                colTotals.append("")
            else:
                colTotals.append("%.2f" % float(acolTotal))
        if self.currentColumnTotals != colTotals:
            self.updateFooter(colTotals)
            self.currentColumnTotals = colTotals
        if self.totCheckCallback=="" or self.totCheckCallback=="None":
            totCheckCallbackFunction = None
        else:
            totCheckCallbackFunction = getattr(self.parentWidget, self.totCheckCallback)
            totCheckCallbackFunction("checktotal",rowId,columnId,checkState)

    def _initBind(self,gridFilter,pageType):
        #self.addMenu("amenu")
        #self.parentWidget.amenu.addMenuItem("MAIN","select","Select Customer","BACK.png")
        self.addMenu("bmenu","header")
        self.parentWidget.bmenu.addMenuItem("MAIN","showmenu","Show Menu","SHOWFIELD.png")
        self.parentWidget.bmenu.addMenuItem("MAIN","hidefield","Hide Field","HIDEFIELD.png")
        self.parentWidget.bmenu.addMenuItem("MAIN","refresh","Hide Field","REFRESH.png")
        #TODO Hook the below signals to real functions
        #self.parentWidget.addSignal(self.parentWidget.amenu, "onClick",  ,calldefwidget=self)
        self.parentWidget.addSignal(self.parentWidget.bmenu, "onClick", self.doHeaderMenu,  calldefwidget=self)
        if pageType=="multi":
            self.parentWidget.addSignal(self,   "onRowDblClicked",  self.doSearchCallback,calldefwidget=self)
            self.parentWidget.addSignal(self,   'onKeyPress',       self.kbControls,sigallow=True,calldefwidget=self,returnvals=[self])
        else:
            #self.parentWidget.addSignal(self,   'onBeforeSelect',   self.doSearchCallback,sigallow=True,calldefwidget=self)
            self.parentWidget.addSignal(self,   'onRowSelect',      self.doSearchCallback,calldefwidget=self)
            self.parentWidget.addSignal(self,   'onKeyPress',       self.kbControls,sigallow=True,calldefwidget=self)
            self.parentWidget.addSignal(self.parentWidget.__dict__[self.searchForm],  "onFocus", self.kbControls,calldefwidget=self,returnvals=[self])

        self.parentWidget.addSignal(self,  "onAfterCMove",      self.columnMove,calldefwidget=self)
        self.parentWidget.addSignal(self,  "onResizeEnd",       self.columnResize,calldefwidget=self)
        self.parentWidget.addSignal(self,  "onAfterSorting",    self.columnSort,calldefwidget=self)
        self.parentWidget.addSignal(self,  "onCheck",           self.gridCheck,calldefwidget=self)

class genjson:
    def __init__(self):
        self.json={}
        self.level=0
        self.removeAmount=0
        self.currStack = []
        self.currStackCount = {}

    def resetXML(self):
        self.json={}
        self.level=0

    def startTag(self,name,tagtype="text"):
        self.level+=1
        if self.level>1:
            adict = self.json
            for d in self.currStack:
                adict = adict[d]
                if len(self.currStack)>0 and self.currStackCount[d]>=0:
                    adict = adict[self.currStackCount[d]]
            self.currStack.append(name)
            if name in adict:
                if not type(adict[name]) is list:
                    adict[name]=[adict[name]]
                #bump it an extra time because someone forgot to declare it as an array
                if self.currStackCount[name]==-1:self.currStackCount[name]+=1
                self.currStackCount[name]+=1
                adict[name].append({})
            else:
                if tagtype.lower()=="array":
                    adict[name] = [{}]
                    self.currStackCount[name]=0
                else:
                    adict[name] = {}
                    self.currStackCount[name]=-1

    def endTag(self,name):
        self.level-=1
        if len(self.currStack)!=0:
            #self.currStackCount[self.currStack[-1]]=0
            del self.currStack[-1]

    def addValue(self,name,value,maxsize=-1):
        self.removeAmount=0
        if maxsize>0:
            if len(value)>maxsize:
                self.removeAmount=len(value)-maxsize
                value=value[0:maxsize]
        if type(value) is str or type(value) is unicode:
            value = value.replace("&","&amp;").replace('"',"&quot;").replace("<","&lt;").replace(">","&gt;").replace("'","&apos;").rstrip(" ")
        adict = self.json
        for d in self.currStack:
            adict = adict[d]
            if len(self.currStack)>0 and self.currStackCount[d]>=0:
                adict = adict[self.currStackCount[d]]
        if type(adict) is list:
            adict[name].append(value)
        else:
            adict[name]=value

    def addValues(self,valdict):
        for name,value in valdict.items():
            self.addValue(name,value)

class genxml:
    def __init__(self):
        self.xml=""
        self.level=0
        self.removeAmount=0

    def resetXML(self):
        self.xml=""
        self.level=0

    def startTag(self,name,*args):
        self.level+=1
        self.xml+="<"+name+">"+"\n"+((self.level*4)*" ")

    def endTag(self,name):
        checkfor = (4*" ")
        if self.xml[-len(checkfor):]==checkfor:self.xml=self.xml[0:-4]
        self.level-=1
        self.xml+="</"+name+">"+"\n"+((self.level*4)*" ")

    def addValue(self,name,value,maxsize=-1):
        self.removeAmount=0
        value=str(value)
        if maxsize>0:
            if len(value)>maxsize:
                self.removeAmount=len(value)-maxsize
                value=value[0:maxsize]
        value = value.replace("&","&amp;").replace('"',"&quot;").replace("<","&lt;").replace(">","&gt;").replace("'","&apos;")
        self.xml+="<"+name+">"+str(value)+"</"+name+">"+"\n"+((self.level*4)*" ")

    def addValues(self,valdict):
        for name,value in valdict.items():
            self.addValue(name,str(value))


def tr(words):
    return words

