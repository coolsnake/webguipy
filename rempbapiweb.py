import base64
import pickle
import uuid
import json
import time
import hashlib
import traceback
import os
import sys
import glob
#import filestubs
import imp
import re
from bson.objectid import ObjectId
from datetime import timedelta, datetime
import urllib2
import ziptestweb

"""
set platform seperator for library to use
"""
platform=sys.platform
if platform[0:3]=="win":
    sep="\\"
elif platform[0:3]=="lin":
    sep="/"
else:
    sep="/"


def formatExceptionInfo(cache=None,spoolid=""):
    """
    format traceback information to run after an exception and pass back to the user

    :param cache:  cache memory object to store error
    :param spoolid: spool id to identify user
    """
    maxTBlevel=5
    cla, exc, trbk = sys.exc_info()
    excName = cla.__name__
    try:
        excArgs = exc.__dict__["args"]
    except KeyError:
        excArgs = "<no args>"
    excTb = traceback.format_tb(trbk, maxTBlevel)
    if not cache is None:
        if spoolid!="":
            cache.append("TraceBack"+spoolid,[cla,exc,trbk,excName,excArgs,excTb])
    aTB=""
    for tb in excTb:
       aTB+="    "+tb.lstrip(" ")+"\n"
    return "ExecName: "+str(excName)+"\nArguments: "+str(excArgs)+"\nTraceBack:\n"+str(aTB)

class EmptyObj(object):
    """
    Empty Session Object Class
    """

    def __init__(self):
        """
        empty init of class
        """
        pass

    def append(self,key,item):
        """
        append call for class to add values to itself

        :param key:
        :param item:
        """
        self.__dict__[key]=item

class DictChanges(object):
    """
    This class is to get the changes and additions in a didctionary
    """
 
    def __init__(self, newdict, olddict):
        """
        Initilize the two dictionaries in order to calculate the difference in the two

        :param newdict: this is the new formulation of the dictionary
        :param olddict: this is the old dictionary for comparison
        """
        self.newdict = newdict
        self.olddict = olddict
        self.setnew = set(newdict.keys())
        self.setold = set(olddict.keys())
        self.theintersect = self.setnew.intersection(self.setold)

    def changed(self):
        """
        Return the changed items for the difference in the dictionaries
        """ 
        retDict = {}
        for o in self.theintersect:
            if str(self.olddict[o]) != str(self.newdict[o]):
                retDict[o]=self.newdict[o]
        return retDict

    def added(self):
        """
        Return the added items for the difference in the dictionaries
        """
        retDict = {}
        addset = self.setnew - self.theintersect
        for o in addset:
            retDict[o]=self.newdict[o]
        return retDict


class spool(object):
    """
    This class is the mainwindow class of the gui that gets generated by the javascript.  Functions in this class control the mainwindow and various core functions
    of the environment itself
    """

    def __init__(self,cache):
        """
        Initialize the spool class

        :param cache: the global memory cache for the current session
        """
        self.startAPICall()
        self.type               = "WINDOW"
        self.name               = "window"
        self.threadID           = ""
        self.sessionObj         = EmptyObj()
        self.connTable          = False
        self.cache              = cache
        self.clientBuffer       = []
        self.isValid            = 1
        self.addingClientSignal = False
        self.autoDone           = False
        self.uiRef              = ""
        self.acnt               = 20000
        self.globalDict         = {}

        self.IntOnly      = 101
        self.FloatOnly    = 102
        self.StrOnly      = 103
        self.EmailOnly    = 104
        self.PhoneOnly    = 105
        self.DateOnly     = 106
        self.StrNoSpaces  = 107
        self.ZipCode      = 108

        try:
            self.addressWidget("dhxWins","WINDOWMANAGER")
        except:
            pass

        self.startAPICall()

    def spinSpool(self,parent,theid,tracelog,dbconn,cursor,modname):
        """
        This function is for spinning up the spool with the stored memory that it needs for the environment during each function call called during a signal

        :param parent:
        :param theid:
        :param tracelog:
        :param dbconn:
        :param cursor:
        :param modname:
        """
        self.startAPICall()
        self.currentModName = modname
        self.parent         = parent
        self.spoolID        = theid
        self.dbconn         = dbconn
        self.cursor         = cursor
        self.tracelog       = tracelog
        self.software       = parent.parent.software
        self.entrypoint     = parent.parent.entrypoint
        self.uiSpoolID      = parent.parent.uiSpoolID
        self.env            = parent.parent.theEnv
        self.valueBuffer    = []
        self.stopAPICall()
         
    
    def beforeCall(self,*args):
        """
        This function will run before the api function call and will be called with the same arguments as the function

        :param *args:
        """
        pass

    def afterCall(self,*args):
        """
        This function will run after the api function call and will be called with the same arguments as the function

        :param *args:
        """
        #subclass me
        pass

    def startAPICall(self):
        """
        Runs before an API call starts to disable any storage to cache that may occur automatically during a self.cacheSet call
        """
        self.__dict__['storeSet']=False

    def stopAPICall(self):
        """
        Runs after an API call ends to enable any storage to cache that is needed during running of non api functions in the module code
        """
        self.__dict__['storeSet']=True

    def passCall(self,directive,immediate=True,addon=""):
        """
        Passes a directive into the spool to be picked up by the browser and processed to control the gui

        :param directive:
        :param immediate:
        :param addon:
        """
        if self.addingClientSignal:
            self.clientBuffer.append(directive)
            self.stopAPICall()
            return
        elif immediate:
            self.clientBuffer=[directive]
        else:
            self.valueBuffer.append(directive)
            self.stopAPICall()
            return
        if addon!="":
            self.cache.append(self.spoolID+"send"+self.threadID,directive+["HINT:"+self.moduleUN]+[addon])
        else:
            try:
                self.cache.append(str(self.spoolID+"send"+self.threadID),directive+["HINT:"+self.moduleUN])
            except:
                self.cache.append(str(self.spoolID+"send"+self.threadID),directive)

    def tr(self, words):
        """
        Function for translating words and phrases in the system.
        This is meant to be used to wrap all words that the end user sees and translate on the fly

        :param words: string with word or phrase
        """
        #TODO build system of translating words and phrases
        #return words[::-1] # test to reverse all words
        return words

    def setUserPresence(self,userID,isPresent=True):
        """
        Set presence with a timestamp in global cache in the framework

        :param userID:
        :param isPresent:
        """
        self.startAPICall()
        presence = self.cache.get("userPresence"+self.software)
        if isPresent==True:
            if presence==[]:
                presence={userID:time.time()}
            else:
                presence[userID]=time.time()
        else:
            if presence==[]:
                pass
            else:
                try:
                    presence.pop(userID)
                except:
                    pass
        self.cache.set("userPresence"+self.software,presence)
        self.stopAPICall()

    def toJulian(self,theDate=None):
        """
        Convert a date to julian (defined as how many days since 1/1/1980) or pass the julian for today if no params
        
        :param theDate: date %m/%d/%y or GMT format %b %d %Y
        """
        foxStart= datetime.strptime("01/01/1980","%m/%d/%Y")
        if theDate==None:theday = datetime.now()
        else:
            if "GMT" in theDate:
                theDate = " ".join(theDate.split(" ")[1:4])
                theday = datetime.strptime(theDate,"%b %d %Y")
            else:
                theday = datetime.strptime(theDate,"%m/%d/%Y")
        if foxStart==theday:return 0
        julian = str(theday-foxStart).split(" ")[0]
        return int(julian)

    def fromJulian(self,theNumber=None):
        """
        Convert a julian (defined as how many days since 1/1/1980) to a legitamate date

        :param theNumber: numeric
        """
        try:
            foxStart= datetime.strptime("01/01/1980","%m/%d/%Y")
            if theNumber is None:
                theNumber = self.toJulian()
            dateString = foxStart + timedelta(days=int(theNumber))
            #TODO get locale to determine how to return the date
            dateString = dateString.strftime("%m/%d/%Y")[0:10]
            return dateString
        except:
            return ""

    def setDebugLines(self,modname,*debugLines):
        """
        set debug lines for debugging
        
        :param modulename:
        :param *debugLines:
        """
        self.startAPICall()
        self.cache.set("debugLines"+modname+self.uiSpoolID,[modname,debugLines])
        self.stopAPICall()

    def getDebugLines(self,modname,spoolID):
        """
        get a list of debug lines for debugging

        :param modname:
        :param spoolID:
        """
        self.startAPICall()
        self.cache.get("debugLines"+modname+spoolID)
        self.stopAPICall()

    def __setattr__(self, item, value):
        """
        subclass magic method that during a set it will store values for the class outside of an api call

        :param item:
        :param value:
        """
        if self.__dict__.has_key(item):
            if "Widget object" in repr(self.__dict__[item]):
                self.__dict__[item].setVal(value)
                ret=None
            else:
                ret=dict.__setattr__(self, item, value)
                self.cacheSet(item,value)
        else:
            ret=dict.__setattr__(self, item, value)
            self.cacheSet(item,value)
        return ret
            

    def set(self,item,value,protected=False):
        """
        set a global variable in the api to be retrieved by get
        """
        self.startAPICall()
        self.__dict__[item]=value
        if self.__dict__.has_key("cache"):
            self.cache.set("sessionObj"+self.uiSpoolID+self.currentModName+item,value)
            storedVals = self.cache.get("storedSets"+self.uiSpoolID+self.currentModName)
            if not [str(item),True] in storedVals and not [str(item),False] in storedVals:
                self.cache.append("storedSets"+self.uiSpoolID+self.currentModName,[str(item),protected])
        self.stopAPICall()

    def getMain(self,timeout=15):
        """
        get return data from the remote gui environment on a blocking function
        """
        acnt=0
        while True:
            currdata=self.cache.get(self.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==timeout*10:
                currdata=""
                break
            if currdata!=[]:
               self.cache.delete(self.spoolID+"receive"+self.threadID)
               break
        return currdata
    
    def cacheSet(self,item,value,protected=False,widgetname=""):
        """
        sets a class value in memory to be regenerated on other events
        """
        if self.__dict__.has_key("storeSet"):
            if self.storeSet:
                self.cache.set("sessionObj"+self.uiSpoolID+self.currentModName+widgetname+item,value)
                storedVals = self.cache.get("storedSets"+self.uiSpoolID+self.currentModName+widgetname)
                if not [str(item),True] in storedVals and not [str(item),False] in storedVals:
                    self.cache.append("storedSets"+self.uiSpoolID+self.currentModName+widgetname,[str(item),protected])
        else:
            print("not saving item")
    
    def cacheUnSet(self,key):
        """
        remove stored sets from the cache of a session
        """
        widgetList = self.cache.get("storedSets"+self.uiSpoolID+self.currentModName+key)
        for akey,avalue in widgetList:
            self.cache.remove("sessionObj"+self.uiSpoolID+self.currentModName+key+akey)
        self.cache.remove("storedSets"+self.uiSpoolID+self.currentModName+key)
    
    def get(self,item,widgetname=""):
        """
        get a global variable that was set with the "set" function
        """
        self.startAPICall()
        value=self.cache.get("sessionObj"+self.uiSpoolID+self.currentModName+item+widgetname)
        if widgetname=="":
            self.__dict__[item]=value
        else:
            self.__dict__[widgetname].__dict__[item]=value
        self.stopAPICall()
        return str(value)

    def delete(self,item):
        """
        delete a global variable that was set with the "set" function
        """
        self.startAPICall()
        self.cache.delete("sessionObj"+self.uiSpoolID+self.currentModName+item)
        self.stopAPICall()

    def updateWidgets(self,widget,wtype):
        """
        internally used to update widgets that get created by other functions
        """
        self.startAPICall()
        widgetDict=self.cache.get(self.software+"uiDict"+self.uiSpoolID+self.currentModName)
        if widgetDict==[]:widgetDict={}
        widgetDict[widget]=wtype
        self.cache.set(self.software+"uiDict"+self.uiSpoolID+self.currentModName,widgetDict)
        self.stopAPICall()
        
    def cleanupThreads(self):
        """
        """
        self.startAPICall()
        directive=['cleanupthreads','',self.currentModName]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()
        
    def getWidgetDict(self):
        """
        """
        self.startAPICall()
        widgetDict=self.cache.get(self.software+"uiDict"+self.uiSpoolID+self.currentModName)
        self.stopAPICall()
        return widgetDict

    def addressWidget(self,widget,atype,parentWidget=None,customlib="",addressClass=None):
        """
        create a widget in the current scope
        """
        self.startAPICall()
        if addressClass is None:addressClass=Widget
        widget=str(widget)
        atype = atype.upper()
        if customlib!="":
            self.__dict__[widget] = self.getSoftwareModule(customlib).module
            self.__dict__[widget] = self.__dict__[widget](self,widget,atype,parentWidget)
            self.cache.set("storedSets"+self.uiSpoolID+self.currentModName+widget+"lib",customlib)
        else:
            self.__dict__[widget]=addressClass(self,widget,atype,parentWidget)
        self.updateWidgets(widget,atype)
        self.stopAPICall()
        
    #add a signal to a widget and set code server side that will run when that signal is triggered
    def addSignal(self,widget,signal,calldef,*returnargs,**kwargs):
        """
        """
        kwargList = ['returnvals','sigallow','calldefwidget','timeout','keytimeout']
        for argname in kwargs.keys():
            if not argname in kwargList:
                raise Exception("Invalid keywork argument " + argname + " in addSignal")
        self.startAPICall()
        threadtype="unthreaded"
        if not type(widget) is str:
            theType      = widget.type
            if widget.type=="TIMER":
                threadtype="unthreaded"
            widget=widget.name
        else:
            if "." in widget:
                theType = self.__dict__[widget.split(".")[-1]].type
            else:
                theType = self.__dict__[widget].type
        try:
            parentWidget = self.__dict__[widget].parentWidget
            if not parentWidget is None:
                parentWidgetType=parentWidget.type
                parentWidget=parentWidget.name
            else:
                parentWidget=""
                parentWidgetType=""
        except:
            parentWidget=""
            parentWidgetType=""
        if not type(calldef) is str:calldef=calldef.__name__
        if theType=="TABLE" and signal.lower()=="onsearchselect":
            self.__dict__[widget].addSearchCallback(calldef)
            return
        if theType=="TABLE" and signal.lower()=="onkbreturn":
            self.__dict__[widget].addKbCallback(calldef)
            return
        retargs = '|**|'.join(returnargs)
        if "sigallow" in kwargs:
            sigallow=kwargs['sigallow']
        else:
            sigallow=False
        if "timeout" in kwargs:
            timeout=kwargs['timeout']
            if int(timeout) <20:
                timeout = int(timeout)*100
        elif signal=="onChange":
            timeout = 0
        else:
            timeout=100
        if "keytimeout" in kwargs:
            keytimeout=kwargs['keytimeout']
            if int(timeout) <20:
                keytimeout = int(timeout)*100
        else:
            keytimeout=1200
        retvals = ""
        if "returnvals" in kwargs:
            for aretval in kwargs['returnvals']:
                try:
                    retvals+=aretval.name+"(*)"+aretval.type+"[&]"
                except:
                    retvals+=str(aretval)+"(*)GLOBAL[&]"
        cdefwidget = ""
        if "calldefwidget" in kwargs:
            if type(kwargs['calldefwidget']) is str:
                cdefwidget=kwargs['calldefwidget']
            else:
                cdefwidget=kwargs['calldefwidget'].name
        directive=['signal',widget,signal,calldef,self.currentModName,threadtype,theType,parentWidget,parentWidgetType,retargs,sigallow,retvals,cdefwidget,keytimeout,timeout]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    def passDirective(self,directive,addWidgetName=None,addWidgetType=None,returnTimeout=15):
        self.startAPICall()
        self.passCall(directive)
        if not addWidgetName is None:self.addressWidget(addWidgetName,addWidgetType)
        self.stopAPICall()
        if directive[-1]=="blockingCall":
            return self.getMain(returnTimeout)
        else:
            return None

    def addWebSocket(self,socketname,wsurl,wsprotocol):
        directive=['addwebsocket',"mainwindow",socketname,"WINDOW",wsurl,wsprotocol]
        self.passDirective(directive,socketname,"WEBSOCKET")
 
    def addToolbar(self,toolBarWidget,iconsize=32,alignment="left"):
        if type(toolBarWidget) != str:toolBarWidget = toolBarWidget.name
        directive=['addtoolbar',"mainwindow",toolBarWidget,"WINDOW",iconsize,alignment]
        self.passDirective(directive,toolBarWidget,"TOOLBAR")

    def addMenu(self,menuWidget):
        if type(menuWidget) != str:menuWidget = menuWidget.name
        directive=['addmenu',"mainwindow",menuWidget,"WINDOW"]
        self.passDirective(directive,menuWidget,"MENU")

    def addLayout(self,layoutWidget,pattern,cell="a"):
        if type(layoutWidget) != str:layoutWidget = layoutWidget.name
        directive=['addlayout',"mainwindow",layoutWidget,self.type,cell,pattern]
        self.passDirective(directive,layoutWidget,"LAYOUT")
   
    def addForm(self,formWidget,formdata,cell="a"):
        if type(formWidget) != str:formWidget = formWidget.name
        directive=['addform',"mainwindow",formWidget,self.type,cell,formdata]
        self.passDirective(directive,formWidget,"FORM")
 
    def setStyle(self,skin):
        directive=['setstyle',"mainwindow",skin,"WINDOW"]
        self.passDirective(directive)
        
    def removeToolBar(self,toolBarWidget):
        if type(toolBarWidget) != str:toolBarWidget = toolBarWidget.name
        directive=['removetoolbar',"","",toolBarWidget]
        self.passDirective(directive)
        
    def addToolBarBreak(self,toolBarWidget):
        if type(toolBarWidget) != str:toolBarWidget = toolBarWidget.name
        directive=['addtoolbarbreak',"","",toolBarWidget]
        self.passDirective(directive)

    def makeTimer(self,widgetName,interval,calldef=""):
        if not type(calldef) is str:calldef=calldef.__name__
        directive=['maketimer',widgetName,calldef,interval]
        self.passDirective(directive,widgetName,"TIMER")

    def makeStopWatch(self,elementName):
        directive=['makestopwatch',elementName]
        self.passDirective(directive,elementName,"STOPWATCH")

    def setGlobalCaretInsert(self,keyCode,insertString):
        directive=['setglobalcaretinsert',keyCode,insertString]
        self.passDirective(directive)
        
    def storeSoftwareSetting(self,setting,value):
        directive=['storesoftwaresetting',setting,value]
        self.passDirective(directive)

    def getSoftwareSetting(self,setting,default=""):
        directive=['getsoftwaresetting',setting,self.spoolID,default]+['blockingCall']
        return self.passDirective(directive)

    def getRemoteWidgets(self,parent="mainwindow",parentWidget=None,internal=False):
        self.startAPICall()
        if internal:
            if not parentWidget is None:
                parentWidget.addressWidget("dhxWins","WINDOWMANAGER")
            else:
                self.addressWidget("dhxwins","WINDOWMANAGER")
        directive=['getwidgets',parent,self.spoolID]+['blockingCall']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.cache.get(self.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.acnt:
                currdata=""
                break
            if currdata!=[]:
               self.cache.delete(self.spoolID+"receive"+self.threadID)
               break
        self.stopAPICall()
        print "remote widgets",currdata
        if currdata!="":
            try:
                adict = json.loads(currdata)
            except:
                adict = {}
            for key,value in adict.items():
                if key!="widgettype":
                    if not parentWidget is None:
                        parentWidget.addressWidget(key,value)
                    else:
                        self.addressWidget(key,value)
        else:
            adict = {}
        return adict

    def setExitDef(self,calldef):
        if not type(calldef) is str:calldef=calldef.__name__
        directive=['setexitdef',"","",calldef,self.currentModName]
        self.passDirective(directive)

    def closeEventCallback(self,calldef):
        if not type(calldef) is str:calldef=calldef.__name__
        directive=['closeeventcallback',"","","","",self.currentModName,calldef]
        self.passDirective(directive)
        
    def cancelSignal(self):
        directive=['cancelsignal']
        self.passDirective(directive)

    def addClientSignal(self,buttonWidget,signal,directive,threaded="threaded",actionDef="",*defArgs):
        """
        add a signal to a widget and send the directives to the client side to be executed
        so that any simple thing that the client can do will be done there instead of talking
        to the server to do simple tasks
        """
        self.startAPICall()
        self.addingClientSignal=True
        if type(buttonWidget) != str:buttonWidget = buttonWidget.name
        if type(actionDef)    != str:actionDef    = actionDef.__name__
        self.clientBuffer=[]
        try:
            if len(defArgs)>0:
                directive(*defArgs)
            else:
                directive()
        except:
            pass
        import copy
        dirList=copy.deepcopy(self.clientBuffer)
        self.clientBuffer=[]
        directive=['clientsignal',buttonWidget,[],[],dirList,signal,self.currentModName,actionDef,threaded]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.addingClientSignal=False
        self.stopAPICall()

    #add a process that will run a program on the client side
    def addProcess(self,processName,program, arguments=[], modal=False, asoftware="", actionDef="", stdOutDef=""):
        self.startAPICall()
        #sender = self.getSender()
        if type(processName) != str:processName=processName.__name__
        if type(actionDef)   != str:actionDef    = actionDef.__name__
        if type(stdOutDef)   != str:stdOutDef    = stdOutDef.__name__
        self.addressWidget(processName,"PROCESS")
        directive=['addprocess',processName,program,arguments,modal,asoftware,actionDef,self.spoolID,self.currentModName,stdOutDef]
        if self.addingClientSignal:
            self.clientBuffer.append(directive)
            self.stopAPICall()
            return
        else:
            self.clientBuffer=[directive]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    def setTalkBox(self,talkboxWidget):
        if not type(talkboxWidget) is str:talkboxWidget=talkboxWidget.name
        directive=['talkbox',talkboxWidget]
        self.passDirective(directive)
        
    def setWindowFocusDef(self, actionDef):
        if type(actionDef) != str:actionDef=actionDef.__name__
        directive=['setwindowfocusdef',actionDef,self.currentModName]
        self.passDirective(directive)

    def hasClipboardText(self):
        self.startAPICall()
        directive=['hasclipboardtext',self.spoolID]+['blockingCall']
        return self.passDirective(directive)
        
    def enableRestore(self,abool):
        directive=['enablerestore',abool]
        self.passDirective(directive)

    #add a signal to a widget that will trigger a process that was created
    def addProcessSignal(self,widget,signal,calldef,threadtype="threaded"):
        if not type(widget) is str:widget=widget.name
        if not type(calldef) is str:calldef=calldef.name
        directive=['signal',widget,signal,calldef,self.currentModName,threadtype]
        self.passDirective(directive)

    #resize the currently active window
    def resizeWindow(self,width,height):
        directive=['mainresize',str(width),str(height)]
        self.passDirective(directive)
        
    #listen to all keystrokes typed into a specific widget also define the
    #key that will stop the listening and the function to run server side
    #when listening is done
    def keyListen(self,valueSet,listenWidgets,typeValueActions,actionDef):
        if type(valueSet)  != str:valueSet=valueSet.name
        if type(actionDef) != str:actionDef=actionDef.__name__
        directive=['keylisten',valueSet,self.currentModName,listenWidgets,typeValueActions,actionDef]
        self.passDirective(directive)

    #get a global that is stored on the client side
    def getGlobal(self,value):
        self.startAPICall()
        directive=['getglobal',value,self.spoolID,"VALUE"]+['blockingCall']
        return self.passDirective(directive)

    def getWindowTitle(self):
        self.startAPICall()
        directive=['getwindowtitle',self.spoolID]+['blockingCall']
        return self.passDirective(directive)

    def setWindowTitle(self,text):
        directive=['setwindowtitle',self.spoolID,text]
        self.passDirective(directive)

    def setWindowSize(self,width,height):
        directive=['setwindowsize',self.spoolID,str(width),"",str(height)]
        self.passDirective(directive)

    #set a global that is stored on the client side and server side
    def setGlobal(self,value,text):
        directive=['setglobal',value,self.spoolID,"VALUE",text]
        self.passDirective(directive)
        setattr(self,value,text)

    #fill up the client clipboard with some data
    def loadClipboard(self,text):
        directive=['loadclipboard',text,self.spoolID,"TEXT"]
        self.passDirective(directive)

    def storeState(self,widget,whattostore,default=""):
        if type(widget) != str:awidget=widget.name
        else:awidget="NONE"
        if type(widget) != str:atype=widget.type
        else:atype="NONE"
        directive=['storestate',awidget,self.spoolID,atype,whattostore.upper(),default]
        self.passDirective(directive)

    #show a message box on the client screen
    def messageBox(self,title,message="",blocking=True,name=""):
        if message=="":message=title;title="pop"
        self.cache.delete(self.spoolID+"receive"+self.threadID)
        if blocking:thedir="messagebox"
        directive=[thedir,title,self.spoolID,message,name]+['blockingCall']
        return self.passDirective(directive)

    #show a message box on the client screen
    def colorDialog(self,title):
        self.startAPICall()
        self.cache.delete(self.spoolID+"receive"+self.threadID)
        directive=["colordialog",title,self.spoolID]+['blockingCall']
        return self.passDirective(directive)

    def getResolution(self):
        self.cache.delete(self.spoolID+"receive"+self.threadID)
        directive=["getresolution","",self.spoolID]+['blockingCall']
        return self.passDirective(directive)
        
    def getPrinterList(self):
        self.cache.delete(self.spoolID+"receive"+self.threadID)
        directive=["getprinterlist","",self.spoolID]+['blockingCall']
        return self.passDirective(directive)

    def storedata(self,key,value):
        self.startAPICall()
        if self.env == "webgui":
            self.parent.cache.set(key,value)
        else:
            pickled_value = pickle.dumps(value)
            self.cache.set(key,pickled_value)
        self.stopAPICall()

    def dataFill(self,lun,data,fields,procname):
        self.startAPICall()
        if not type(procname) is str:procname=procname.name
        dataid=str(uuid.uuid1()).lstrip("{").rstrip("}").replace("-","")
        directive=['datafill',str(lun),dataid,'',fields,procname]
        self.addressWidget("db"+str(lun),"DATABUCKET")
        self.storedata(dataid,data)
        if self.addingClientSignal:
            self.clientBuffer.append(directive)
            self.stopAPICall()
            return
        else:
            self.clientBuffer=[directive]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()

    def makeSocketObject(self,objectName,hostname="",port=0):
        self.startAPICall()
        directive=['makesocketobject',objectName,hostname,port]
        self.passDirective(directive,objectName,"TCPSOCKET")

    def http_request(self,hostname,request_data,urlAddon="",datatype="plain",ssl=False,username="",password=""):
        self.httpError = ""
        if ssl:url = "https://%s" % hostname
        else:url = "http://%s" % hostname
        
        if username!="":
            passManager = urllib2.HTTPPasswordMgrWithDefaultRealm()
            passManager.add_password(None,url,username,password)
            
            authHandler = urllib2.HTTPDigestAuthHandler(passManager)
            urlOpener = urllib2.build_opener(authHandler)
            
        else:
            urlOpener = urllib2.build_opener()
        
        if "/" in datatype:
            if request_data is None:
                pass
            elif len(request_data)==0:
                #urlOpener.add_headers={'Content-Type':datatype}
                pass
            else:
                urlOpener.add_headers={'Host':hostname, 'Content-Type':datatype, 'Content-Length':str(len(request_data))}
        else:
            urlOpener.add_headers={'Host':hostname, 'Content-Type':'text'+datatype, 'Content-Length':str(len(request_data))}
        
        try:
            if request_data=="":
                req = urlOpener.open(url+"/"+urlAddon)
            else:
                req = urlOpener.open(url+"/"+urlAddon,data=request_data)
        except urllib2.HTTPError as e:
            req = e
            self.httpError = str(e.code) + " " +  str(e)
        
        result=req.read()

        return result

    def http_requestA(self,hostname,request_data,urlAddon="",datatype="plain",ssl=False,username="",password="",method="POST"):
        self.httpError = ""
        if ssl:url = "https://%s" % hostname
        else:url = "http://%s" % hostname

        if username!="":
            passManager = urllib2.HTTPPasswordMgrWithDefaultRealm()
            passManager.add_password(None,url,username,password)

            authHandler = urllib2.HTTPDigestAuthHandler(passManager)
            urlOpener = urllib2.build_opener(authHandler)

        else:
            handler = urllib2.HTTPHandler()
            urlOpener = urllib2.build_opener(handler)

        if "/" in datatype:
            if request_data is None:
                pass
            elif len(request_data)==0:
                add_headers={'Content-Type':datatype}
            else:
                add_headers={'Host':hostname, 'Content-Type':datatype, 'Content-Length':str(len(request_data))}
        else:
            add_headers={'Host':hostname, 'Content-Type':'text'+datatype, 'Content-Length':str(len(request_data))}

        try:
            if request_data=="":
                req = urllib2.Request(url+"/"+urlAddon,data=None)
                for key,value in add_headers.items():
                    req.add_header(key,value)
                req.get_method = lambda: method
                res = urlOpener.open(req)
            else:
                if request_data==" ":request_data=""
                req = urllib2.Request(url+"/"+urlAddon,data=request_data)
                for key,value in add_headers.items():
                    req.add_header(key,value)
                req.get_method = lambda: method
                res = urlOpener.open(req)
        except urllib2.HTTPError as e:
            res = e
            self.httpError = str(e.code) + " "

        result=res.read()

        return result

    def sendHttpRequest(self,hostname,request_data="",urlAddon="",datatype="plain",ssl=False,username="",password=""):
        self.startAPICall()
        self.cache.delete(self.spoolID+"receive"+self.threadID)
        directive=["sendhttprequest",'',self.spoolID,hostname,request_data,urlAddon,datatype,ssl,username,password]+['blockingCall']
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.cache.get(self.spoolID+"receive"+self.threadID)
            time.sleep(0.15)
            if currdata!=[]:
               self.cache.delete(self.spoolID+"receive"+self.threadID)
               break
            if acnt==self.acnt:
                currdata=False
                break
            acnt+=1
        self.stopAPICall()
        return currdata

    def sendHttpRequestSVR(self,hostname,request_data="",urlAddon="",datatype="plain",ssl=False,username="",password=""):
        self.startAPICall()
        currdata = self.http_request(hostname,request_data,urlAddon,datatype,ssl,username,password)
        self.stopAPICall()
        return currdata

    #show a boolean box (OK / Cancel) with a question and get True or False return
    def booleanBox(self,title,message,okButtonText="Ok",cancelButtonText="Cancel"):
        self.cache.delete(self.spoolID+"receive"+self.threadID)
        directive=["booleanbox",title,self.spoolID,message,okButtonText,cancelButtonText]+['blockingCall']
        return self.passDirective(directive)

    def runStripe(self,publickey):
        self.cache.delete(self.spoolID+"receive"+self.threadID)
        directive=["runstripe",publickey,self.spoolID]+['blockingCall']
        return self.passDirective(directive)

    #show an input box that expects entry on a line edit as a return value
    def inputBox(self,title,form):
        self.cache.delete(self.spoolID+"receive"+self.threadID)
        directive=["inputbox",title,self.spoolID,form]+['blockingCall']
        return self.passDirective(directive)

    #show a file search dialog box on the client side for the client to
    #choose a file and path to be sent back
    def fileDialog(self,title,startpath,lookForDir=False):
        self.cache.delete(self.spoolID+"receive"+self.threadID)
        directive=["filedialog",title,self.spoolID,startpath,lookForDir]+["blockingCall"]
        return self.passDirective(directive)

    def focusWidget(self):
        self.startAPICall()
        self.cache.delete(self.spoolID+"receive"+self.threadID)
        directive=["focuswidget",'',self.spoolID]+['blockingCall']
        return self.passDirective(directive)
        
    def setFocusVal(self,value,thetype="FOCUS"):
        directive=['setvalue','',str(self.spoolID),thetype,value]
        self.passDirective(directive)
        
    def getFocusVal(self,value,thetype="FOCUS"):
        directive=['getfocusval',self.spoolID,thetype]+['blockingCall']
        return self.passDirective(directive)
        
    #create a UI file on the server side if one does not exists
    def createDialogUI(self,filename):
        self.startAPICall()
        dui = open(filename,"w")
        dui.write(filestubs.uiDialogStub)
        dui.close()
        self.stopAPICall()
    
    def createMainWindowUI(self,filename,altfilename=""):
        self.startAPICall()
        dui = open(filename,"w")
        dui.write(filestubs.uiMainWindowStub)
        dui.close()
        if altfilename!="":
            dui = open(altfilename,"w")
            dui.write(filestubs.uiMainWindowStub)
            dui.close()
        self.stopAPICall()
    
    #create a module file on the server is one does not exists
    def createModFile(self,filename,stubType="mod"):
        stubdat=filestubs.modStub
        if stubType.lower()=="grid":stubdat=filestubs.modGridStub
        if stubType.lower()=="conv":stubdat=filestubs.modConvStub
        self.startAPICall()
        mod = open(filename,"w")
        mod.write(stubdat)
        mod.close()
        self.stopAPICall()

    #android function
    def backHook(self,funcName):
        self.startAPICall()
        directive=['backhook',funcName,'',self.currentModName]
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()
        
    #android function        
    def homeHook(self,funcName):
        directive=['homehook',funcName,'',self.currentModName]
        self.passDirective(directive)
        
    #android function        
    def menuHook(self,funcName):
        directive=['menuhook',funcName,'',self.currentModName]
        self.passDirective(directive)
        
    #android and possibly other mobile devices function
    def showKeyboard(self):
        directive=['showkeyboard']
        self.passDirective(directive)
        
    def askForClose(self):
        directive=['askforclose']
        self.passDirective(directive)

    #create a module file on the server is one does not exists
    def createWebModFile(self,filename):
        self.startAPICall()
        mod = open(filename,"w")
        mod.write(filestubs.modWebStub)
        mod.close()
        self.stopAPICall()

    #create quickbooks object
    def createQBObject(self,widgetName,filepath):
        self.startAPICall()
        directive=['createqbobject',widgetName,self.spoolID,filepath]+['blockingCall']
        return self.passDirective(directive,widgetName,"QBOBJECT")

    #show a dialog box and if the dialog ui does not exist for this dialog create it
    #and if the mod does not exist for this dialog create it as well.
    #Then display the dialog client side and make it the main screen
    def dialogBox(self,dialog,title,width=0,height=0,actionDef="",widgetUI="",software=""):
        if software=="":software=self.software
        if type(actionDef) != str:actionDef=actionDef.__name__
        if type(widgetUI)  != str:widgetUI=widgetUI.name
        dialog=dialog.upper()
        try:
            uifile = glob.glob('obj' + software + sep + dialog.upper() + '.ui')
            module = glob.glob('obj' + software + sep + "mod_" + dialog.upper() + '.p*')
        except:
            pass
        self.cache.delete(self.spoolID+"receive"+self.threadID)
        directive=["dialogbox",title,self.spoolID,dialog,width,height,self.currentModName,actionDef,widgetUI,software]
        self.passDirective(directive,dialog.lower(),"DIALOGBOX")
        
    def softwareDialog(self,software,title,actionDef="",width=0,height=0):
        self.assignWidgetUI(software+"module",software,software)
        self.dialogBox(software,title,width,height,actionDef,software+"module",software)

    def getSoftwareModule(self,moduleName):
        plugin = ziptestweb.loadPaceModule(self.software,moduleName,"0123456789abcdef")
        self.stopAPICall()
        return plugin

    def assignWidgetUI(self,widgetName,uiClass,uiSoftware=""):
        self.addressWidget(widgetName,"CUSTOMWIDGET")
        directive=["assignwidgetui",self.spoolID,uiClass,self.currentModName,widgetName,uiSoftware]
        self.passDirective(directive,widgetName,"CUSTOMWIDGET")

    def startCustomEventListener(self):
        directive=["startcustomeventlistener",self.spoolID,'',self.currentModName]
        self.passDirective(directive)
        
    def assignScribbleWidget(self,widgetName,addToWidget):
        directive=["assignscribblewidget",self.spoolID,'',self.currentModName,widgetName,addToWidget.name]
        self.passDirective(directive,widgetName,"SCRIBBLEWIDGET")
        
    def assignCameraWidget(self,widgetName,addToWidget):
        self.addressWidget(widgetName,"CAMERAWIDGET")
        directive=["assigncamerawidget",self.spoolID,'',self.currentModName,widgetName,addToWidget.name]
        self.passDirective(directive,widgetName,"CAMERAWIDGET")

    def exitModule(self,moduleToExit=""):
        #self.flushBuffer()
        self.startAPICall()
        directive=["exitmodule",moduleToExit]
        self.passDirective(directive)
        if moduleToExit=="":
            self.autoDone=True
    
    def getTraceback(self):
        self.startAPICall()
        val=self.cache.get("TraceBack"+self.uiSpoolID)
        self.cache.delete("TraceBack"+self.uiSpoolID)
        self.stopAPICall()
        return val
                
    def createProject(self,software,web=False,modFileType="mod"):
        self.startAPICall()
        objFolder = glob.glob("obj" + software)
        if len(objFolder)==0:
            os.mkdir("obj" + software)
        uifile = glob.glob('obj' + software + sep + software + '.ui')
        if len(uifile)==0:
            self.createMainWindowUI('obj' + software + sep + software + '.ui',software + '.ui')
        module = glob.glob('obj' + software + sep + "mod_" + software + '.p*')
        if len(module)==0:
            self.createModFile('obj' + software + sep + "mod_" + software + '.py',modFileType)
            if web:self.createWebModFile('obj' + software + sep + "mod_web_" + software.lower() + '.py')
        self.stopAPICall()

    def createModule(self,software,modulename,dialog=False,modFileType="mod"):
        self.startAPICall()
        objFolder = glob.glob("obj" + software)
        if len(objFolder)==0:
            self.messageBox("Error","Unable to find Project")
            self.stopAPICall()
            return
        if dialog==True:
            uifile = glob.glob('obj' + software + sep + modulename + '.ui')
            if len(uifile)==0:
                self.createDialogUI('obj' + software + sep + modulename + '.ui')
        module = glob.glob('obj' + software + sep + "mod_" + modulename + '.p*')
        if len(module)==0:
            self.createModFile('obj' + software + sep + "mod_" + modulename + '.py',modFileType)
        self.stopAPICall()

    def setWindowIconFromWidget(self,widget,window):
        if type(widget) != str:widget=widget.name
        directive=['setwindowiconfromwidget',widget,window]
        self.passDirective(directive)
    
    def setWindowIconFromResource(self,pngfile,window):
        self.startAPICall()
        directive=['setwindowiconfromresource',pngfile,window]
        self.passDirective(directive)

    def centerWindow(self):
        directive=['centerwindow']
        self.passDirective(directive)

    def raiseScreen(self):
        self.startAPICall()
        directive=['raisescreen',self.spoolID]
        self.passDirective(directive)

    #send an error to be displayed client side console (for dev)
    def error(self,errorTrace):
        self.tellcli(errorTrace)

    #send a message to be displayed client side console (for dev)
    def tellcli(self,*args):
        #if self.notalk!="True":
        datstr=""
        for arg in args:
            datstr+=str(arg)+"\t"
        self.startAPICall()
        directive=['error',str(datstr)]
        #if not self.software=="WEBIDE":
        try:
            self.tracelog.write(str(datstr),2,self.parent.parentmod,self.parent.parentspool)
        except:
            print(datstr)
        self.cache.append(self.spoolID+"send"+self.threadID,directive)
        self.stopAPICall()
    
    def createShortcut(self,objname,shortcut,widget=""):
        directive=["createshortcut",objname,shortcut,widget]
        self.passDirective(directive,objname,"KEYACCEL")

    #an internal function to be used to finish a list of directives to the client
    #so that the client knows to stop looking
    def done(self):
        directive=["done"]
        self.passDirective(directive)
    
    def flushBuffer(self):
        directive=['signalflush',self.valueBuffer]+['blockingCall']
        return self.passDirective(directive)

    def doEvents(self):
        directive=['signalflush',self.valueBuffer]+['blockingCall']
        return self.passDirective(directive)

    def inBuffer(self,name):
        self.startAPICall()
        for adir in self.valueBuffer:
            if adir[1]==name:
                self.stopAPICall()
                return True
        self.stopAPICall()
        return False

    def getValueList(self,*args,**kwargs):
        self.startAPICall()
        valList  = []
        typeList = []
        valTypeListFill=False
        valExtraListFill=False
        if kwargs.has_key("valType"):
            valTypeList=kwargs["valType"]
        else:
            valTypeList=[]
            valTypeListFill=True
        if kwargs.has_key("valExtra"):
            valExtraList=kwargs["valExtra"]
        else:
            valExtraList=[]
            valExtraListFill=True
        for arg in args:
            try:
                valList.append(arg.getAddName()+arg.name)
                #if self.inBuffer(arg.name):self.flushBuffer()
                typeList.append(arg.type)
                if valTypeListFill:valTypeList.append("")
                if valExtraListFill:valExtraList.append("")
            except:
                valList.append(None)
                typeList.append("")
                if valTypeListFill:valTypeList.append("")
                if valExtraListFill:valExtraList.append("")
        directive=["getvaluelist",valList,self.spoolID,typeList,valTypeList,valExtraList]+['blockingCall']
        currdata = self.passDirective(directive)
        if type(currdata) is str:currdata=currdata.split(",")
        if not type(currdata) is bool:
            for arg in args:
                if typeList[currcnt]=="TABLE":
                    currdata[currcnt]= self.decode_base64(currdata[currcnt]).split("\n")
                arg.value=currdata[currcnt]
                currcnt+=1
        else:
            for arg in args:
                arg.value=""
        return currdata
    
    def decode_base64(self,data):
        missing_padding = 4 - len(data) % 4
        if missing_padding:
            data += b'='* missing_padding
        return base64.decodestring(data)

    def setValueList(self,*args):
        switch=0
        items=[]
        values=[]
        types=[]
        for arg in args:
            if switch==0:
                items.append(arg.name)
                types.append(arg.type)
                switch=1
            elif switch==1:
                values.append(arg)
                switch=0
        directive=["setvaluelist",items,self.spoolID,types,values]
        self.passDirective(directive)
        
                    
    #tells the client to end itself (goodbye)
    def exitProgram(self):
        directive=['exitprogram']
        self.passDirective(directive)
        
    def startSpinner(self):
        directive=['startspinner',"mainwindow"]
        self.passDirective(directive)
        self.flushBuffer()

    def stopSpinner(self):
        directive=['stopspinner',"mainwindow"]
        self.passDirective(directive)

    def printStart(self,printerName,formData,formXML,printFlags=""):
        directive=['printstart','mainwindow',self.spoolID,printerName,formData,formXML,printFlags]+['blockingCall']
        return self.passDirective(directive,None,None,999)

    def exitWindow(self):
        directive=['exitwindow']
        self.passDirective(directive)
        
    def closeHint(self):
        self.startAPICall()
        setList = self.cache.get("storedSets"+self.uiSpoolID+self.currentModName)
        for aset in setList:
            try:
                self.set(aset[0],self.__dict__[aset[0]])
            except:
                pass
        self.stopAPICall()

    def delAll(self,*args):
        self.startAPICall()
        self.cache.clearUID(self.uiSpoolID)
        self.stopAPICall()

    def getFieldClassInfo(self,gridClass,fields,keys,sortinfo):
        self.startAPICall()
        try:
            #agridclass = self.dbObj.getTable("yesgridclass")
            agridclass = self.db.yesgridclass
            
            retSel      = ""
            allRetSel   = ""
            funcDict    = {}
            filterDict  = {}
            allFuncList = []
            allFilterList = []
            allColNames = ['theKey']
            keyFuncList = []

            agridclass.acur = agridclass.find({"$and":[{"classname":gridClass},{"colorder":{"$lte":0}}]})
            if agridclass.acur.count()>0:
                theDB=agridclass.acur[0]['griddb']
            else:
                theDB = ""
            
            cnt=0
            #self.tellcli(gridClass,theDB)
            for akey in keys:
                if akey=="Sort Order":
                    if type(sortinfo) is list and len(sortinfo)>0:
                        akey=sortinfo[0]
                    else:
                        akey='nosort|'#' +"
                        retSel+=akey
                        
                
                agridclass.recDat=[]
                agridclass.acur = agridclass.find({"$and":[{"classname":gridClass},{"columnname":akey}]})
                if agridclass.acur.count()>0:agridclass.recDat=[agridclass.acur[0]['columntype'],agridclass.acur[0]['source']]
                
                if agridclass.recDat!=[] and agridclass.recDat!=None:
                    datline=agridclass.recDat
                    #self.tellcli("found key")
                    if datline[0]=="Field":
                        #retSel+="convert(varchar,"+datline[1]+")+ '|' +"
                        retSel+=str(datline[1])+"|"#+"+ '|' +"
                        #self.tellcli("added field")
                    else:
                        try:
                            funcField    = datline[1].split("(")[1].rstrip(" ").rstrip(")")
                            functionName = datline[1].split("(")[0]
                            retSel+=funcField+"|"#"+ '|' +"
                            keyFuncList.append([cnt,functionName])
                            #self.tellcli("added keyfunc")
                        except Exception, e:
                            retSel+=str(datline[1])+"|"#"+ '|' +"
                            #self.tellcli("error adding keyfunc",str(e))
                else:
                    pass
                    #self.tellcli(gridClass,akey,"not found")
                cnt+=1
                        
            sortKey=retSel
            #if retSel!="":
            #    retSel=retSel[:-1]+" as theKey"
            #elif type(sortinfo) is list and len(sortinfo)>0:
            retSel={0:retSel}
            retFld={}
            cnt=1
            allCnt=0

            agridclass.recDat = []
            agridclass.acur = agridclass.find({"$and":[{"classname":gridClass},{"colorder":{"$ne":-1}}]}).sort("colorder")
            for arec in agridclass.acur:agridclass.recDat.append([arec['columntype'],arec['source'],arec['columnname']])
                                 
            for fielddat in agridclass.recDat:
                afield=fielddat[2]
                datline=fielddat
                if datline[0]=="Field":
                    if afield in fields:
                        retSel[fields.index(afield)+1]=datline[1]
                        retFld[fields.index(afield)+1]=[fields.index(afield)+1,datline[1],afield]
                    allRetSel+=datline[1]+","
                elif datline[0]=="Function":
                    funcField = ""
                    try:
                        funcField    = datline[1].split("(")[1].rstrip(" ").rstrip(")")
                        functionName = datline[1].split("(")[0]
                        if afield in fields:
                            retSel[fields.index(afield)+1]=funcField
                            funcDict[fields.index(afield)+1]=[fields.index(afield)+1,functionName,afield]
                        allRetSel+=funcField+","
                        allFuncList.append([allCnt,functionName])
                    except Exception, e:
                        if afield in fields:
                            retSel[fields.index(afield)+1]=datline[1]
                        allRetSel+=funcField+","
                elif datline[0]=="Filter":
                    try:
                        funcField    = datline[1].split("(")[1].rstrip(" ").rstrip(")")
                        functionName = datline[1].split("(")[0]
                        if afield in fields:
                            retSel[fields.index(afield)+1]=funcField
                            filterDict[fields.index(afield)+1]=[fields.index(afield)+1,functionName,afield]
                        allRetSel+=funcField+","
                        allFilterList.append([allCnt,functionName])
                    except:
                        if afield in fields:
                            retSel[fields.index(afield)+1]=datline[1]
                        allRetSel+=funcField+","
                    
                allCnt+=1
                allColNames.append(afield)
            
            retVal=[]
            for d in sorted(retSel.keys()):retVal.append(retSel[d])
            retSel=','.join(retVal)
            
            usedfldList=[]
            for d in sorted(retFld.keys()):usedfldList.append(retFld[d])
            
            funcList=[]
            for d in sorted(funcDict.keys()):funcList.append(funcDict[d])
            
            filterList=[]
            for d in sorted(filterDict.keys()):filterList.append(filterDict[d])
            
            allRetSel=allRetSel[:-1]
        except Exception, e:
            self.tellcli(str(e))
            self.tellcli(str(formatExceptionInfo()))
        self.stopAPICall()
        return retSel,sortKey,theDB,funcList,filterList,keyFuncList,allRetSel,allFuncList,allColNames,allFilterList,usedfldList

    def getKeyClassInfo(self,gridClass):
        self.startAPICall()
        agridkey = self.db.yesgridkeys

        agridkey.recDat=[]
        agridkey.acur = agridkey.find({"classname":gridClass}).sort("keyorder")
        for arec in agridkey.acur:agridkey.recDat.append([arec['classkey']])
                           
        retDat=[]
        for adat in agridkey.recDat:
            retDat.append(adat[0])
                            
        self.stopAPICall()
        return retDat

    def getFieldClassList(self,gridClass):
        self.startAPICall()
        agridclass = self.parent.parent.mongoClient.pacemain.yesgridclass
        
        recDat = []
        acur = agridclass.find({"$and":[{"classname":str(gridClass)},{"colorder":{"$gte":0}}]}).sort("colorder")
        self.tellcli({"$and":[{"classname":str(gridClass)},{"colorder":{"$gte":0}}]}) 
        for arec in acur:
            #self.tellcli("REC",arec)
            recDat.append([arec['colorder'],'0',arec['columnname']])
        
        if recDat!=[] and recDat!=None:
            self.stopAPICall()
            return recDat
        else:
            self.stopAPICall()
            return []
            
    def cacheTable(self,tableName,tableKey=""):
        if self.cache.gpdbconn.root.has_key(tableName):
            retTable=self.cache.gpdbconn.root[tableName]
        else:
            self.cache.gpdbconn.root[tableName]=self.cache.gpdb.table(tableName,tableKey)
            retTable = self.cache.gpdbconn.root[tableName]
        return retTable

                
class Widget(object):
    def __init__(self,parent,name,type,parentWidget=None):
        if not parentWidget is None:
            self.parentWidget = parentWidget
        else:
            self.parentWidget = None
        self.widgetLib = ""
        self.parent = parent
        self.threadID = self.parent.threadID
        self.name = name
        self.type = str(type)
        self.value = None
        self.binding = {}
        self.isValid = 1


    def tr(self,words):
        #return words[::-1]
        return words

    def __str__(self):
        return str(self.value)

    def tellcli(self,*args):
        self.parent.tellcli(*args)

    def messageBox(self,*args):
        self.parent.messageBox(*args)

    def __setattr__(self, item, value):
        if "parent" in self.__dict__ and "name" in self.__dict__: 
            try:
                self.parent.__dict__[self.name].__dict__[item]=value
                self.parent.cacheSet(item,self.__dict__[item],False,self.name)
            except:
                pass
        ret=dict.__setattr__(self, item, value)
        return ret
 
    def addressWidget(self,widget,atype,extraParent=False,addressClass=None):
        self.parent.stopAPICall()
        if addressClass is None:addressClass=Widget
        widget=str(widget)
        atype = atype.upper()
        setattr(getattr(self.parent,self.name),widget,addressClass(self.parent,widget,atype,self))
        self.parent.cacheSet(widget,self.__dict__[widget],False,self.name)

    #add a signal to a widget and set code server side that will run when that signal is triggered
    def addSignal(self,widget,signal,calldef,*args,**kwargs):
        kwargList = ['returnvals','sigallow','calldefwidget','timeout','keytimeout']
        for argname in kwargs.keys():
            if not argname in kwargList:
                raise Exception("Invalid keywork argument " + argname + " in addSignal")
        self.parent.startAPICall()
        if not type(widget) is str:
            theType = widget.type
            widget  = widget.name
        else:
            theType = self.__dict__[widget].type
        if not type(calldef) is str:
            calldef=calldef.__name__
        theLib = self.widgetLib
        if "sigallow" in kwargs:
            sigallow=kwargs['sigallow']
        else:
            sigallow=False
        retargs = '|**|'.join(args)
        retvals = ""
        if theType=="TABLE" and signal.lower()=="onsearchselect":
            self.__dict__[widget].addSearchCallback(calldef)
            return
        if theType=="TABLE" and signal.lower()=="onkbreturn":
            self.__dict__[widget].addKbCallback(calldef)
            return
        if theType=="TABLE" and signal.lower()=="ontotalcheck":
            self.__dict__[widget].addTotalCheckCallback(calldef)
            return
        if "returnvals" in kwargs:
            for aretval in kwargs['returnvals']:
                try:
                    retvals+=aretval.getAddName()+aretval.name+"(*)"+aretval.type+"[&]"
                except Exception as e:
                    print(e)
                    retvals+=str(aretval)+"(*)GLOBAL[&]"
        cdefwidget = ""
        if "calldefwidget" in kwargs:
            if type(kwargs['calldefwidget']) is str:
                cdefwidget=kwargs['calldefwidget']
            else:
                cdefwidget=kwargs['calldefwidget'].name
        if "timeout" in kwargs:
            timeout=kwargs['timeout']
            if int(timeout) <20:
                timeout = float(timeout)*100
        elif signal=="onChange":
            timeout = 0
        #elif signal=="onRowSelect":
        #    timeout = 270
        else:
            timeout=100
        if "keytimeout" in kwargs:
            keytimeout=kwargs['keytimeout']
            if int(timeout) <20:
                keytimeout = float(timeout)*100
        else:
            keytimeout=1200
        directive=['widgetsignal',widget,signal,calldef,self.parent.currentModName,"",theType,self.name,theLib,sigallow,retargs,retvals,cdefwidget,keytimeout,timeout]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    def getAddName(self):
        retname = ""
        if self.parentWidget=="":return ""
        onObj = self.parentWidget
        if not onObj is None:
            while True:
                if not onObj is None:
                    retname=onObj.name+"."+retname
                else:
                    break
                try:
                    onObj = onObj.parentWidget
                except:
                    break
        
        return retname

    def getAddType(self):
        rettype = ""
        onObj = self.parentWidget
        if not onObj is None:
            while True:
                if not onObj is None:
                    rettype=onObj.type+"."+rettype
                else:
                    break
                try:
                    onObj = onObj.parentWidget
                except:
                    break
        return rettype

    def passDirective(self,directive,addWidgetName=None,addWidgetType=None,addWidgetToParent=True,returnTimeout=15):
        self.parent.startAPICall()
        self.parent.passCall(directive)
        if not addWidgetName is None:
            if addWidgetToParent:
                self.parent.addressWidget(addWidgetName,addWidgetType)
            else:
                self.doAddAddress(addWidgetName,addWidgetType)
        self.parent.stopAPICall()
        if directive[-1]=="blockingCall":
            return self.parent.getMain(returnTimeout)
        else:
            return None

    def close(self,*args):
        directive=['close',self.getAddName()+self.name,str(self.parent.spoolID),self.type]
        self.passDirective(directive)
        if self.type=="DIALOG":self.parent.cacheUnSet(self.name)

    def toJulian(self,theDate=None):
        foxStart= datetime.strptime("01/01/1980","%m/%d/%Y")
        if theDate==None:theday = datetime.now()
        else:
            if "GMT" in theDate:
                theDate = " ".join(theDate.split(" ")[1:4])
                theday = datetime.strptime(theDate,"%b %d %Y")
            else:
                theday = datetime.strptime(theDate,"%m/%d/%Y")
        if foxStart==theday:return 0
        julian = str(theday-foxStart).split(" ")[0]
        return int(julian)

    def fromJulian(self,theNumber=None):
        try:
            foxStart= datetime.strptime("01/01/1980","%m/%d/%Y")
            if theNumber is None:
                theNumber = self.toJulian()
            dateString = foxStart + timedelta(days=int(theNumber))
            #TODO add locale to determine how to return the date
            dateString = dateString.strftime("%m/%d/%Y")[0:10]
            return dateString
        except:
            return ""

    def show(self,widgetname=""):
        self.parent.startAPICall()
        if not self.name+"hse" in self.parent.__dict__:
            directive=['show',self.getAddName()+self.name,self.parent.spoolID,self.type,widgetname]
        else:
            directive=['show',self.getAddName()+self.parent.__dict__[self.name+'hse'],self.parent.spoolID,"HTMLELEMENT",widgetname]
        self.passDirective(directive)
    
    def showKeyboard(self,keyflag=""):
        directive=['showkeyboardwidget',self.getAddName()+self.name,self.parent.spoolID,self.type,keyflag]
        self.passDirective(directive)

    def expandAll(self):
        directive=['expandall',self.getAddName()+self.name,self.parent.spoolID,self.type]
        self.passDirective(directive)

    def collapseAll(self):
        directive=['collapseall',self.getAddName()+self.name,self.parent.spoolID,self.type]
        self.passDirective(directive)

    def stopTimer(self):
        directive=['stoptimer',self.getAddName()+self.name,self.parent.spoolID,self.type]
        self.passDirective(directive)
    
    def setSpacing(self,spacing):
        directive=['setspacing',self.getAddName()+self.name,self.parent.spoolID,self.type,spacing]
        self.passDirective(directive)

    def setMargin(self,margin):
        directive=['setmargin',self.getAddName()+self.name,self.parent.spoolID,self.type,margin]
        self.passDirective(directive)

    def startTimer(self):
        directive=['starttimer',self.getAddName()+self.name,self.parent.spoolID,self.type]
        self.passDirective(directive)

    def startStopWatch(self):
        directive=['startstopwatch',self.getAddName()+self.name,self.parent.spoolID,self.type]
        self.passDirective(directive)

    def stopStopWatch(self):
        directive=['stopstopwatch',self.getAddName()+self.name,self.parent.spoolID,self.type]
        self.passDirective(directive)

    def getStopWatchSeconds(self):
        directive=['getstopwatchseconds',self.getAddName()+self.name,self.parent.spoolID]+['blockingCall']
        return self.passDirective(directive)

    def setInterval(self,interval=10):
        directive=['setinterval',self.getAddName()+self.name,self.parent.spoolID,self.type,interval]
        self.passDirective(directive)

    def assignLayout(self,widgetAssign):
        if type(widgetAssign) != str:widgetAssign=widgetAssign.name
        directive=["assignlayout",self.parent.spoolID,widgetAssign,self.parent.currentModName,self.getAddName()+self.name]
        self.passDirective(directive)
        
    def setWebLayout(self,widgetAssign,startURL=""):
        if type(widgetAssign) != str:widgetAssign=widgetAssign.name
        directive=["setweblayout",self.parent.spoolID,widgetAssign,self.parent.currentModName,self.getAddName()+self.name,startURL]
        self.passDirective(directive)

    def hideTitleBar(self):
        directive=['hidetitlebar',self.getAddName()+self.name,self.parent.spoolID,self.type]
        self.passDirective(directive)

    #set the top headers for a table
    def setTableHeaders(self,headers,headerFilters=[],secondaryHeader=[],footer=[]):
        directive=['tableheaders',self.getAddName()+self.name,headers,self.type,headerFilters,secondaryHeader,footer]
        self.passDirective(directive)

    def updateFooter(self,footer):
        directive=['updatefooter',self.getAddName()+self.name,footer,self.type]
        self.passDirective(directive)

    def setFilterValue(self,column,value):
        directive=['setfiltervalue',self.getAddName()+self.name,"",self.type,column,value]
        self.passDirective(directive)
    
    #set the top headers for a table
    def setSelectMode(self,selmode):
        directive=['setselectmode',self.getAddName()+self.name,selmode,self.type]
        self.passDirective(directive)
    
    def setTableAlignments(self,alignments):
        directive=['settablealignments',self.getAddName()+self.name,alignments,self.type]
        self.passDirective(directive)

    def setTableRowNoSelect(self,row):
        directive=['settablerownoselect',self.getAddName()+self.name,self.type,row]
        self.passDirective(directive)

    def setTableRowStyles(self,rowid,bgcolor,rowstyle="",celloptions=[]):
        directive=['settablerowstyles',self.getAddName()+self.name,self.type,rowid,bgcolor,rowstyle,celloptions]
        self.passDirective(directive)
        
    def keySort(self):
        directive=['keysort',self.getAddName()+self.name,self.type]
        self.passDirective(directive)
    
    def setDragDropEnabled(self,abool=True):
        enabled="true"
        if not abool:enabled="false"
        directive=['setdragdropenabled',self.getAddName()+self.name,self.type,enabled]
        self.passDirective(directive)

    def setMultilineEnabled(self,abool=True):
        enabled="true"
        if not abool:enabled="false"
        directive=['setmultilineenabled',self.getAddName()+self.name,self.type,enabled]
        self.passDirective(directive)

    def setColumnMoveEnabled(self,abool=True):
        enabled="true"
        if not abool:enabled="false"
        directive=['setcolumnmoveenabled',self.getAddName()+self.name,self.type,enabled]
        self.passDirective(directive)
    
    def setToolTip(self,tipinfo):
        directive=['settooltip',self.getAddName()+self.name,tipinfo,self.type]
        self.passDirective(directive)

    def setTableWidths(self,widths):
        directive=['settablewidths',self.getAddName()+self.name,widths,self.type]
        self.passDirective(directive)

    def setTableFontStyle(self,fontstyle):
        directive=['settablefontstyle',self.getAddName()+self.name,fontstyle,self.type]
        self.passDirective(directive)

    def setFontSize(self,fontsize="12px"):
        if type(fontsize) is int or type(fontsize) is float:fontsize=str(fontsize)+"px"
        directive=['setfontsize',self.getAddName()+self.name,fontsize,self.type]
        self.passDirective(directive)

    def setTableColTypes(self,types):
        directive=['settablecoltypes',self.getAddName()+self.name,types,self.type]
        self.passDirective(directive)
        
    def setTableResizes(self,resizes):
        directive=['settableresizes',self.getAddName()+self.name,resizes,self.type]
        self.passDirective(directive)
        
    #fill a table one by one
    def fillTableOne(self,rowkey,data,position=0):
        directive=['tableaddone',self.getAddName()+self.name,data,position,self.type,rowkey]
        self.passDirective(directive)
        
    def addRow(self,data,position=0):
        directive=['tableaddone',self.getAddName()+self.name,data,position,self.type]
        self.passDirective(directive)
        
    def tableSortColumn(self,columnnum,AscOrDesc="asc"):
        directive=['tablesortcolumn',self.getAddName()+self.name,columnnum,0,AscOrDesc]
        self.passDirective(directive)
        
    def setColorStart(self,keyColStart,dataColStart):
        directive=['setcolorstart',self.getAddName()+self.name,keyColStart,0,dataColStart]
        self.passDirective(directive)
        
    def acceptDrop(self,acceptBool):
        directive=['acceptdrop',self.getAddName()+self.name,acceptBool]
        self.passDirective(directive)
        
    def setDefaultBackgroundColor(self,color):
        directive=['setdefaultbackgroundcolor',self.getAddName()+self.name,color]
        self.passDirective(directive)
    
    #add a row to a table using the key to replace a key that may already be there
    def addKey(self,data,keypos=None):
        directive=['tableaddkey',self.getAddName()+self.name,data,self.type,keypos]
        self.passDirective(directive)

    def deleteRow(self,row):
        directive=['deleterow',self.getAddName()+self.name,row,self.type]
        self.passDirective(directive)

    def deleteRowKey(self,rowKey,keypos=None):
        directive=['deleterowkey',self.getAddName()+self.name,rowKey,self.type,keypos]
        self.passDirective(directive)
        
    def selectRow(self,rowindex):
        directive=['selectrows',self.getAddName()+self.name,rowindex,self.type]
        self.passDirective(directive)
   
    def setCheckedColumn(self,colIndex,value=1):
        directive=['setcheckedcolumn',self.getAddName()+self.name,colIndex,self.type,value]
        self.passDirective(directive)

    def selectRowKey(self,rowindex):
        directive=['selectrowkeys',self.getAddName()+self.name,rowindex,self.type]
        self.passDirective(directive)

    def getWord(self):
        self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
        directive=["getword",self.getAddName()+self.name,self.parent.spoolID,self.type]+['blockingCall']
        return self.passDirective(directive)
    
    def signalFlush(self):
        self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
        directive=["signalflush",self.getAddName()+self.name,self.parent.spoolID,self.type]+['blockingCall']
        return self.passDirective(directive)

    def buildTableData(self,data,headers,widths=[],types=[],alignments=[],sorttypes=[]):
        self.parent.startAPICall()
        rtdat = {"head":[],"rows":[]}
        cnt = 0
        for nhead in headers:
            if len(widths)==len(headers):headwidth = widths[cnt]
            else: headwidth = 100
            if len(types)==len(headers):headtype = types[cnt]
            else: headtype = "ro"
            if len(alignments)==len(headers):headalign = alignments[cnt]
            else: headalign = "left"
            if len(sorttypes)==len(headers):headsort = sorttypes[cnt]
            else: headsort = "str"
            rtdat["head"].append({"width":headwidth,"type":headtype,"align":headalign,"sort":headsort,"value":headers[cnt]})
            cnt+=1
        for ndat in data:
            rtdat["rows"].append({"id":ndat[0],"data":ndat[1:]})
        self.parent.stopAPICall()
        return rtdat

    #fill the table with all the data to be displayed
    def fillTableMany(self,data,rowtoselect=-1):
        dataid=str(uuid.uuid1()).lstrip("{").rstrip("}").replace("-","")
        directive=['tablefill',self.getAddName()+self.name,dataid,self.type,rowtoselect]
        self.storedata(dataid,data)
        self.passDirective(directive)

    def schedulerFill(self,scheddata):
        directive=['schedulerfill',self.getAddName()+self.name,scheddata,self.type]
        self.passDirective(directive)

    def fillTableMany2(self,data):
        dataid=str(uuid.uuid1()).lstrip("{").rstrip("}").replace("-","")
        directive=['tablefill2',self.getAddName()+self.name,dataid,self.type]
        self.storedata(dataid,data)
        self.passDirective(directive)

    def clearTable(self):
        directive=['tableclear',self.getAddName()+self.name,'',self.type]
        self.passDirective(directive)
        
    def initTable(self):
        directive=['tableinit',self.getAddName()+self.name,'',self.type]
        self.passDirective(directive)

    def setTableDelegate(self,column,atype,colData=[],callDef="",params=[]):
        if not type(callDef) is str:callDef=callDef.__name__
        directive=['settabledelegate',self.getAddName()+self.name,self.type,column,atype,colData,self.parent.currentModName,callDef,params]
        self.passDirective(directive)
        
    def resetTableDelegates(self):
        directive=['resettabledelegates',self.getAddName()+self.name,self.type,self.parent.currentModName]
        self.passDirective(directive)

    def setTableColumnIcon(self,column,resource,iconfile):
        directive=['settablecolumnicon',self.getAddName()+self.name,self.type,column,resource,iconfile]
        self.passDirective(directive)

    def setHideIcon(self,row,column,abool=True):
        directive=['sethideicon',self.getAddName()+self.name,self.type,row,column,abool]
        self.passDirective(directive)

    def setSortingEnabled(self,abool):
        directive=['setsortingenabled',self.getAddName()+self.name,self.type,abool]
        self.passDirective(directive)

    def setTableColumnEditable(self,column):
        directive=['settablecolumneditable',self.getAddName()+self.name,self.type,column]
        self.passDirective(directive)
        
    def setTableCellDisabled(self,row,column):
        directive=['settablecelldisabled',self.getAddName()+self.name,self.type,row,column]
        self.passDirective(directive)
        
    def setWordWrap(self,abool):
        directive=['setwordwrap',self.getAddName()+self.name,self.type,abool]
        self.passDirective(directive)

    def setTableCellValue(self,rowKey,column,value):
        if type(value) is str:
            pass
        elif type(value) is int or type(value) is float:
            pass
        else:
            value = json.dumps(value)
        directive=['settablecellvalue',self.getAddName()+self.name,self.type,rowKey,column,value]
        self.passDirective(directive)

    def setTableRowKey(self,rowKey,newKey):
        directive=['settablerowkey',self.getAddName()+self.name,self.type,rowKey,newKey]
        self.passDirective(directive)

    def setTableCellType(self,rowKey,column,atype,startval=""):
        directive=['settablecelltype',self.getAddName()+self.name,self.type,rowKey,column,atype,startval]
        self.passDirective(directive)

    def setTableCellEnabled(self,row,column):
        directive=['settablecellenabled',self.getAddName()+self.name,self.type,row,column]
        self.passDirective(directive)

    def setCellContents(self,row,column,data):
        directive=['setcellcontents',self.getAddName()+self.name,self.type,row,column,data]
        self.passDirective(directive)

    def setSelectRows(self):
        directive=['setselectrows',self.getAddName()+self.name,self.type]
        self.passDirective(directive)

    def setSelectCells(self):
        directive=['setselectcells',self.getAddName()+self.name,self.type]
        self.passDirective(directive)

    def setTableBGColorRule(self,keyItem,equalTo,color,columns,priority=0):
        directive=['settablebgcolorrule',self.getAddName()+self.name,keyItem,equalTo,color,columns,priority]
        self.passDirective(directive)

    def setTableNSRule(self,keyItem,equalTo,exceptionList=[]):
        directive=['settablensrule',self.getAddName()+self.name,keyItem,equalTo,exceptionList]
        self.passDirective(directive)

    def setTableFGColorRule(self,keyItem,equalTo,color,columns,priority=0):
        directive=['settablefgcolorrule',self.getAddName()+self.name,keyItem,equalTo,color,columns,priority]
        self.passDirective(directive)

    #hide a column in a table
    def hideColumns(self,colList):
        directive=['hidecolumns',self.getAddName()+self.name,colList]
        self.passDirective(directive)

    def hide(self,widgetname=""):
        if not self.name+"hse" in self.parent.__dict__:
            directive=['hide',self.getAddName()+self.name,"",self.type,widgetname]
        else:
            directive=['hide',self.getAddName()+self.parent.__dict__[self.name+'hse'],"","HTMLELEMENT",widgetname]
        self.passDirective(directive)

    #hide a grid header
    def hideHeader(self):
        directive=['hideheader',self.getAddName()+self.name]
        self.passDirective(directive)

    def hideAll(self):
        directive=['hideall',self.getAddName()+self.name,self.type]
        self.passDirective(directive)

    def write(self,data):
        directive=['write',self.getAddName()+self.name,self.type,data]
        self.passDirective(directive)

    def writeToSocket(self,data):
        directive=['writetosocket',self.getAddName()+self.name,self.type,data]
        self.passDirective(directive)

    def readFromSocket(self):
        directive=['readfromsocket',self.getAddName()+self.name,self.parent.spoolID,self.type]+['blockingCall']
        self.value = self.passDirective(directive)
        return self.value

    #add a python code editor screen to the current widget
    def addFormattedEdit(self,filename,onChangeActionDef="",onSelectChangeActionDef="",onMarginClickActionDef="",codeType="PYTHON"):
        if type(onChangeActionDef) != str:onChangeActionDef=onChangeActionDef.__name__
        if type(onSelectChangeActionDef) != str:onSelectChangeActionDef=onSelectChangeActionDef.__name__
        if type(onMarginClickActionDef) != str:onMarginClickActionDef=onMarginClickActionDef.__name__
        data=open(self.parent.cache.realpath+filename,"r").read()
        import base64
        data = base64.b64encode(data)
        directive=['addpythoncodeedit',self.getAddName()+self.name,self.parent.spoolID,self.type,filename,data,onChangeActionDef,self.parent.currentModName,onSelectChangeActionDef,codeType,onMarginClickActionDef]
        self.passDirective(directive)

    def addFormattedWebEdit(self,widgetname,filename,onChangeActionDef="",onSelectChangeActionDef="",onMarginClickActionDef="",codeType="PYTHON",filedata=""):
        if type(onChangeActionDef) != str:onChangeActionDef=onChangeActionDef.__name__
        if type(onSelectChangeActionDef) != str:onSelectChangeActionDef=onSelectChangeActionDef.__name__
        if type(onMarginClickActionDef) != str:onMarginClickActionDef=onMarginClickActionDef.__name__
        #sender = self.getSender()
        if filedata=="":
            data=open(self.parent.cache.realpath+filename,"r").read()
        else:
            data=filedata
        import base64
        data = base64.b64encode(data)
        directive=['addpythoncodeedit',self.getAddName()+self.name,self.parent.spoolID,self.type,filename,data,onChangeActionDef,self.parent.currentModName,onSelectChangeActionDef,codeType,onMarginClickActionDef,widgetname]
        self.passDirective(directive,widgetname,"CODEEDIT")

    def disconnectListener(self):
        directive=['disconnectlistener',self.getAddName()+self.name,self.parent.spoolID,self.type]
        self.passDirective(directive)

    def reconnectListener(self,index=-1):
        directive=['reconnectlistener',self.getAddName()+self.name,self.parent.spoolID,self.type,index]
        self.passDirective(directive)

    #add a balloon to a widget
    def showBalloon(self,text):
        directive=['showballoon',self.getAddName()+self.name,self.parent.spoolID,self.type,text]
        self.passDirective(directive)

    #raise widget
    def raiseWidget(self):
        directive=['raise',self.getAddName()+self.name,self.parent.spoolID,self.type]
        self.passDirective(directive)

    def exportXLS(self):
        directive=['exportxls',self.getAddName()+self.name,self.parent.spoolID,self.type]
        self.passDirective(directive)

    def exportPDF(self):
        directive=['exportpdf',self.getAddName()+self.name,self.parent.spoolID,self.type]
        self.passDirective(directive)
    

    #get a value from the current widget
    def getVal(self,valtype="",extra="",wait=10000):
        self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
        self.parent.cache.set(self.parent.spoolID+"receiveloading",None)
        directive=['getvalue',self.getAddName()+self.name,self.parent.spoolID,self.type,valtype,extra]+['blockingCall']
        self.value = self.passDirective(directive)
        return self.value

    def setAsTime(self,timeFormat="%H:%i"):
        directive=['setastime',self.getAddName()+self.name,self.parent.spoolID,self.type,timeFormat]
        self.passDirective(directive)
        
    def getTableData(self):
        self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
        directive=['gettabledata',self.getAddName()+self.name,self.parent.spoolID,self.type]+['blockingCall']
        self.value = self.passDirective(directive)
        return self.value

    def getSelectedKey(self):
        self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
        directive=['getselectedkey',self.getAddName()+self.name,self.parent.spoolID,self.type]+['blockingCall']
        self.value = self.passDirective(directive)
        return self.value
        
    def getTableHeaderInfo(self):
        self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
        directive=['gettableheaderinfo',self.getAddName()+self.name,self.parent.spoolID,self.type]+['blockingCall']
        self.value = self.passDirective(directive)
        return self.value

    def setRowHeight(self,theheight):
        directive=['setrowheight',self.getAddName()+self.name,self.type,theheight]
        self.passDirective(directive)
        
    def setRowHeightToContents(self):
        directive=['setrowheighttocontents',self.getAddName()+self.name,self.type]
        self.passDirective(directive)

    def setColumnWidgetRules(self,tableColumn,*args):
        sendList=[]
        for data in args:
            sendList.append(data.getRuleData())
        directive=['setcolumnwidgetrules',self.getAddName()+self.name,self.type,tableColumn, sendList]
        self.passDirective(directive)

    def setColumnWidth(self,thecolumn,thewidth):
        directive=['setcolumnwidth',self.getAddName()+self.name,self.type,thecolumn,thewidth]
        self.passDirective(directive)

    def setColumnsResizeable(self,thecolumn):
        directive=['setcolumnsresizeable',self.getAddName()+self.name,self.type,thecolumn]
        self.passDirective(directive)

    def getCodeFileLock(self):
        self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
        directive=['getcodefilelock',self.getAddName()+self.name,self.parent.spoolID,self.type]+['blockingCall']
        self.value = self.passDirective(directive)
        return self.value
    
    def setMask(self,mask):
        self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
        directive=['setmask',self.getAddName()+self.name,self.parent.spoolID,self.type,mask]
        self.passDirective(directive)

    #get a value from a widget after validating its contents to match what you want
    #the content type to be
    def getValidate(self,TypeConst,Required=False,valtype=""):
        self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
        directive=['getvalue',self.getAddName()+self.name,self.parent.spoolID,self.type,valtype,TypeConst,Required]+['blockingCall']
        self.value = self.passDirective(directive)
        return self.value

    #get the index from the current widget
    def getIndex(self):
        self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
        directive=['getindex',self.getAddName()+self.name,self.parent.spoolID,self.type]+['blockingCall']
        self.value = self.passDirective(directive)
        return self.value
        
    def getIndexCount(self):
        self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
        directive=['getindexcount',self.getAddName()+self.name,self.parent.spoolID,self.type]+['blockingCall']
        self.value = self.passDirective(directive)
        return self.value
        
    #set the value of the current widget
    def setVal(self,text,immediate=True,valType=""):
        if self.type=="CODEEDIT":
            import base64
            text = base64.b64encode(text)
        else:
            text = str(text)
        self.value = text
        directive=['setvalue',self.getAddName()+self.name,str(self.parent.spoolID),self.type,text,valType]
        self.passDirective(directive)

    def initWidget(self):
        #subclass me
        pass

    def initParams(self,keyargs):
        for akey,avalue in keyargs.items():
            setattr(self,akey,avalue)

    def dialogBox(self, windowname, title, widgetLib, width, height, maximize=False, returnCallback=None, *args,**kwargs):
        if not returnCallback is None and not type(returnCallback) is str:
            returnCallback = returnCallback.__name__ 
        self.parent.globalDict[windowname] = {"caller":self.name,"returnCallback":returnCallback}
        self.parent.dhxWins.createWindow(windowname,width,height,"ajax","doDialogScreen",title,True,maximize,None,widgetLib,*args,**kwargs)
        
   
    def createWindow(self,windowname,width,height,datatype,data,title,modal,maximize=False,windowParent=None,widgetLib="",*args,**kwargs):
        self.parent.startAPICall()
        self.parent.tracelog.write("CREATING WINDOW for lib "+widgetLib)
        if windowParent==None:
            self.parent.addressWidget(windowname,"DIALOG",None,widgetLib)
            awidget = self.parent.__dict__[windowname]
            wpaddname = ""
        else:
            #this only runs if i'm creating a dialog inside a dialog by giving a windowParent
            if self.parent.name==windowParent.name:
                self.parent.addressWidget(windowname,"DIALOG")
                awidget = self.parent.__dict__[windowname]
                wpaddname = self.getAddName() + windowParent.name
            else:
                self.parent.__dict__[windowParent.name].addressWidget(windowname,"DIALOG")
                awidget = self.parent.__dict__[windowParent.name].__dict__[windowname]
                wpaddname = windowParent.getAddName() +  windowParent.name
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['createwindow',self.getAddName()+self.name,self.parent.spoolID,self.type,windowname,width,height,datatype,data,modal,title,maximize,wpaddname]+['blockingCall']
        currdata = self.passDirective(directive)
        if widgetLib!="":
            awidget.widgetLib = widgetLib
            awidget.initParams(kwargs) 
            awidget.initWidget()
            awidget.addSignal(awidget,      "onClose",       awidget.close)
        else:
            awidget.parent.addClientSignal(awidget,      "onClose",       awidget.close)
        if currdata!="":
            try:
                adict = json.loads(currdata)
            except Exception as e:
                self.parent.tracelog.write(str(e)+str(currdata))
                adict = {}
            for key,value in adict.items():
                if key!="widgettype":
                    if not awidget is None:
                        awidget.addressWidget(key,value)
                    else:
                        self.addressWidget(key,value)
        else:
            adict = {}
        return adict
 
    def setActionGlobal(self,text,immediate=False):
        directive=['setactionglobal',self.getAddName()+self.name,self.parent.spoolID,self.type]
        self.passDirective(directive)
    
    #set the value of the current widget
    def setURL(self,text,calldef=""):
        if not type(calldef) is str:calldef=calldef.__name__
        directive=['seturl',self.getAddName()+self.name,self.parent.spoolID,self.type,text,calldef]+["blockingCall"]
        self.value = self.passDirective(directive)
        return self.value

    #set the value of the current widget
    def setAJAX(self,function):
        awidget = self.parent.__dict__[self.name]
        wpaddname=""
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setajax',self.getAddName()+self.name,self.parent.spoolID,self.type,function,wpaddname]+['blockingCall']
        self.value=function
        currdata = self.passDirective(directive)
        if currdata!="":
            try:
                adict = json.loads(currdata)
            except:
                adict = {}
            for key,value in adict.items():
                if key!="widgettype":
                    if not awidget is None:
                        awidget.addressWidget(key,value)
                    else:
                        self.addressWidget(key,value)
        else:
            adict = {}

        return adict

    #set the value of the current widget
    def addAlliance(self,sellerid,buyerid,partnerid,vinnumber,catalogid,indexid,indexcount):
        directive=['addalliance',self.getAddName()+self.name,self.parent.spoolID,self.type,sellerid,buyerid,partnerid,vinnumber,catalogid,indexid,str(indexcount)]+['blockingCall']
        self.value = self.passDirective(directive)
        return self.value

    def addStackedWidget(self,widgetName,indexQty,activeIndex=0,cell=""):
        immediate=True
        for d in range(0,indexQty):
            self.doAddAddress(widgetName+str(d),"LAYOUT")
            self.doAddAddress(widgetName+"Div"+str(d),"HTMLELEMENT")
            self.parent.__dict__[widgetName+str(d)+"hse"] = widgetName+"Div"+str(d)  #internally used only during hide / show
        self.doAddAddress(widgetName,"STACKEDWIDGET")
        directive=['addstackedwidget',self.getAddName()+self.name,self.parent.spoolID,self.type,indexQty,activeIndex,widgetName,cell]
        self.passDirective(directive,widgetName,"STACKEDWIDGET",False)
             
    def checkAvailabilityAlliance(self):
        directive=['checkavailabilityalliance',self.getAddName()+self.name,"",self.parent.spoolID]+['blockingCall']
        self.value = self.passDirective(directive)
        return self.value

    def placeOrderAlliance(self,deliveryMethod,orderMessage,purchaseOrderNumber):
        directive=['placeorderalliance',self.getAddName()+self.name,"",self.parent.spoolID,deliveryMethod,orderMessage,purchaseOrderNumber]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.value = self.passDirective(directive)
        return self.value
 
    #set the value of the current widget
    def setCursorPosition(self,line,index,immediate=False):
        directive=['setcursorposition',self.getAddName()+self.name,self.parent.spoolID,self.type,line,index]
        self.passDirective(directive)

    def setFocusCallback(self,InOrOut,theDef):
        if not type(theDef) is str:theDef=theDef.__name__
        InOrOut=InOrOut.upper()
        directive=['focuseventcall',self.getAddName()+self.name,self.parent.spoolID,self.type,InOrOut,self.parent.currentModName,theDef]
        self.passDirective(directive)
        
    def delegateFocusEventCallback(self,InOrOut,theDef):
        if not type(theDef) is str:theDef=theDef.__name__
        InOrOut=InOrOut.upper()
        directive=['delegatefocuseventcall',self.getAddName()+self.name,self.parent.spoolID,self.type,InOrOut,self.parent.currentModName,theDef]
        self.passDirective(directive)

    def annotateLine(self):
        directive=['annotateline',self.getAddName()+self.name,self.parent.spoolID,self.type]
        self.passDirective(directive)

    def append(self,text,immediate=True):
        directive=['append',self.getAddName()+self.name,self.parent.spoolID,self.type,text]
        self.passDirective(directive)

    def setLength(self,text):
        directive=['setlength',self.getAddName()+self.name,self.parent.spoolID,self.type,text]
        self.passDirective(directive)
    
    #set the current widget to a client side global
    def setToGlobal(self,text):
        directive=['settoglobal',self.getAddName()+self.name,self.parent.spoolID,self.type,text]
        self.passDirective(directive)

    def putToGlobal(self,text):
        directive=['puttoglobal',self.getAddName()+self.name,self.parent.spoolID,self.type,text]
        self.passDirective(directive)

    #set the current widget to a specific index
    def setIndex(self,index,widgetname=""):
        directive=['setindex',self.getAddName()+self.name,self.parent.spoolID,self.type,index,widgetname]
        self.passDirective(directive)

    def closeCurrentEdit(self):
        directive=['closeedit',self.getAddName()+self.name,self.parent.spoolID,self.type]
        self.passDirective(directive)

    def removeTab(self,whichtab):
        directive=['removetab',self.getAddName()+self.name,self.parent.spoolID,self.type,whichtab]
        self.passDirective(directive)

    def cut(self):
        directive=['cut',self.getAddName()+self.name,self.parent.spoolID,self.type]
        self.passDirective(directive)

    def showFind(self):
        directive=['showfind',self.getAddName()+self.name,self.parent.spoolID,self.type]
        self.passDirective(directive)
        
    def copy(self):
        directive=['copy',self.getAddName()+self.name,self.parent.spoolID,self.type]
        self.passDirective(directive)
        
    def paste(self):
        directive=['paste',self.getAddName()+self.name,self.parent.spoolID,self.type]
        self.passDirective(directive)

    def undo(self,keyOnText=""):
        directive=['undo',self.getAddName()+self.name,self.parent.spoolID,self.type,keyOnText]
        self.passDirective(directive)

    def redo(self,keyOnText=""):
        directive=['redo',self.getAddName()+self.name,self.parent.spoolID,self.type,keyOnText]
        self.passDirective(directive)
  
    def insert(self,thetext):
        directive=['insert',self.getAddName()+self.name,self.parent.spoolID,self.type,thetext]
        self.passDirective(directive)

    def setTabChanged(self,index):
        directive=['settabchanged',self.getAddName()+self.name,index]
        self.passDirective(directive)
        
    def setTabText(self,thetext):
        directive=['settabtext',self.getAddName()+self.name,'',self.type,thetext]
        self.passDirective(directive)

    def tabCloseHook(self,calldef,retGlobal):
        directive=['tabclosehook',self.getAddName()+self.name,"",calldef.__name__,retGlobal]
        self.passDirective(directive)

    def replace(self,text,findLineEdit):
        if type(findLineEdit) != str:findLineEdit=findLineEdit.name
        directive=['replace',self.getAddName()+self.name,self.parent.spoolID,self.type,text,findLineEdit]
        self.passDirective(directive)
    
    def setCompleterData(self,dataList):
        directive=['setcompleterdata',self.getAddName()+self.name,self.parent.spoolID,self.type,dataList]
        self.passDirective(directive)
    
    def findFirst(self,text):
        directive=['findfirst',self.getAddName()+self.name,self.parent.spoolID,self.type,text]
        self.passDirective(directive)
        
    def updateText(self,text):
        directive=['updatetext',self.getAddName()+self.name,self.parent.spoolID,self.type,text]
        self.passDirective(directive)
    
    def findNext(self):
        directive=['findnext',self.getAddName()+self.name,self.parent.spoolID,self.type]
        self.passDirective(directive)
    
    def setTabSaved(self,index):
        directive=['settabsaved',self.getAddName()+self.name,index]
        self.passDirective(directive)

    def setTabUnlocked(self,index,switch=True):
        directive=['settabunlocked',self.getAddName()+self.name,index,switch]
        self.passDirective(directive)

    def setAllSaved(self):
        directive=['setallsaved',self.getAddName()+self.name]
        self.passDirective(directive)
    
    def getTabChanged(self,index):
        directive=['gettabchanged',self.getAddName()+self.name,index,self.parent.spoolID]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.value = self.passDirective(directive)
        return self.value

    def getAllUnsaved(self):
        directive=['getallunsaved',self.getAddName()+self.name,self.parent.spoolID]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.value = self.passDirective(directive)
        return self.value

    #bump the index of the current widget by X amount
    def moveIndex(self,index):
        directive=['moveindex',self.getAddName()+self.name,self.parent.spoolID,self.type,index]
        self.passDirective(directive)
        
    #clear the focus from the current widget to the main widget
    def clearFocus(self):
        directive=['clearfocus',self.getAddName()+self.name,self.parent.spoolID,self.type]
        self.passDirective(directive)
        
    #set the focus to the current widget
    def setFocus(self,widget=""):
        if type(widget) != str:widget=widget.name
        directive=['setfocus',self.getAddName()+self.name,self.parent.spoolID,self.type,widget]
        self.passDirective(directive)

    #internal function used to get the md5 hash value of a local file
    def md5_for_local_file(self,afile):
        self.parent.startAPICall()
        afile=open(afile,"r")
        block_size=2**20
        md5 = hashlib.md5()
        while True:
            data = afile.read(block_size)
            if not data:
                break
            md5.update(data)
        self.parent.stopAPICall()
        return md5.digest()

    def runCallback(self,*args):
        callingWidgetName = self.parent.globalDict[self.name]["caller"]
        returnCallback    = self.parent.globalDict[self.name]["returnCallback"]
        returnFunc = getattr(self.parent.__dict__[callingWidgetName],returnCallback)
        returnFunc(*args)
        self.close()

    #internal function used to get the md5 hash value of a remote file
    def md5_for_remote_file(self,afile):
        self.parent.startAPICall()
        self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['getmd5',self.getAddName()+self.name,self.parent.spoolID,self.type,afile]+['blockingCall']
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        acnt=0
        while True:
            currdata=self.parent.cache.get(self.parent.spoolID+"receive"+self.threadID)
            acnt+=1
            time.sleep(.01)
            if acnt==self.parent.acnt:break
            if currdata!=[]:
               self.parent.cache.delete(self.parent.spoolID+"receive"+self.threadID)
               break
        self.parent.stopAPICall()
        return currdata
        
    #send a file from the server to the client 
    def sendFile(self,afile):
        dataid=str(uuid.uuid1()).lstrip("{").rstrip("}").replace("-","")
        totalBytes = os.path.getsize(afile)
        data = open(afile,'rb').read(totalBytes)
        directive=['sendfile',self.getAddName()+self.name,dataid,afile]
        self.storedata(dataid,data)
        self.passDirective(directive)

    #set the image pixmap of the current widget
    def setPixMap(self,imageFile,stretch=True):
        self.parent.startAPICall()
        localMD5  = self.md5_for_local_file("images"+sep+imageFile)
        remoteMD5 = self.md5_for_remote_file("images"+sep+imageFile)
        if localMD5!=remoteMD5:
            self.sendFile("images"+sep+imageFile)
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        directive=['setpixmap',self.getAddName()+self.name,self.parent.spoolID,self.type,"images"+sep+imageFile]
        self.parent.cache.append(self.parent.spoolID+"send"+self.threadID,directive)
        self.parent.stopAPICall()

    #set the image icon of the current widget
    def setIcon(self,resource,iconfile):
        directive=['seticon',self.getAddName()+self.name,self.parent.spoolID,self.type,resource,iconfile]
        self.passDirective(directive)

    #set the context menu allowed columns
    def setContextMenuColumns(self,columnList):
        if not type(columnList) is list:columnList=[columnList]
        directive=['setcontextmenucolumns',self.getAddName()+self.name,columnList,"",self.parent.spoolID,self.type]
        self.passDirective(directive)
        
    def disableDragDropColumns(self,columnList):
        if not type(columnList) is list:columnList=[columnList]
        directive=['disabledragdropcolumns',self.getAddName()+self.name,columnList,"",self.parent.spoolID,self.type]
        self.passDirective(directive)

    def addHideRowRange(self,rangeStart,rangeEnd):
        rowRange = range(rangeStart,rangeEnd)
        directive=['addhiderowrange',self.getAddName()+self.name,rowRange,"",self.parent.spoolID,self.type]
        self.passDirective(directive)
        
    #add a menu stretch to the current toolbar
    def addStretch(self):
        directive=['addstretch',self.getAddName()+self.name,"",self.parent.spoolID,self.type]
        self.passDirective(directive)

    def doAddAddress(self,widget,widgetType):
        if self.type=="DIALOG":
            self.addressWidget(widget,widgetType)
        elif self.getAddType()=="DIALOG.":
            self.parentWidget.addressWidget(widget,widgetType,True)
        else:
            self.parent.addressWidget(widget,widgetType)

    #add a menu stretch to the current toolbar
    def addLayout(self,layoutWidget,pattern,cell="a"):
        if type(layoutWidget) != str:layoutWidget = layoutWidget.name
        directive=['addlayout',self.getAddName()+self.name,layoutWidget,self.type,cell,pattern]
        self.passDirective(directive,layoutWidget,"LAYOUT",False)

    def getItemNames(self,item):
        retItems = []
        try:
            pmod = self.parent.parent.parent.__dict__[self.parent.spoolID+"sessinfo"]["parentmod"]
        except:
            pmod = ""
        if not type(item) is list:item=[item]
        for anitem in item:
            if "value" in anitem:
                anitem['value'] = anitem['value'].replace("'","q|q")
            if "bindname" in anitem:
                try:
                    self.binding[anitem["bindname"][0]]=[anitem["name"],anitem["type"],anitem["bindname"]]
                except Exception as e:
                    print("could not bind",anitem,e)
            if anitem["type"]=="combo":
                self.doAddAddress(anitem["name"],"COMBOBOX")
            elif anitem["type"]=="input":
                self.doAddAddress(anitem["name"],"TEXTBOX") 
            elif anitem["type"]=="radio":
                self.doAddAddress(anitem["name"],"RADIOBUTTON")
            elif anitem["type"]=="password":
                self.doAddAddress(anitem["name"],"TEXTBOX")
            elif anitem["type"]=="calendar":
                self.doAddAddress(anitem["name"],"CALENDAR")
            elif anitem["type"]=="button":
                if "image" in anitem:
                    anitem["value"]="<img style=display:inline-block;vertical-align:bottom;margin-right:3px;margin-bottom:2px src=paceicon/blue/"+anitem["image"]+" height=18 width=18>"+anitem["value"]
                self.doAddAddress(anitem["name"],"HTMLELEMENT")
            elif anitem["type"]=="container":
                self.doAddAddress(anitem["name"],"CONTAINER")
            elif anitem["type"]=="checkbox":
                self.doAddAddress(anitem["name"],"CHECKBOX")
            if pmod!="" and "name" in anitem:
                anitem['tooltip']=anitem['name']
            retItems.append(anitem)
        if len(retItems)==1:retItems=retItems[0]
        return retItems

    def addForm(self,formWidget,formdata,cell="a"):
        self.parent.startAPICall()
        if type(formWidget) != str:formWidget = formWidget.name
        retformdata = []
        for item in formdata:
            if "type" in item:
                #if item["type"]=="block" or item["type"]=="radio":
                if "list" in item:
                    item['list']=self.getItemNames(item['list'])
                item=self.getItemNames(item)
            retformdata.append(item)
        directive=['addform',self.getAddName()+self.name,formWidget,self.type,cell,retformdata]
        self.passDirective(directive,formWidget,"FORM",False)
        try:
            self.parentWidget.__dict__[formWidget].binding = self.binding
        except:
            pass

    def bind(self,data):
        self.clearItems()
        for abind,widgetinfo in self.binding.items():
            if abind in data:
                convtype=str
                if len(widgetinfo[2])>1:
                    if widgetinfo[2][1]=="julian":convtype=self.fromJulian
                self.parentWidget.__dict__[widgetinfo[0]].setVal(convtype(data[abind]))

    def bindGet(self):
        retdict = {}
        for abind,widgetinfo in self.binding.items():
            if abind!="" and widgetinfo[0] in self.parentWidget.__dict__:
                convtype=str
                if len(widgetinfo[2])>1:
                    if widgetinfo[2][1]=="int":convtype=int
                    elif widgetinfo[2][1]=="float":convtype=float
                    elif widgetinfo[2][1]=="julian":convtype=self.toJulian
                try:
                    self.parentWidget.__dict__[widgetinfo[0]].value = convtype(self.parentWidget.__dict__[widgetinfo[0]].value)
                    retdict[abind]= convtype(self.parentWidget.__dict__[widgetinfo[0]].value)
                except:
                    retdict[abind]= self.parentWidget.__dict__[widgetinfo[0]].value
        return retdict

    def hasWidget(self,widgetname):
        for abind,widgetinfo in self.binding.items():
            if widgetname==widgetinfo[0]:
                return True
        return False

    def wrapSave(self,dataValues,gridWidget,dbTableName,recordID,saveCallbackFunction):
        changeDict = DictChanges(dataValues,gridWidget.lastdata[str(recordID)]).changed()
        dat =self.parent.db[dbTableName].find_one({"_id":ObjectId(recordID)})
        globalChanges = DictChanges(dat,gridWidget.lastdata[str(recordID)]).changed()
        if globalChanges!={}:
            oChanges = DictChanges(globalChanges,changeDict).changed()
            if oChanges!={}:
                scb = saveCallbackFunction.__name__
                self.parent.changeWindowData=[oChanges,changeDict,self.name,scb]
                self.parent.dhxWins.createWindow("changesWindow",500,400,"ajax","doDialogScreen","Database Updates",True,False,None,"CHANGES")
                return
        saveCallbackFunction("save",changeDict)

    def startSpinner(self):
        directive=['startspinner',self.getAddName()+self.name]
        self.passDirective(directive)

    def stopSpinner(self):
        directive=['stopspinner',self.getAddName()+self.name]
        self.passDirective(directive)

    def addCalendar(self,calWidget,cell="a"):
        if type(calWidget) != str:calWidget = calWidget.name
        directive=['addcalendar',self.getAddName()+self.name,calWidget,self.type,cell]
        self.passDirective(directive,calWidget,"CALENDAR",False)

    def addScheduler(self,calWidget,sections,units,datestart,cell="a"):
        if type(calWidget) != str:calWidget = calWidget.name
        addhtml = ""
        px = 10
        for item in units:
            addhtml+='<div class="dhx_cal_tab" name="'+item["name"]+'_tab" style="right:'+str(px)+'px"></div>\n'
            px+=70
        schedHTML = """<div id="scheduler_here" class="dhx_cal_container" style="width:100pct; height:100pct;">
            <div class="dhx_cal_navline">
                <div class="dhx_cal_prev_button">&nbsp;</div>
                <div class="dhx_cal_next_button">&nbsp;</div>
                <div class="dhx_cal_today_button"></div>
                <div class="dhx_cal_date" style="align:right" ></div>
                %(addhtml)s             
            </div>
            <div class="dhx_cal_header"></div>
            <div class="dhx_cal_data"></div>
        </div>
        """ % {"addhtml":addhtml}
        schedHTML = schedHTML.replace("pct","%")
        directive=['addscheduler',self.getAddName()+self.name,calWidget,self.type,cell,sections,units,datestart,schedHTML]
        self.passDirective(directive,calWidget,"SCHEDULER",False)

    def highlightHour(self,hrtext,uid):
        directive=['highlighthour',self.getAddName()+self.name,hrtext,uid]
        self.passDirective(directive)

    def addTabBar(self,tabWidget,cell="a"):
        if type(tabWidget) != str:tabWidget = tabWidget.name
        directive=['addtabbar',self.getAddName()+self.name,tabWidget,self.type,cell]
        self.passDirective(directive,tabWidget,"TABSHEET",False)

    def addTimeBox(self,htmlWidgetName,cell="a"):
        directive=['addtimebox',self.getAddName()+self.name,htmlWidgetName,self.type,cell]
        self.passDirective(directive)

    def addHTML(self,htmlString,cell="a"):
        directive=['addhtml',self.getAddName()+self.name,htmlString,self.type,cell]
        self.passDirective(directive)

    def addGridLayout(self,layoutWidget,rows,columns,cell="a"):
        if type(layoutWidget) != str:layoutWidget = layoutWidget.name
        directive=['addgridlayout',self.getAddName()+self.name,layoutWidget,self.type,cell,rows,columns]
        self.passDirective(directive,layoutWidget,"GRIDLAYOUT",False)

    def addToolbar(self,toolBarWidget,iconsize=32,alignment="left",layoutcell="a"):
        if type(toolBarWidget) != str:toolBarWidget = toolBarWidget.name
        directive=['addtoolbar',self.getAddName()+self.name,toolBarWidget,self.type,iconsize,alignment,layoutcell]
        self.passDirective(directive,toolBarWidget,"TOOLBAR",False)

    def addUploader(self,uploaderWidget,layoutcell="a"):
        if type(uploaderWidget) != str:uploaderWidget = uploaderWidget.name
        directive=['adduploader',self.getAddName()+self.name,uploaderWidget,self.type,layoutcell]
        self.passDirective(directive,uploaderWidget,"TOOLBAR",False)

    def click(self):
        directive=['click',self.getAddName()+self.name,"",self.type]
        self.passDirective(directive)

    def addMenu(self,menuWidget,layoutcell="a"):
        if type(menuWidget) != str:menuWidget = menuWidget.name
        directive=['addmenu',self.getAddName()+self.name,menuWidget,self.type,layoutcell]
        self.passDirective(directive,menuWidget,"MENU",False)

    def addButton(self,buttonName,buttonText,icon,isDropdown=False,buttonParent=""):
        directive=['addbutton',self.getAddName()+self.name,buttonName,self.type,buttonText,icon,isDropdown,buttonParent]
        self.passDirective(directive)

    def addInput(self,inputName,inputValue,inputWidth,readOnly=False,style=""):
        directive=['addinput',self.getAddName()+self.name,inputName,self.type,inputValue,inputWidth,readOnly,style]
        self.passDirective(directive,inputName,"TEXTBOX",False)
   
    def addText(self,text,fontsize=""):
        directive=['addtext',self.getAddName()+self.name,"",self.type,text,fontsize]
        self.passDirective(directive)

    def addMenuItem(self,itemParent,itemName,itemText,icon,isDropdown=False):
        directive=['addmenuitem',self.getAddName()+self.name,itemParent,self.type,itemName,itemText,icon]
        self.passDirective(directive)
        
    #add a menu seperator to the current toolbar
    def addSeperator(self,sepID):
        directive=['addseperator',self.getAddName()+self.name,self.parent.spoolID,self.type,sepID]
        self.passDirective(directive)

    #set the subframe to use in a web widget
    def setSubFrameTitle(self,theTitle):
        directive=['setsubframetitle',self.getAddName()+self.name,theTitle,"",self.parent.spoolID,self.type]
        self.passDirective(directive)
        
    def addTrayMenu(self,actionWidget,icon):
        if type(actionWidget) != str:actionWidget=actionWidget.__name__
        directive=['addtraymenu',actionWidget,icon,self.parent.spoolID,addname]
        self.passDirective(directive,actionWidget,"ACTION")

    def addGridTab(self,tabText,gridWidgetName,tabWidgetName,makeActive=False):
        directive=['addgridtab',self.getAddName()+self.name,tabText,gridWidgetName,tabWidgetName,makeActive,self.type,False]
        self.doAddAddress(gridWidgetName,"TABLE")
        self.passDirective(directive,tabWidgetName,"TAB",False)

    def addEditor(self,editorWidgetName):
        directive=['addeditor',self.getAddName()+self.name,editorWidgetName,'','','',self.type]
        self.passDirective(directive,editorWidgetName,"EDITOR",False)

    def addGrid(self,gridWidgetName,layoutCell="a"):
        directive=['addgridtab',self.getAddName()+self.name,"",gridWidgetName,layoutCell,False,self.type,False]
        self.passDirective(directive,gridWidgetName,"TABLE",False)

    def addTree(self,gridWidgetName,layoutCell="a"):
        directive=['addgridtab',self.getAddName()+self.name,"",gridWidgetName,layoutCell,False,self.type,True]
        self.passDirective(directive,gridWidgetName,"TREE",False)
    
    def startRecord(self):
        directive=['startrecord',self.getAddName()+self.name]
        self.passDirective(directive)
    
    #add a tab to the current widget
    def addTab(self,tabText,widgetName=""):
        directive=['addtab',self.getAddName()+self.name,tabText,widgetName]
        self.passDirective(directive,widgetName,"WIDGET",False)
    
    #add an item to the current widget (ex: combobox)
    def addItem(self,itemText):
        directive=['additem',self.getAddName()+self.name,self.parent.spoolID,self.type,itemText]
        self.passDirective(directive)
    
    #add multiple items to the current widget
    def addItems(self,itemList):
        directive=['additems',self.getAddName()+self.name,self.parent.spoolID,self.type,json.dumps(itemList)]
        self.passDirective(directive)

    def openSelect(self):
        directive=['openselect',self.getAddName()+self.name,self.parent.spoolID,self.type]
        self.passDirective(directive)

    def addGridComboItems(self,itemList,key,index):
        directive=['addgridcomboitems',self.getAddName()+self.name,self.parent.spoolID,self.type,itemList,key,index]
        self.passDirective(directive)

    def setColumnComboItems(self,itemList,index):
        directive=['setcolumncomboitems',self.getAddName()+self.name,self.parent.spoolID,self.type,itemList,index]
        self.passDirective(directive)
        
    def clearItems(self):
        directive=['clearitems',self.getAddName()+self.name,self.parent.spoolID,self.type]
        self.passDirective(directive)

    def progressOn(self):
        directive=['progresson',self.getAddName()+self.name,self.parent.spoolID,self.type]
        self.passDirective(directive)
        self.parent.flushBuffer()

    def progressOff(self):
        directive=['progressoff',self.getAddName()+self.name,self.parent.spoolID,self.type]
        self.passDirective(directive)
        
    def clearDelegates(self):
        directive=['cleardelegates',self.getAddName()+self.name,self.parent.spoolID,self.type]
        self.passDirective(directive)
        
    #set the background color of the current widget
    def setBackColor(self,color):
        directive=['setbackcolor',self.getAddName()+self.name,color]
        self.passDirective(directive)
    
    def setStyleSheet(self,styleString):
        directive=['setstylesheet',self.getAddName()+self.name,styleString]
        self.passDirective(directive)
    
    def setSpan(self,startRow,startColumn,endRow,endColumn):
        directive=['setspan',self.getAddName()+self.name,startRow,startColumn,endRow,endColumn]
        self.passDirective(directive)
        
    def scrollToRow(self,tableRow,tableColumn=1):
        directive=['scrolltorow',self.getAddName()+self.name,tableRow,tableColumn]
        self.passDirective(directive)
    
    #set the foreground color of the current widget
    def setForeColor(self,color):
        directive=['setforecolor',self.getAddName()+self.name,color]
        self.passDirective(directive)
            
    #set the enabled status of the current widget
    def setEnabled(self,enableSetting,immediate=True,subWidgetDat=""):
        directive=['setenabled',self.getAddName()+self.name,self.parent.spoolID,self.type,enableSetting,subWidgetDat]
        self.passDirective(directive)

    def setFormat(self,subWidgetDat,sformat):
        directive=['setformat',self.getAddName()+self.name,self.parent.spoolID,self.type,subWidgetDat,sformat]
        self.passDirective(directive)
        
    #set the enabled status of the current widget
    def setReadOnly(self,enableSetting,immediate=True):
        directive=['setreadonly',self.getAddName()+self.name,self.parent.spoolID,self.type,enableSetting]
        self.passDirective(directive)

    def setTitleText(self,theText,immediate=True):
        directive=['settitletext',self.getAddName()+self.name,self.parent.spoolID,self.type,theText]
        self.passDirective(directive)

    def addButtonListOptions(self,optionList):
        directive=['addbuttonlistoptions',self.getAddName()+self.name,self.parent.spoolID,self.type,optionList]
        self.passDirective(directive)

    #set the width of the current widget
    def setWidth(self,width,layoutPosition="a"):
        directive=['setwidth',self.getAddName()+self.name,self.parent.spoolID,self.type,width,layoutPosition]
        self.passDirective(directive)
        
    #set the widget of the current widget
    def setWidget(self,widget):
        if type(widget) != str:awidget=widget.name
        else:awidget=widget
        directive=['setwidget',self.getAddName()+self.name,self.parent.spoolID,awidget]
        self.passDirective(directive)
        
    #set the widget of the current widget
    def addWidget(self,widget):
        if type(widget) != str:awidget=widget.name
        else:awidget=widget
        directive=['addwidget',self.getAddName()+self.name,self.parent.spoolID,awidget]
        self.passDirective(directive)
        
    #set the layout of the current widget
    def setLayout(self,widget):
        if type(widget) != str:awidget=widget.name
        else:awidget=widget
        directive=['setlayout',self.getAddName()+self.name,self.parent.spoolID,awidget]
        self.passDirective(directive)
        
    def addWidgetRow(self,widget):
        if type(widget) != str:awidget=widget.name
        else:awidget=widget
        directive=['addwidgetrow',self.getAddName()+self.name,self.parent.spoolID,awidget]
        self.passDirective(directive)

    def setMinimumWidth(self,width):
        directive=['setminimumwidth',self.getAddName()+self.name,self.parent.spoolID,self.type,width]
        self.passDirective(directive)

    def setWidgetResizeable(self,abool):
        directive=['setwidgetresizeable',self.getAddName()+self.name,self.parent.spoolID,self.type,abool]
        self.passDirective(directive)

    def setFixedHeight(self,height):
        directive=['setfixedheight',self.getAddName()+self.name,self.parent.spoolID,self.type,height]
        self.passDirective(directive)

    #set the height of the current widget
    def setHeight(self,height,layoutPosition="a"):
        directive=['setheight',self.getAddName()+self.name,self.parent.spoolID,str(self.type),height,layoutPosition]
        self.passDirective(directive)

    def resize(self):
        directive=['resize',self.getAddName()+self.name,self.parent.spoolID,self.type]
        self.passDirective(directive)

    def setGeometry(self,geometry):
        directive=['setgeometry',self.getAddName()+self.name,self.parent.spoolID,self.type,geometry]
        self.passDirective(directive)

    #internal function used to delete something from the memory cache
    def delete(self,key):
        self.parent.startAPICall()
        self.parent.cache.delete(key)
        self.parent.stopAPICall()

    #internal function used to store something that the client can retrieve directly
    #such as data etc..
    def storedata(self,key,value):
        self.parent.startAPICall()
        if self.parent.env == "webgui":
            self.parent.cache.set(key,value)
        else:
            pickled_value = pickle.dumps(value)
            self.parent.cache.set(key,pickled_value)
        self.parent.stopAPICall()


    ##### functions for grid binding added

    def initGrid(self,gridClass,gridFilter,screenName,changeModClass="",searchLimit=500):
        self.gridClass          = gridClass
        self.gridFilter         = gridFilter
        self.filterName         = gridFilter
        self.screenName         = screenName
        self.changeModClass     = changeModClass
        self.currentColumnNames = []
        self.currentColumnTotals= []
        self.searchWidget       = None
        self.searchWidgetFields = []
        self.firstRunBind       = False
        self.searchLimit        = searchLimit
        self.gridKey            = []
        self.lastFocus          = ""
        self.lastdata           = {}
        self.lastdataKeys       = []
        self.columnDict         = {}
        self.hasSearchText      = False
        self.searchCallback     = ""
        self.kbCallback         = ""
        self.totCheckCallback   = ""
        self.filterDB           = ""
        self.secondaryLookup    = {}
        self.pageType           = ""
        self.searchSpec         = {}
        self.forceSortField     = ""
        self.groupByField       = []
        self.groupByRowData     = {}
        self.tosDict            = {}
        self.totalFields        = []
        self.colorRows          = []
        self.lockRows           = []
        self.fieldPosStore      = {}
        self.fieldSourceStore   = {}
        self.dataKeys           = []
        self.groupKeys          = []
        self.allKeys            = []
        self.ignoreMaster       = False

    def addSearchWidget(self,searchForm,searchWidget,searchButton,pageType="multi",*args):
        self.pageType           = pageType
        self.searchForm         = searchForm.name
        self.searchName         = searchWidget.name
        self.searchButton       = searchButton.name
        self.parentWidget.addSignal(searchForm,   "onButtonClick",   self.doSearchButton,returnvals=[searchWidget],calldefwidget=self)
        self.parentWidget.addSignal(searchForm,   "onKeyTimeout",    self.kbControls,keytimeout=700,sigallow=True,calldefwidget=self)
        
        self._initBind(self.gridFilter,pageType)
        self.searchWidgetFields = args
        self.gridKey = ["_id"]

    def addGroupBy(self,fieldName,ttlonSelect=[],*args):
        self.groupByField.append(fieldName)
        self.tosDict[fieldName] = ttlonSelect
        self.groupByRowData[fieldName] = args

    def initFilterMode(self,dbname,forceSortField="",secondaryLookup={}):
        import pymongo
        self.gridKey = ["_id"]
        self.filterDB = dbname
        self.secondaryLookup = secondaryLookup
        if forceSortField=="" and len(self.groupByField)>0:
            if len(self.groupByField)>1:
                sortlist = []
                for afield in self.groupByField[::-1]:
                    sortlist.append([afield,pymongo.ASCENDING])
                self.forceSortField=tuple(sortlist)
            else:
                self.forceSortField=self.groupByField[0]
        else:
            self.forceSortField = forceSortField
        self.addMenu(self.name+"headmenu","header")
        parentWidget = self.parentWidget
        if parentWidget is None:parentWidget = self.parent
        parentWidget.__dict__[self.name+"headmenu"].addMenuItem("MAIN","showmenu","Show Menu","SHOWFIELD.png")
        parentWidget.__dict__[self.name+"headmenu"].addMenuItem("MAIN","hidefield","Hide Field","HIDEFIELD.png") 
        parentWidget.__dict__[self.name+"headmenu"].addMenuItem("MAIN","refresh","Refresh","REFRESH.png")

        parentWidget.addSignal(self,  "onAfterCMove",      self.columnMove,calldefwidget=self,timeout=0)
        parentWidget.addSignal(self,  "onResizeEnd",       self.columnResize,calldefwidget=self,timeout=0)
        parentWidget.addSignal(self,  "onAfterSorting",    self.columnSort,calldefwidget=self,timeout=0)
        if self.forceSortField!="":
            parentWidget.addSignal(self,  "onBeforeSorting",    self.dumpSort,calldefwidget=self,sigallow=False)
        parentWidget.addSignal(parentWidget.__dict__[self.name+"headmenu"],  "onClick",   self.doHeaderMenu,calldefwidget=self)
        parentWidget.addSignal(self,  "onCheck",           self.gridCheck,calldefwidget=self,timeout=0)

    def dumpSort(self,*args):
        pass

    def doHeaderMenu(self,moduleName,*args):
        if moduleName=="showmenu":
            self.parent.currentShowMenuGridClass = self.gridClass
            self.parent.currentShowMenuGridFilter = self.gridFilter
            self.parent.currentGridWidgetName = self.name
            if self.parentWidget is None:
                self.parent.currentGridParentName = self.parent.name
            else:
                self.parent.currentGridParentName = self.parentWidget.name
            self.parent.dhxWins.createWindow("showMenu",400,350, "ajax","doDialogScreen","Show/Hide Menu",True,False,None,"SHOWMENU")
        elif moduleName=="refresh":
            self.runFilter()
        elif moduleName=="hidefield":
            print(moduleName,args)

    def setSearchSpec(self,key,value,aggregate=False):
        self.searchSpec[key]=value

    def addTotalField(self,totalField):
        self.totalFields.append(totalField)

    def addVarTotalField(self,selectField,totalField):
        self.totalFields.append([selectField,totalField])

    def getTotal(self,totalName):
        try:
            return float(self.currentColumnTotals[self.getFieldPosition(totalName)])
        except:
            return 0.00

    def runFilter(self,colorRows=[],lockRows=[]):
        if not colorRows==[]:self.colorRows = colorRows
        if not lockRows==[]:self.lockRows = lockRows
        self.fieldPosStore      = {}
        self.fieldSourceStore   = {}
        self.clearItems()
        adata,colnames,colwidths,colTotals,colTypes = self.getSearchDat(None,self.searchLimit)
        self.currentColumnNames = colnames
        self.currentColumnTotals = colTotals
        if colnames!=[]:
            for alock in self.lockRows:
                self.setTableRowNoSelect(alock)
            for acolor in self.colorRows:
                self.setTableRowStyles(*acolor)
            self.setTableColTypes(colTypes)
            self.setTableHeaders(colnames,[],[],colTotals)
            self.setTableWidths(colwidths)
            self.setColumnMoveEnabled()
            if "selectedRowKey" in self.__dict__ and type(self.selectedRowKey) is str:
                self.selectRowKey(self.selectedRowKey+"|")
                self.fillTableMany(adata,self.selectedRowKey+"|")
            else:
                self.fillTableMany(adata)
            self.setColumnMoveEnabled()
        else:
            self.fillTableMany([])
        if len(adata)>0:
            if "selectedRowKey" in self.__dict__:
                return self.selectedRowKey
            else:
                return adata[0][0].rstrip("|")
        return [""]

    def addSearchCallback(self,searchCallback):
        if not type(searchCallback) is str:self.searchCallback=searchCallback.__name__
        else:self.searchCallback = searchCallback

    def addKbCallback(self,kbCallback):
        if not type(kbCallback) is str:self.kbCallback=kbCallback.__name__
        else:self.kbCallback = kbCallback

    def addTotalCheckCallback(self,totCheckCallback):
        if not type(totCheckCallback) is str:self.totCheckCallback=totCheckCallback.__name__
        else:self.totCheckCallback = totCheckCallback

    def kbControls(self,arg1="",arg2="",arg3="",arg4=""):
        if self.kbCallback=="" or self.kbCallback=="None":kbCallbackFunction = None
        else:kbCallbackFunction = getattr(self.parentWidget, self.kbCallback)
        formWidget = self.parentWidget.__dict__[self.searchForm]

        #if arg3==self.searchButton:
        #    formWidget.setFocus("null");self.lastFocus="grid"
  
        if arg3==self.searchName:
            if arg1=="" and self.hasSearchText == True:
                self.hasSearchText = False
                if not kbCallbackFunction is None:kbCallbackFunction("searchform",arg1,arg2,arg3,arg4)
            elif arg1!="" and self.hasSearchText==False:
                self.hasSearchText = True
                if not kbCallbackFunction is None:kbCallbackFunction("searchform",arg1,arg2,arg3,arg4)
            if len(arg1)>2:
                self.doSearchButton("",arg1,arg2,arg3,arg4)
            elif arg2=="13":
                self.doSearchButton("",arg1,arg2,arg3,arg4)
        
        elif not kbCallbackFunction is None and arg3==self.name:
            kbCallbackFunction("grid",arg1,arg2,arg3,arg4)
            
        elif not kbCallbackFunction is None and (formWidget.hasWidget(arg1) or formWidget.hasWidget(arg3)):  # arg3 widgetname exists in the form
            kbCallbackFunction("searchform",arg1,arg2,arg3,arg4)
        elif not kbCallbackFunction is None and arg1==self.searchName:
            kbCallbackFunction("searchtext",arg1,arg2,arg3,arg4)

    def getFieldPosition(self,fieldName):
        if fieldName in self.fieldPosStore:return self.fieldPosStore[fieldName]
        usr4grids    = self.parent.db.usr4grids
        fdat =usr4grids.find_one({"gridclass":self.gridClass,
                                  "filtername":self.gridFilter,
                                  "fieldname":fieldName,
                                  "screenname":self.screenName.lower()})
        if fdat is None:
            return -1
        else:
            self.fieldPosStore[fieldName] = fdat["colorder"]
            return fdat["colorder"]

    def getFieldSource(self,position,returnIsFunc=False):
        isFunc = False
        if returnIsFunc:
            pass
        elif position in self.fieldSourceStore:
            return self.fieldSourceStore[position]
        usr4grids    = self.parent.db.usr4grids
        fdat =usr4grids.find_one({"gridclass":self.gridClass,
                                  "fieldname":{"$ne":'[NULL]'},
                                  "filtername":self.gridFilter,
                                  "colorder":int(position),
                                  "screenname":self.screenName.lower()})
        if fdat is None:
            if returnIsFunc:
                return "",isFunc
            else:
                return ""
        else:
            agridclass       = self.parent.maindb.yesgridclass
            gcdict = agridclass.find_one({"_id":ObjectId(fdat['fldclass_id'])})
            src = gcdict["source"]
            if "(" in src:
                if not "Julian" in src:isFunc=True
                src = src.split("(")[1].split(")")[0]
            if "," in src:
                if not "Julian" in src:isFunc = True
                src = src.split(",")[0]
            self.fieldSourceStore[position] = src
            if returnIsFunc:
                return src,isFunc
            else:
                return src

    def hideRows(self,keysOrKeyType="data"):
        self.parent.startAPICall()
        if type(keysOrKeyType) is list:
            keys = json.dumps(keysOrKeyType)
        elif keysOrKeyType=="group":
            keys = json.dumps(self.groupKeys)
        elif keysOrKeyType=="all":
            keys = json.dumps(self.dataKeys+self.groupKeys)
        elif keysOrKeyType=="data":
            keys = json.dumps(self.dataKeys)
        else:
            self.parent.stopAPICall()
            return
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['hiderows',self.getAddName()+self.name,self.parent.spoolID,str(self.type),keys]
        self.passDirective(directive)

    def showRows(self,keysOrKeyType="data"):
        self.parent.startAPICall()
        if type(keysOrKeyType) is list:
            keys = json.dumps(keysOrKeyType)
        elif keysOrKeyType=="group":
            keys = json.dumps(self.groupKeys)
        elif keysOrKeyType=="all":
            keys = json.dumps(self.dataKeys+self.groupKeys)
        elif keysOrKeyType=="data":
            keys = json.dumps(self.dataKeys)
        else:
            self.parent.stopAPICall()
            return
        if not self.parentWidget is None:addname = self.getAddName()
        else:addname=""
        #sender = self.getSender()
        directive=['showrows',self.getAddName()+self.name,self.parent.spoolID,str(self.type),keys]
        self.passDirective(directive) 

    def getSearchDat(self,searchText,limitOfSearch,keyOnly=""):

        useFilter = False
        if searchText is None or keyOnly!="":
            useFilter = True
        returnData = []
        agridclass       = self.parent.maindb.yesgridclass
        usr4grids        = self.parent.db.usr4grids
        gridcur          = self._getGrid(agridclass,usr4grids)
        if not useFilter:
            if len(self.searchWidgetFields)>2:
                firstSearchInfo = []
                for afld in self.searchWidgetFields[1]:
                    firstSearchInfo.append({afld.rstrip():{'$regex':".*"+re.escape(searchText)+".*","$options":"i"}})
                secSearchInfo = []
                for afld in self.searchWidgetFields[4]:
                    secSearchInfo.append({afld.rstrip():{'$regex':".*"+re.escape(searchText)+".*","$options":"i"}})
                vcursor = self.parent.db[self.searchWidgetFields[0]].find({"$or":firstSearchInfo}).limit(limitOfSearch)
                for vdata in vcursor:
                    secSearchInfo.append({self.searchWidgetFields[2]:vdata[self.searchWidgetFields[2]]})
                    if len(self.searchSpec.keys())>0:
                        secSearchInfo = [secSearchInfo]
                        hasSpecs = False
                        for key,value in self.searchSpec.items():
                            if not value is None:
                                hasSpecs = True
                                secSearchInfo.append({key:value})
                        if hasSpecs:secSearchInfo = {"$and":secSearchInfo}
                        else:secSearchInfo = secSearchInfo[0]
                                                  
                cursor = self.parent.db[self.searchWidgetFields[3]].find({"$or":secSearchInfo}).limit(limitOfSearch)
            else:
                firstSearchInfo = []
                for afld in self.searchWidgetFields[1]:
                    searchList = {afld.rstrip():{'$regex':".*"+re.escape(searchText)+".*","$options":"i"}}
                    if len(self.searchSpec.keys())>0:
                        searchList = [searchList]
                        hasSpecs = False
                        for key,value in self.searchSpec.items():
                            if not value is None:
                                hasSpecs = True
                                searchList.append({key:value})
                        if hasSpecs:searchList = {"$and":searchList}
                        else:searchList = searchList[0]
                    
                    firstSearchInfo.append(searchList)
                      
                    
                cursor = self.parent.db[self.searchWidgetFields[0]].find({"$or":firstSearchInfo}).limit(limitOfSearch)
        elif keyOnly!="":
            if self.filterDB!="":usedb = self.filterDB
            else:usedb = self.searchWidgetFields[0]
            cursor = self.parent.db[usedb].find({"_id":ObjectId(keyOnly)})
            if cursor.count()==0 and len(self.searchWidgetFields)>3:
                cursor = self.parent.db[self.searchWidgetFields[3]].find({"_id":ObjectId(keyOnly)})
        elif type(self.filterDB) is list:
            cursor = self.filterDB
        else:
            #build the cursor for the filter
            if self.ignoreMaster:
                rcursor = self.parent.db['usr4filterrules'].find({"screenname":self.screenName.lower(),"filtername":self.gridFilter})
            else:
                tcursor = self.parent.db['usr4filterrules'].find_one({"screenname":self.screenName.lower(),"filtername":self.gridFilter})
                if not tcursor is None:
                    rcursor = self.parent.db['usr4filterrules'].find({"$or":[{"screenname":"master","filtername":"MASTER"},{"screenname":self.screenName.lower(),"filtername":self.gridFilter}]})
                else:
                    rcursor = self.parent.db['usr4filterrules'].find({"screenname":self.screenName.lower(),"filtername":self.gridFilter})
            oplookup = {"EqualTo":"$eq","LessThan":"$lt","LessThan/EqualTo":"$lte","GreaterThan":"$gt","GreaterThan/EqualTo":"$gte","Not EqualTo":"$ne","Contains":"$regex"}
            searchDict = {}
            for rule in rcursor:
                usrfield = usr4grids.find_one({"fieldname":rule["rulefield"],"screenname":self.screenName.lower(),"filtername":self.gridFilter})
                if not usrfield is None: 
                    gcdict = agridclass.find_one({"_id":ObjectId(usrfield['fldclass_id'])})
                    if gcdict is None:
                        usr4grids.remove({"_id":usrfield["_id"]})
                        continue
                    actualField = gcdict['source']
                    convFunc = None
                    if "(" in actualField and ")" in actualField:
                        actualField = actualField.split("(")[1].split(")")[0].split(",")[0]
                        if "convertJulian" in gcdict['source']:convFunc = self.parent.toJulian
                
                    operation = oplookup[rule['rulesign']]
                    if gcdict['columntype']=="3" or gcdict['columntype']=="4" or gcdict['columntype']=="5" or gcdict['columntype']=="6" or gcdict['columntype']=="7" or gcdict['columntype']=="9":
                        try:
                            thevalue = int(rule["equalvalue"])
                        except:
                            thevalue = rule["equalvalue"] 
                    else:
                        thevalue = rule["equalvalue"]
                          
                    if not convFunc is None:
                        try:
                            thevalue=convFunc(thevalue)
                        except:
                            pass

                    if type(thevalue) is str:
                        if thevalue.upper()=="TODAY":thevalue=self.parent.toJulian()
                        elif thevalue.upper()=="TOMORROW":thevalue=self.parent.toJulian()+1
                        elif thevalue.upper()=="YESTERDAY":thevalue=self.parent.toJulian()-1

                    if searchDict == {}:
                        searchDict["$and"] = [{actualField:{operation:thevalue}}]
                    elif "$and" in searchDict:
                        searchDict["$and"].append({actualField:{operation:thevalue}})

                else:
                    print("rulefield " + rule["rulefield"] + " is missing from the grid")
            for key,value in self.searchSpec.items():
                if key=="$and" and "$and" in searchDict:
                    if type(value) is list:
                        for aitem in value:
                            searchDict[key].append(aitem)
                    else:
                        searchDict[key].append(value)
                else:
                    searchDict[key]=value
            if self.forceSortField != "":
                cursor = self.parent.db[self.filterDB].find(searchDict).sort(self.forceSortField).limit(limitOfSearch)
            else:
                sortcolumn,sortdir,isfunc = self.getSortInfo()
                if sortcolumn!="" and not isfunc:
                    direction = 1
                    if sortdir=="des":direction = -1
                    if self.secondaryLookup != {}:
                        cursor = self.parent.db[self.filterDB].aggregate([{"$match"  : searchDict},
                                                                          {"$lookup" : self.secondaryLookup},
                                                                          {"$sort"   : {sortcolumn:direction}}]).limit(limitOfSearch)
                    else:
                        cursor = self.parent.db[self.filterDB].find(searchDict).sort(sortcolumn,direction).limit(limitOfSearch)
                else:
                    if self.secondaryLookup != {}:
                        cursor = self.parent.db[self.filterDB].aggregate([{"$match"  : searchDict},
                                                                          {"$lookup" : self.secondaryLookup}]).limit(limitOfSearch)
                    else:
                        cursor = self.parent.db[self.filterDB].find(searchDict).limit(limitOfSearch)


        columnNames      = []
        columnWidths     = []
        columnTypes      = []
        columnDataFields = []
        self.columnDict  = {}
        for fielddict in gridcur:
            gcdict = agridclass.find_one({"_id":ObjectId(fielddict['fldclass_id'])})
            if gcdict is None:
                usr4grids.remove({"_id":fielddict["_id"]})
                continue
            columnWidths.append(fielddict['colwidth'])
            #columnNames.append(str(fielddict['fieldname']))
            columnNames.append(str(gcdict['columnname']))
            if int(fielddict['colorder']) in self.columnDict:
                self.columnDict[int(fielddict['colorder'])+.01]=str(fielddict['fieldname'])
            else:
                self.columnDict[int(fielddict['colorder'])]=str(fielddict['fieldname'])
            if gcdict['columntype']=="0":
                columnTypes.append("ro|str|left")
            elif gcdict['columntype']=="1":
                columnTypes.append("ro|str|center")
            elif gcdict['columntype']=="2":
                columnTypes.append("ro|str|right")
            elif gcdict['columntype']=="3":
                columnTypes.append("ron|price|right")
            elif gcdict['columntype']=="4":
                columnTypes.append("ron|int|right")
            elif gcdict['columntype']=="5":
                columnTypes.append("ron|int1|right")
            elif gcdict['columntype']=="6":
                columnTypes.append("ron|int2|right")
            elif gcdict['columntype']=="7":
                columnTypes.append("ron|int4|right")
            elif gcdict['columntype']=="8":
                acolType = "ch|str|left"
                for k,v in self.tosDict.items():
                    if len(v)>0:
                        if self.getFieldPosition(v[0])==int(fielddict['colorder']):
                            acolType = "oldch|str|left"
                columnTypes.append(acolType)
            elif gcdict['columntype']=="9":
                columnTypes.append("ro|date|left")
            elif gcdict['columntype']=="10":
                columnTypes.append("combo|str|left")
            elif gcdict['columntype']=="11":
                columnTypes.append("ed|str|left")
            else:
                columnTypes.append("ro")
            gsrc=gcdict['source']
            if "(" in gsrc:
                inparen = str(gsrc).split("(")[1].split(")")[0]
                columnDataFields.append([inparen.rstrip(),gsrc])
            else:
                columnDataFields.append([str(gsrc).rstrip(),str(gsrc).rstrip()])

        if keyOnly=="":
            self.lastdata = {}
            self.lastdataKeys = []
        try:
            gridDataMod = self.parent.getSoftwareModule(self.changeModClass.upper()).griddatamodule(self)
        except Exception as e:
            if not "mod_.pyc" in str(e):
                print("ERROR LOADING gridDataMod",str(e),formatExceptionInfo())
            gridDataMod = "empty"
        if len(self.totalFields)>0:
            columnTotals = [0] * len(columnNames)
        else:
            columnTotals = []
        if len(self.tosDict.keys())>0:
            columnTOSTotals = [0] * len(columnNames)
        else:
            columnTOSTotals = [] 
        if len(self.groupByField)>0:
            thisGroup = [""] * len(self.groupByField)
            lastLoopGroup = [None] * len(self.groupByField)
            lastLoopData = [None] * len(self.groupByField)
            thisGroupKey = ["ZZZ"] * len(self.groupByField)
            for d in range(0,len(thisGroupKey)):thisGroupKey[d]+=str(d)
            thisGroupSel = [""] * len(self.groupByField)
            groupTotals = [0.00] * len(self.groupByField)
        else:
            thisGroup = []
            lastLoopGroup = []
            lastLoopData = []
            thisGroupKey = []
            thisGroupSel = []
            groupTotals = []
        colorlist = ["#D2D2D2","#A2A2A2","#908100","#A3616C"]
        self.dataKeys = []
        self.groupKeys = []
        self.allKeys  = []
        for data in cursor:
            keydat      = ""
            firstKeyDat = ""
            for akey in self.gridKey:
                keydat+=str(data[akey])
                if not "|" in keydat:firstKeyDat=keydat
                keydat+="|"
            self.dataKeys.append(keydat)
            self.allKeys.append(keydat)
            rowData = [keydat]
            if len(self.totalFields)>0:
                columnTempTotals = [0] * len(columnNames)
            else:
                columnTempTotals = []

            showrow = True
            rowcolor = ""
            colCount = 0
            if len(self.groupByField)>0:
                cntgrp = 0
                for agroup in self.groupByField:
                    if agroup in data:
                        thisGroup[cntgrp] = str(data[agroup])
                        for grpadd in self.groupByField[cntgrp+1:]:
                            if grpadd in data:
                                thisGroup[cntgrp] += str(data[grpadd])
                    else:
                        thisGroup[cntgrp] = ""
                    if not lastLoopGroup[cntgrp] is None:
                        if thisGroup[cntgrp]!=lastLoopGroup[cntgrp]:
                            grpRowData = [thisGroupKey[cntgrp]]
                            for column,gsrc in columnDataFields:
                                if gsrc==agroup or gsrc in self.groupByField[cntgrp+1:]:
                                    if gsrc in lastLoopData[cntgrp]:
                                        grpRowData.append(lastLoopData[cntgrp][gsrc])
                                    else:
                                        grpRowData.append("")
                                else:
                                    grpRowData.append("")
                            ttlCol = self.getFieldPosition(self.tosDict[agroup][1])
                            self.setTableRowStyles(thisGroupKey[cntgrp],colorlist[cntgrp],"",[[ttlCol,"color:#FF002B;"]])
                            if agroup in self.tosDict:
                                if len(self.tosDict[agroup])>0:
                                    colNum = self.getFieldPosition(self.tosDict[agroup][0])
                                    ttlColNum = self.getFieldPosition(self.tosDict[agroup][1])
                                    selectOnValue = self.tosDict[agroup][2]
                                    if "false" in thisGroupSel[cntgrp]:
                                        if selectOnValue!="allhide":
                                            grpRowData[colNum+1]="false"
                                            self.setTableCellType(thisGroupKey[cntgrp],colNum,"ch","false")
                                    else:
                                        if selectOnValue!="allhide":
                                            grpRowData[colNum+1]="true"
                                            self.setTableCellType(thisGroupKey[cntgrp],colNum,"ch","true")
                                    for rcWrite in self.groupByRowData[agroup]:
                                        rcCol = self.getFieldPosition(rcWrite[0])
                                        rcColName = self.getFieldSource(rcCol)
                                        #convert lastLoopData field into a string to be piped into the string for the grid
                                        if rcColName in lastLoopData[cntgrp]:
                                            lastLoopData[cntgrp][rcColName] =  str(lastLoopData[cntgrp][rcColName])
                                            grpRowData[rcCol+1]=str(rcWrite[1] % lastLoopData[cntgrp])
                                            if len(rcWrite)>2:
                                                self.setTableRowStyles(thisGroupKey[cntgrp],colorlist[cntgrp],"",[[rcCol,rcWrite[2]]])


                                    grpRowData[ttlColNum+1] = "%.2f" % float(groupTotals[cntgrp])
                            self.lastdata[thisGroupKey[cntgrp]]=grpRowData
                            self.lastdataKeys.append(thisGroupKey[cntgrp])
                            self.groupKeys.append(thisGroupKey[cntgrp])
                            self.allKeys.append(thisGroupKey[cntgrp])
                            returnData.append(grpRowData)
                            #clear group key after row from prev loop was added
                            thisGroupKey[cntgrp] = "ZZZ"+str(cntgrp)
                            thisGroupSel[cntgrp] = ""
                            groupTotals[cntgrp] = 0.00
                            #if len(self.tosDict.keys())>0:
                            #    columnTOSTotals = [0] * len(columnNames)
                            #else:
                            #    columnTOSTotals = []

                    #build the group key for the group row
                    thisGroupKey[cntgrp]+="|"+str(data["_id"])
                    #build the group sel so that I can tell if the group should be checked or not
                    if len(self.tosDict[agroup])>0:
                        asrc = self.getFieldSource(self.getFieldPosition(self.tosDict[agroup][0]))
                        if asrc in data:
                            thisGroupSel[cntgrp]+="|"+str(data[asrc])
                        else:
                            thisGroupSel[cntgrp]+="|false"
                    else:
                        thisGroupSel[cntgrp]+="|false"
                    cntgrp+=1

            for column,gsrc in columnDataFields:
                newdat = self.getDataModInfo(column,gsrc,gridDataMod,data)
                if type(newdat) is list and len(newdat)==2:
                    newdat, showrow = newdat
                elif type(newdat) is list and len(newdat)==3:
                    newdat, showrow, rowcolor = newdat
                rowData.append(newdat)
                if not showrow:break
                if len(self.tosDict.keys())>0:
                    for atoskey,atos in self.tosDict.items():
                        if len(atos)>0:
                            if atos[1] == columnNames[colCount]:
                                try:
                                    columnTOSTotals[colCount]+=float(data[column.rstrip()])
                                except Exception as e:
                                    pass

                colCount+=1

            # add the totals buckets up (this is based on sort order for groupings and each bucket gets cleared when its dropped into a grouping
            for atotalField in self.totalFields:
                if type(atotalField) is list:
                    selColNum = self.getFieldPosition(atotalField[0])
                    selColSrc = self.getFieldSource(selColNum)
                    colNum = self.getFieldPosition(atotalField[1])
                    colSrc = self.getFieldSource(colNum)
                    if selColSrc in data and data[selColSrc] == "true":
                        try:
                            columnTempTotals[colNum]+=float(data[colSrc])
                        except:
                            pass
                else:
                    colNum = self.getFieldPosition(atotalField)
                    colSrc = self.getFieldSource(colNum)
                    try:
                        columnTempTotals[colNum]+=float(data[colSrc])
                    except Exception as e:
                        print("adding totals error ",e,"colSrc",colSrc,"TotalField",atotalField,"colNum",colNum,"colTempTotals",columnTempTotals)
            gcnt = 0
            for agrp in self.groupByField:
                colNum = self.getFieldPosition(self.tosDict[agrp][1])
                ckColNum = self.getFieldPosition(self.tosDict[agrp][0])
                totalKey = self.tosDict[agrp][2]
                if totalKey != "all" and totalKey != "allhide":
                    if rowData[ckColNum+1]==totalKey:
                        try:
                            groupTotals[gcnt]+=float(rowData[colNum+1])
                        except:
                             pass
                else:
                    try:
                        groupTotals[gcnt]+=float(rowData[colNum+1])
                    except:
                        pass
                gcnt+=1
            if self.groupByField!=[]:
                cntgrp=0
                for agroup in self.groupByField:
                    if agroup in data:
                        lastLoopGroup[cntgrp] = str(data[agroup])
                        for grpadd in self.groupByField[cntgrp+1:]:
                            if grpadd in data:
                                lastLoopGroup[cntgrp] += str(data[grpadd])
                        lastLoopData[cntgrp] = data
                    else:
                        lastLoopGroup[cntgrp] = ""
                        lastLoopData[cntgrp] = {}
                    cntgrp+=1
            if showrow:
                if len(self.totalFields)>0:
                    cnt=0
                    for colTot in columnTempTotals:
                        columnTotals[cnt]+=colTot
                        cnt+=1
                returnData.append(rowData)
                if rowcolor!="":
                    self.setTableRowStyles(rowData[0],rowcolor)
            if len(self.tosDict.keys())>0:
                cnt=0
                for colTot in columnTOSTotals:
                    columnTOSTotals[cnt]+=colTot
                    cnt+=1
            if keyOnly=="" and showrow:
                self.lastdata[firstKeyDat]=data
                self.lastdataKeys.append(firstKeyDat)
        if self.groupByField!=[]:
            cntgrp = 0
            for agroup in self.groupByField:
                if not lastLoopGroup[cntgrp] is None:
                    grpRowData = [thisGroupKey[cntgrp]]
                    for column,gsrc in columnDataFields:
                        if gsrc==agroup or gsrc in self.groupByField[cntgrp+1:]:
                            grpRowData.append(lastLoopData[cntgrp][gsrc])
                        else:
                            grpRowData.append("")
                    returnData.append(grpRowData)
                    self.lastdata[thisGroupKey[cntgrp]]=grpRowData
                    self.lastdataKeys.append(thisGroupKey[cntgrp])
                    self.groupKeys.append(thisGroupKey[cntgrp])
                    ttlCol = self.getFieldPosition(self.tosDict[agroup][1])
                    self.setTableRowStyles(thisGroupKey[cntgrp],colorlist[cntgrp],"",[[ttlCol,"color:#FF002B;"]])
                    if agroup in self.tosDict:
                        if len(self.tosDict[agroup])>0:
                            colNum = self.getFieldPosition(self.tosDict[agroup][0])
                            selectOnValue = self.tosDict[agroup][2]
                            if "false" in thisGroupSel[cntgrp]:
                                if selectOnValue!="allhide":
                                    grpRowData[colNum+1]="false"
                                    self.setTableCellType(thisGroupKey[cntgrp],colNum,"ch","false")
                            else:
                                if selectOnValue!="allhide":
                                    grpRowData[colNum+1]="true"
                                    self.setTableCellType(thisGroupKey[cntgrp],colNum,"ch","true")
                            grpRowData[ttlCol+1] = "%.2f" % float(groupTotals[cntgrp])
                            for rcWrite in self.groupByRowData[agroup]:
                                rcCol = self.getFieldPosition(rcWrite[0])
                                rcColName = self.getFieldSource(rcCol)
                                #convert lastLoopData field into a string to be piped into the string for the grid
                                lastLoopData[cntgrp][rcColName] =  str(lastLoopData[cntgrp][rcColName])
                                grpRowData[rcCol+1]=str(rcWrite[1] % lastLoopData[cntgrp])
                                if len(rcWrite)>2:
                                    self.setTableRowStyles(thisGroupKey[cntgrp],colorlist[cntgrp],"",[[rcCol,rcWrite[2]]])
                cntgrp+=1
        columnTotalFinal = []
        for ctotal in columnTotals:
            if float(ctotal)!=0.00:
                columnTotalFinal.append("%.2f" % float(ctotal))
            else:
                columnTotalFinal.append("")
        self.currentGroupTotals = groupTotals
        if self.forceSortField == "":
            sortcolumn,sortdir,isfunc = self.getSortInfo(True)
            if isfunc:
                returnData.sort(key= lambda row: row[sortcolumn+1],reverse=sortdir)

        return returnData,columnNames,columnWidths,columnTotalFinal,columnTypes

    def getDataModInfo(self,column,gsrc,gridDataMod,data):
        if str(gsrc)!=str(column) and "(" in str(gsrc) and gridDataMod!="empty":
            srcfield = gsrc.split("(",1)
            fields = srcfield[1].rstrip().rstrip(")").split(",")
            fieldargs = []
            for afield in fields:
                if afield=="self":
                    continue
                elif afield.rstrip() in data:
                    fieldargs.append(data[afield.rstrip()])
                elif '"' in afield or "'" in afield:
                    fieldargs.append(str(afield).lstrip("'").lstrip('"').rstrip("'").rstrip('"'))
                else:
                    fieldargs.append(str(afield))
            try:
                newdat = getattr(gridDataMod, srcfield[0])(*fieldargs)
            except Exception as e:
                print("Function Error ",str(e), gridDataMod, srcfield[0])
                newdat = fieldargs[0]
            retdat = newdat
        elif not column.rstrip() in data:
            retdat = ""
        else:
            retdat = str(data[column.rstrip()])
        return retdat

    def doSearchButton(self,moduleName,arg1="",arg2="",arg3="",arg4=""):
        searchBox = self.parentWidget.__dict__[self.searchName]
        theGrid = self
        colnames = []
        #try:
        if 1==1:
            if arg3==self.searchName:
                inText=arg1.lower()
            else:
                inText = searchBox.value
            adata = []
            if inText!="":
                adata,colnames,colwidths,colTotals,colTypes = theGrid.getSearchDat(inText,self.searchLimit)
                self.currentColumnNames = colnames
                self.currentColumnTotals = colTotals
        
            if colnames!=[]:
                theGrid.clearItems()
                theGrid.setTableHeaders(colnames,[],[],colTotals)
                theGrid.setTableColTypes(colTypes)
                theGrid.setTableWidths(colwidths)
                theGrid.fillTableMany(adata)
                theGrid.setColumnMoveEnabled()
                if len(adata)>0 and self.pageType=="single":
                    theGrid.doSearchCallback(adata[0][0],"","") 
            else:
                theGrid.clearItems()
                theGrid.fillTableMany([])
                theGrid.setColumnMoveEnabled()

    def _getGrid(self,agridclass,griddb):
        #this function returns the grid cursor (creates if does not exists for user and adds fields that may not exists yet)
        gridcur = griddb.find({"gridclass":self.gridClass,
                               "fieldname":{"$ne":'[NULL]'},
                               "filtername":self.gridFilter,
                               "screenname":self.screenName.lower()}).sort("colorder")
        fieldItems = agridclass.find({"$and":[{"classname":str(self.gridClass)},{"colorder":{"$gte":0}}]},{"_id":1,"columnname":1}).sort("colorder")
        try:
            import pymongo
            lastDat=agridclass.find({"$and":[{"classname":str(self.gridClass)},{"colorder":{"$gte":0}}]},{"_id":1,"colorder":1}).sort([("colorder",pymongo.DESCENDING)])[0]
            lastCol = lastDat["colorder"]
        except:
            lastCol = 99
        #found data so go see if there are some new fields to add
        if gridcur.count()>0:
            for fieldItem in fieldItems:
                acur = griddb.find_one({"fldclass_id":str(fieldItem['_id']),"filtername":self.gridFilter})
                if not acur:
                    lastCol+=1
                    recdict = {}
                    recdict['screenname']    = self.screenName.lower()
                    recdict['gridclass']     = self.gridClass
                    recdict['filtername']    = self.gridFilter
                    recdict['fieldname']     = fieldItem['columnname']
                    recdict['colorder']      = lastCol
                    recdict['colwidth']      = 0
                    recdict['sortflag']      = 0
                    recdict['sortdirection'] = ''
                    recdict['fldclass_id']   = str(fieldItem['_id'])
                    griddb.save(recdict,w=0)
            
        #no data found so go create the whole grid locally
        else:
            cnt=0
            for fieldItem in fieldItems:
                if cnt==0:
                     #create the header if any fields exists
                     recdict = {}
                     recdict['screenname']  =  self.screenName.lower()
                     recdict['gridclass']   =  self.gridClass
                     recdict['filtername']  =  self.gridFilter
                     recdict['fieldname']   =  "[NULL]"
                     recdict['colorder']    =  -1
                     recdict['colwidth']    =  0
                     recdict['sortflag']    =  ''
                     recdict['sortdirection'] =  "asc"
                     recdict['screenname']  =  self.screenName.lower()
                     recdict['fldclass_id'] =  ""
                     griddb.save(recdict,w=0)
                recdict = {}
                # create each field
                recdict['screenname']    = self.screenName.lower()
                recdict['gridclass']     = self.gridClass
                recdict['filtername']    = self.gridFilter
                recdict['fieldname']     = fieldItem['columnname']
                recdict['colorder']      = cnt
                recdict['colwidth']      = 100
                recdict['sortflag']      = 0
                recdict['sortdirection'] = ''
                recdict['fldclass_id']   = str(fieldItem['_id'])
                griddb.save(recdict,w=0)
                cnt+=1
            gridcur = griddb.find({"fieldname":{"$ne":'[NULL]'},
                                   "filtername":self.gridFilter,
                                   "screenname":self.screenName.lower()}).sort("colorder")
        return gridcur

    def columnMove(self,startPosition,newPosition):
        colList = sorted(self.columnDict.keys())
        if int(startPosition)<int(newPosition):adj=.5
        else:adj=-.5
        aval = self.columnDict[int(colList[int(startPosition)])]
        del self.columnDict[int(colList[int(startPosition)])]
        self.columnDict[int(colList[int(newPosition)])+adj] = aval
        cnt=0
        usr4grids        = self.parent.db.usr4grids
        newDict = {}
        for a in sorted(self.columnDict.keys()):
            usr4grids.update_one({"gridclass":self.gridClass,"fieldname":self.columnDict[a],"filtername":self.filterName,"screenname":self.screenName.lower()},{"$set":{"colorder":cnt}})
            newDict[cnt] = self.columnDict[a]
            cnt+=1
        self.columnDict = newDict
        self.fieldSourceStore = {}
        if len(self.groupByField)<=0:
            adata,colnames,colwidths,colTotals,colTypes = self.getSearchDat(None,self.searchLimit)
            self.currentColumnNames = colnames
            self.currentColumnTotals = colTotals
        else:
            self.runFilter()

    def columnResize(self,columnNum,columnWidth,widgetName):
        colList = sorted(self.columnDict.keys())
        usr4grids        = self.parent.db.usr4grids
        usr4grids.update_one({"gridclass":self.gridClass,"fieldname":self.columnDict[colList[int(columnNum)]],"filtername":self.filterName,"screenname":self.screenName.lower()},{"$set":{"colwidth":int(columnWidth)}})

    def columnSort(self,columnNum,columnType,direction):
        colList = sorted(self.columnDict.keys())
        usr4grids        = self.parent.db.usr4grids
        usr4grids.update_one({"gridclass":self.gridClass,"filtername":self.filterName,"screenname":self.screenName.lower(),"colorder":-1},{"$set":{"sortflag":self.columnDict[colList[int(columnNum)]],"sortdirection":direction}})

    def getSortInfo(self,listSort=False):
        if listSort:
            sortcolumn = 0
            sortdir    = False
            isFunc     = False
        else:
            sortcolumn = ""
            sortdir    = "asc"
            isFunc     = False
        usr4grids  = self.parent.db.usr4grids
        gridInfo   = usr4grids.find_one({"gridclass":self.gridClass,"filtername":self.filterName,"screenname":self.screenName.lower(),"colorder":-1})
        if not gridInfo is None:
            if "sortdirection" in gridInfo:
                if "asc" in gridInfo["sortdirection"] or "des" in gridInfo["sortdirection"]:
                    sortdir = gridInfo["sortdirection"]
                    if listSort:
                        if sortdir=="asc":sortdir=False
                        elif sortdir=="des":sortdir=True
            if "sortflag" in gridInfo:
                if str(gridInfo["sortflag"])!="0":
                    sortcolumn = self.getFieldPosition(gridInfo["sortflag"])
                    if not listSort:
                        sortcolumn,isFunc = self.getFieldSource(int(sortcolumn),True)
                    else:
                        nocol,isFunc = self.getFieldSource(int(sortcolumn),True)
        if sortcolumn=="":sortcolumn="_id"
        return sortcolumn,sortdir,isFunc

    def doSearchCallback(self,*args):
        if self.searchCallback=="" or self.searchCallback=="None":searchCallbackFunction = None
        else:searchCallbackFunction = getattr(self.parentWidget, self.searchCallback)
        if not searchCallbackFunction is None:
            searchCallbackFunction(*args)

    def gridCheck(self,rowId,columnId,checkState):
        if "ZZZ" in rowId:
            rowIdList = rowId.split("|")[1:]
        else:
            rowIdList = [rowId.split("|")[0]]

        srcfield = self.getFieldSource(int(columnId))
        for aRowId in rowIdList:
            self.parent.db[self.filterDB].update_one({"_id":ObjectId(aRowId)},{"$set":{srcfield:checkState}})
            self.lastdata[aRowId][srcfield]=checkState

        if "ZZZ" in rowId:
            rowIdList = rowId.split("|")[1:]
            columnTotals = [0.00] * len(self.currentColumnTotals)
            groupTotals = [0.00] * len(self.groupByField)
            for aRowId in self.lastdataKeys:
                #if it is a group by row and its not the current row then handle it
                if "ZZZ" in aRowId and aRowId!=rowId:
                    aRowIdList = aRowId.split("|")[1:]
                    if set(aRowIdList).issubset(set(rowIdList)):
                        self.setTableCellValue(aRowId,columnId,checkState)
                        self.lastdata[aRowId][int(columnId)+1]=checkState
                #if it is not a group by row
                elif not "ZZZ" in aRowId:
                    for atotalField in self.totalFields:
                        if type(atotalField) is list:
                            selColNum = self.getFieldPosition(atotalField[0])
                            selColSrc = self.getFieldSource(selColNum)
                            colNum = self.getFieldPosition(atotalField[1])
                            colSrc = self.getFieldSource(colNum)
                            if selColSrc in self.lastdata[aRowId] and self.lastdata[aRowId][selColSrc] == "true":
                                try:
                                    columnTotals[colNum]+=float(self.lastdata[aRowId][colSrc])
                                except:
                                    pass
                        else:
                            colNum = self.getFieldPosition(atotalField)
                            colSrc = self.getFieldSource(colNum)
                            try:
                                columnTotals[colNum]+=float(self.lastdata[aRowId][colSrc])
                            except:
                                pass
                    cnt = 0
                    for agrp in self.groupByField:
                        colNum = self.getFieldPosition(self.tosDict[agrp][1])
                        colName = self.getFieldSource(colNum)
                        ckColNum = self.getFieldPosition(self.tosDict[agrp][0])
                        ckColName = self.getFieldSource(ckColNum)
                        totalKey = self.tosDict[agrp][2]
                        if totalKey !="all" and totalKey!="allhide":
                            if ckColName in self.lastdata[aRowId] and  self.lastdata[aRowId][ckColName]==totalKey:
                                try:
                                    groupTotals[cnt]+=float(self.lastdata[aRowId][colName])
                                except:
                                    pass
                        else:
                             if ckColName in self.lastdata[aRowId]:
                                 try:
                                     groupTotals[cnt]+=float(self.lastdata[aRowId][colName])
                                 except:
                                     pass
                        cnt+=1
                    continue
               
                #if "ZZZ" in aRowId and aRowId!=rowId:
                #if checkState=="false" and  set(rowIdList).issubset(set(aRowId.split("|")[1:])):
                #    self.setTableCellValue(aRowId,columnId,checkState)
                #    self.lastdata[aRowId][int(columnId)+1]=checkState
                #elif checkState=="true":
                #    pass

                grpLevel = int(aRowId.split("|")[0].replace("ZZZ",""))
                grpName = self.groupByField[grpLevel]
                if self.tosDict[grpName][2]!="all" and self.tosDict[grpName][2]!="allhide":
                    colNum = self.getFieldPosition(self.tosDict[grpName][1])
                    self.setTableCellValue(aRowId,colNum,groupTotals[grpLevel])
                groupTotals[grpLevel]=0.00
        else:
            #rowIdList = rowId.split("|")[1:]
            columnTotals = [0.00] * len(self.currentColumnTotals)
            for aRowId in self.lastdataKeys:
                for atotalField in self.totalFields:
                    if type(atotalField) is list:
                        selColNum = self.getFieldPosition(atotalField[0])
                        selColSrc = self.getFieldSource(selColNum)
                        colNum = self.getFieldPosition(atotalField[1])
                        colSrc = self.getFieldSource(colNum)
                        if selColSrc in  self.lastdata[aRowId] and self.lastdata[aRowId][selColSrc] == "true":
                            try:
                                columnTotals[colNum]+=float(self.lastdata[aRowId][colSrc])
                            except:
                                pass
                    else:
                        colNum = self.getFieldPosition(atotalField)
                        colSrc = self.getFieldSource(colNum)
                        try:
                            columnTotals[colNum]+=float(self.lastdata[aRowId][colSrc])
                        except:
                            pass

        colTotals = []
        for acolTotal in columnTotals:
            if acolTotal==0.00:
                colTotals.append("")
            else:
                colTotals.append("%.2f" % float(acolTotal))
        if self.currentColumnTotals != colTotals:
            self.updateFooter(colTotals)
            self.currentColumnTotals = colTotals
        if self.totCheckCallback=="" or self.totCheckCallback=="None":
            totCheckCallbackFunction = None
        else:
            totCheckCallbackFunction = getattr(self.parentWidget, self.totCheckCallback)
            totCheckCallbackFunction("checktotal",rowId,columnId,checkState)

    def _initBind(self,gridFilter,pageType):
        #self.addMenu("amenu")
        #self.parentWidget.amenu.addMenuItem("MAIN","select","Select Customer","BACK.png")
        self.addMenu("bmenu","header")
        self.parentWidget.bmenu.addMenuItem("MAIN","showmenu","Show Menu","SHOWFIELD.png")
        self.parentWidget.bmenu.addMenuItem("MAIN","hidefield","Hide Field","HIDEFIELD.png")
        self.parentWidget.bmenu.addMenuItem("MAIN","refresh","Hide Field","REFRESH.png")
        #TODO Hook the below signals to real functions
        #self.parentWidget.addSignal(self.parentWidget.amenu, "onClick",  ,calldefwidget=self)
        self.parentWidget.addSignal(self.parentWidget.bmenu, "onClick", self.doHeaderMenu,  calldefwidget=self)
        if pageType=="multi":
            self.parentWidget.addSignal(self,   "onRowDblClicked",  self.doSearchCallback,calldefwidget=self)
            self.parentWidget.addSignal(self,   'onKeyPress',       self.kbControls,sigallow=True,calldefwidget=self,returnvals=[self])
        else:
            #self.parentWidget.addSignal(self,   'onBeforeSelect',   self.doSearchCallback,sigallow=True,calldefwidget=self)
            self.parentWidget.addSignal(self,   'onRowSelect',      self.doSearchCallback,calldefwidget=self)
            self.parentWidget.addSignal(self,   'onKeyPress',       self.kbControls,sigallow=True,calldefwidget=self)
            self.parentWidget.addSignal(self.parentWidget.__dict__[self.searchForm],  "onFocus", self.kbControls,calldefwidget=self,returnvals=[self])

        self.parentWidget.addSignal(self,  "onAfterCMove",      self.columnMove,calldefwidget=self)
        self.parentWidget.addSignal(self,  "onResizeEnd",       self.columnResize,calldefwidget=self)
        self.parentWidget.addSignal(self,  "onAfterSorting",    self.columnSort,calldefwidget=self)
        self.parentWidget.addSignal(self,  "onCheck",           self.gridCheck,calldefwidget=self)

class genjson:
    def __init__(self):
        self.json={}
        self.level=0
        self.removeAmount=0
        self.currStack = []
        self.currStackCount = {}

    def resetXML(self):
        self.json={}
        self.level=0

    def startTag(self,name,tagtype="text"):
        self.level+=1
        if self.level>1:
            adict = self.json
            for d in self.currStack:
                adict = adict[d]
                if len(self.currStack)>0 and self.currStackCount[d]>=0:
                    adict = adict[self.currStackCount[d]]
            self.currStack.append(name)
            if name in adict:
                if not type(adict[name]) is list:
                    adict[name]=[adict[name]]
                #bump it an extra time because someone forgot to declare it as an array
                if self.currStackCount[name]==-1:self.currStackCount[name]+=1
                self.currStackCount[name]+=1
                adict[name].append({})
            else:
                if tagtype.lower()=="array":
                    adict[name] = [{}]
                    self.currStackCount[name]=0
                else:
                    adict[name] = {}
                    self.currStackCount[name]=-1

    def endTag(self,name):
        self.level-=1
        if len(self.currStack)!=0:
            #self.currStackCount[self.currStack[-1]]=0
            del self.currStack[-1]

    def addValue(self,name,value,maxsize=-1):
        self.removeAmount=0
        if maxsize>0:
            if len(value)>maxsize:
                self.removeAmount=len(value)-maxsize
                value=value[0:maxsize]
        if type(value) is str or type(value) is unicode:
            value = value.replace("&","&amp;").replace('"',"&quot;").replace("<","&lt;").replace(">","&gt;").replace("'","&apos;").rstrip(" ")
        adict = self.json
        for d in self.currStack:
            adict = adict[d]
            if len(self.currStack)>0 and self.currStackCount[d]>=0:
                adict = adict[self.currStackCount[d]]
        if type(adict) is list:
            adict[name].append(value)
        else:
            adict[name]=value

    def addValues(self,valdict):
        for name,value in valdict.items():
            self.addValue(name,value)

class genxml:
    def __init__(self):
        self.xml=""
        self.level=0
        self.removeAmount=0

    def resetXML(self):
        self.xml=""
        self.level=0

    def startTag(self,name,*args):
        self.level+=1
        self.xml+="<"+name+">"+"\n"+((self.level*4)*" ")

    def endTag(self,name):
        checkfor = (4*" ")
        if self.xml[-len(checkfor):]==checkfor:self.xml=self.xml[0:-4]
        self.level-=1
        self.xml+="</"+name+">"+"\n"+((self.level*4)*" ")

    def addValue(self,name,value,maxsize=-1):
        self.removeAmount=0
        value=str(value)
        if maxsize>0:
            if len(value)>maxsize:
                self.removeAmount=len(value)-maxsize
                value=value[0:maxsize]
        value = value.replace("&","&amp;").replace('"',"&quot;").replace("<","&lt;").replace(">","&gt;").replace("'","&apos;")
        self.xml+="<"+name+">"+str(value)+"</"+name+">"+"\n"+((self.level*4)*" ")

    def addValues(self,valdict):
        for name,value in valdict.items():
            self.addValue(name,str(value))


def tr(words):
    return words

